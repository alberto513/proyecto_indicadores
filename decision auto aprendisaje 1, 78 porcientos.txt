using System;
using System.IO;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Data;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.NinjaScript.Indicators;

namespace NinjaTrader.NinjaScript.Indicators
{
    public enum AutoLearnModes
    {
        Off,
        Passive,
        Active
    }

    public class MagnoDecisionScore_v1 : Indicator
    {
        [NinjaScriptProperty]
        public int CooldownBars { get; set; } = 1;

        [NinjaScriptProperty]
        public int SignalPoints { get; set; } = 40;

        [NinjaScriptProperty]
        public int TakeProfitTicks { get; set; } = 20;

        [NinjaScriptProperty]
        public int StopLossTicks { get; set; } = 20;

        [NinjaScriptProperty]
        public double VolumeThreshold { get; set; } = 1.5;

        [NinjaScriptProperty]
        public double SlopeMin { get; set; } = 0.035;

        [NinjaScriptProperty]
        public double BodyContextRatio { get; set; } = 0.4;

        [NinjaScriptProperty]
        public int MinScoreToTrade { get; set; } = 5;

        [NinjaScriptProperty]
        public bool EnablePrints { get; set; } = true;

        [NinjaScriptProperty]
        public bool EnableCsvLog { get; set; } = true;

        [NinjaScriptProperty]
        [Display(Name = "AutoLearnMode", Order = 20, GroupName = "Parameters")]
        public AutoLearnModes AutoLearnMode { get; set; } = AutoLearnModes.Off;

        [NinjaScriptProperty]
        [Display(Name = "AutoLearnDays", Order = 21, GroupName = "Parameters")]
        public int AutoLearnDays { get; set; } = 5;

        [NinjaScriptProperty]
        [Display(Name = "MinTradesForAutoLearn", Order = 22, GroupName = "Parameters")]
        public int MinTradesForAutoLearn { get; set; } = 50;

        [NinjaScriptProperty]
        public int WrFontSize { get; set; } = 14;

        [NinjaScriptProperty]
        public TextPosition WrPanelPosition { get; set; } = TextPosition.TopRight;

        [NinjaScriptProperty]
        [XmlIgnore]
        public Brush LongArrowColor { get; set; } = Brushes.Lime;

        [Browsable(false)]
        public string LongArrowColorSerializable
        {
            get { return LongArrowColor.ToString(); }
            set { LongArrowColor = (Brush)new BrushConverter().ConvertFromString(value); }
        }

        [NinjaScriptProperty]
        [XmlIgnore]
        public Brush ShortArrowColor { get; set; } = Brushes.Red;

        [Browsable(false)]
        public string ShortArrowColorSerializable
        {
            get { return ShortArrowColor.ToString(); }
            set { ShortArrowColor = (Brush)new BrushConverter().ConvertFromString(value); }
        }

        private EMA ema14;
        private SMA volSma;
        private SMA sma20;
        private ATR atr14;
        private MACD macd;
        private int lastSignalBar = -1000;
        private StreamWriter logW;

        // Variables WR
        private int totalTrades = 0;
        private int totalTP = 0;
        private int totalSL = 0;
        private double wrPercent = 0;

        private class SignalData
        {
            public DateTime SignalTime;
            public double EntryPrice;
            public double TP;
            public double SL;
            public bool IsLong;
            public bool InTrade;
            public int Score;
            public double SlopeVal;
            public double VolRatioVal;
            public double BodyRatioVal;
            public double SpaceTicks;
            public double MacdHist;
            public double ExtDistTicks;
        }

        private SignalData signal;

        private class TradeStats
        {
            public int Total;
            public int TP;
        }

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "MagnoDecisionScore_v1";
                Calculate = Calculate.OnBarClose;
                IsOverlay = true;
                AddPlot(Brushes.Transparent, "DecisionPlot");
            }
            else if (State == State.DataLoaded)
            {
                ema14 = EMA(14);
                volSma = SMA(Volume, 14);
                sma20 = SMA(20);
                atr14 = ATR(14);
                macd = MACD(12, 26, 9);

                if (EnableCsvLog)
                {
                    string path = System.IO.Path.Combine(NinjaTrader.Core.Globals.UserDataDir, "MagnoDecisionScore_log.csv");
                    bool newFile = !File.Exists(path);
                    logW = new StreamWriter(path, true);
                    if (newFile)
                        logW.WriteLine("Time,Dir,Entry,TP,SL,Score,Slope,VolRatio,BodyRatio,SpaceTicks,MACDHist,ExtDistTicks,Result");
                }

                if (AutoLearnMode != AutoLearnModes.Off)
                    ApplyAutoLearn();
            }
            else if (State == State.Terminated)
            {
                if (logW != null)
                {
                    logW.Flush();
                    logW.Close();
                    logW = null;
                }
            }
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < 20)
                return;

            // Gestión de trade abierto
            if (signal != null)
            {
                if (signal.InTrade)
                {
                    bool hitTP = signal.IsLong ? High[0] >= signal.TP : Low[0] <= signal.TP;
                    bool hitSL = signal.IsLong ? Low[0] <= signal.SL : High[0] >= signal.SL;

                    if (hitTP || hitSL)
                    {
                        totalTrades++;
                        if (hitTP) totalTP++;
                        if (hitSL) totalSL++;
                        wrPercent = totalTrades > 0 ? (double)totalTP / totalTrades * 100 : 0;

                        string res = hitTP ? "TP" : "SL";
                        string dir = signal.IsLong ? "LONG" : "SHORT";
                        if (EnablePrints)
                            Print($"{dir}={signal.SignalTime:HH:mm:ss} - Señal {signal.EntryPrice} Entrada={signal.EntryPrice} - TP={signal.TP} - SL={signal.SL} - Resultado={res}");
                        if (logW != null)
                        {
                            DateTime closeTime = Time[0];
                            logW.WriteLine($"{closeTime:yyyy-MM-dd HH:mm:ss},{dir},{signal.EntryPrice:0.00},{signal.TP:0.00},{signal.SL:0.00},{signal.Score},{signal.SlopeVal:F3},{signal.VolRatioVal:F2},{signal.BodyRatioVal:F2},{signal.SpaceTicks:F0},{signal.MacdHist:F2},{signal.ExtDistTicks:F0},{res}");
                            logW.Flush();
                        }

                        signal = null;
                    }
                    else
                    {
                        return;
                    }
                }

                if (signal != null && !signal.InTrade && CurrentBar >= lastSignalBar + 1)
                {
                    signal.EntryPrice = Open[0];
                    if (signal.IsLong)
                    {
                        signal.TP = signal.EntryPrice + (TakeProfitTicks * TickSize);
                        signal.SL = signal.EntryPrice - (StopLossTicks * TickSize);
                    }
                    else
                    {
                        signal.TP = signal.EntryPrice - (TakeProfitTicks * TickSize);
                        signal.SL = signal.EntryPrice + (StopLossTicks * TickSize);
                    }
                    signal.InTrade = true;
                    return;
                }

                if (signal != null)
                    return;
            }

            if (CurrentBar <= lastSignalBar + CooldownBars)
            {
                Values[0][0] = 0;
                return;
            }

            bool longSetup = IsLongSetup();
            bool shortSetup = IsShortSetup();

            if (longSetup)
                RegisterSignal(true);
            else if (shortSetup)
                RegisterSignal(false);
            else
                Values[0][0] = 0;

            // Mostrar WR en el gráfico
            Draw.TextFixed(this, "WRPanel",
                $"Total: {totalTrades} | TP: {totalTP} | SL: {totalSL} | WR: {wrPercent:F1}%",
                WrPanelPosition,
                Brushes.White,
                new SimpleFont("Arial", WrFontSize),
                Brushes.Transparent,
                Brushes.Black,
                60);
        }

        private bool IsLongSetup()
        {
            bool c1 = Close[0] > ema14[0];
            bool c2 = Volume[0] > volSma[0] * VolumeThreshold;
            bool c3 = (ema14[0] - ema14[3]) / (3 * TickSize) > SlopeMin;
            bool c4 = Math.Abs(Close[0] - Open[0]) > (High[0] - Low[0]) * BodyContextRatio;
            int count = (c1 ? 1 : 0) + (c2 ? 1 : 0) + (c3 ? 1 : 0) + (c4 ? 1 : 0);
            return count >= 3 && Close[0] > Open[0];
        }

        private bool IsShortSetup()
        {
            bool c1 = Close[0] < ema14[0];
            bool c2 = Volume[0] > volSma[0] * VolumeThreshold;
            bool c3 = (ema14[0] - ema14[3]) / (3 * TickSize) < -SlopeMin;
            bool c4 = Math.Abs(Close[0] - Open[0]) > (High[0] - Low[0]) * BodyContextRatio;
            int count = (c1 ? 1 : 0) + (c2 ? 1 : 0) + (c3 ? 1 : 0) + (c4 ? 1 : 0);
            return count >= 3 && Close[0] < Open[0];
        }

        private void RegisterSignal(bool isLong)
        {
            double slope = Math.Abs(ema14[0] - ema14[3]) / (3 * TickSize);
            double volRatio = Volume[0] / volSma[0];
            double bodyRatio = (High[0] != Low[0]) ? Math.Abs(Close[0] - Open[0]) / (High[0] - Low[0]) : 0;

            double mid = sma20[0];
            double atr = atr14[0];
            double upperBand = mid + atr;
            double lowerBand = mid - atr;
            double upperExtreme = mid + 2 * atr;
            double lowerExtreme = mid - 2 * atr;
            double space = isLong ? upperBand - Close[0] : Close[0] - lowerBand;
            double macdHist = macd.Diff[0];
            bool f5 = CurrentBar > 0
                ? !(isLong && macd.Diff[0] < macd.Diff[1]) && !(!isLong && macd.Diff[0] > macd.Diff[1])
                : true;
            double extDist = isLong ? upperExtreme - Close[0] : Close[0] - lowerExtreme;

            bool f1 = slope > SlopeMin;
            bool f2 = Volume[0] > volSma[0] * VolumeThreshold;
            bool f3 = bodyRatio > BodyContextRatio;
            bool f4 = (space / TickSize) >= SignalPoints;
            bool f6 = (extDist / TickSize) > SignalPoints * 0.5;

            int score = (f1 ? 1 : 0) + (f2 ? 1 : 0) + (f3 ? 1 : 0) + (f4 ? 1 : 0) + (f5 ? 1 : 0) + (f6 ? 1 : 0);
            Brush col = isLong ? LongArrowColor : ShortArrowColor;

            double entry = Close[0];
            double tpCalc = isLong ? entry + (TakeProfitTicks * TickSize) : entry - (TakeProfitTicks * TickSize);
            double slCalc = isLong ? entry - (StopLossTicks * TickSize) : entry + (StopLossTicks * TickSize);

            if (isLong)
            {
                Draw.ArrowUp(this, "mdecLong_" + CurrentBar, true, 0, Low[0] - TickSize, col);
                Draw.VerticalLine(this, "mdecLineL_" + CurrentBar, 0, col);
            }
            else
            {
                Draw.ArrowDown(this, "mdecShort_" + CurrentBar, true, 0, High[0] + TickSize, col);
                Draw.VerticalLine(this, "mdecLineS_" + CurrentBar, 0, col);
            }

            Values[0][0] = score >= MinScoreToTrade ? 1 : 0;
            lastSignalBar = CurrentBar;

            double spaceTicks = space / TickSize;
            double extTicks = extDist / TickSize;
            string dir = isLong ? "LONG" : "SHORT";
            if (EnablePrints)
                Print($"{dir}={Time[0]:HH:mm:ss} Score={score} Slope={slope:F3} Vol={volRatio:F2} Body={bodyRatio:F2} Space={spaceTicks:F0} MACD={macdHist:F2} Ext={extTicks:F0} TP={tpCalc:0.00} SL={slCalc:0.00}");

            signal = new SignalData
            {
                SignalTime = Time[0],
                IsLong = isLong,
                InTrade = false,
                Score = score,
                SlopeVal = slope,
                VolRatioVal = volRatio,
                BodyRatioVal = bodyRatio,
                SpaceTicks = spaceTicks,
                MacdHist = macdHist,
                ExtDistTicks = extTicks
            };
        }

        private void UpdateStats<TKey>(System.Collections.Generic.Dictionary<TKey, TradeStats> dict, TKey key, bool isTP)
        {
            TradeStats stats;
            if (!dict.TryGetValue(key, out stats))
            {
                stats = new TradeStats();
                dict[key] = stats;
            }
            stats.Total++;
            if (isTP)
                stats.TP++;
        }

        private int ChooseBest(System.Collections.Generic.Dictionary<int, TradeStats> dict, int minTrades, int minVal, int maxVal, int current)
        {
            double bestPct = -1;
            int best = current;
            foreach (var kv in dict)
            {
                if (kv.Value.Total >= minTrades)
                {
                    double pct = (double)kv.Value.TP / kv.Value.Total * 100.0;
                    if (pct > bestPct)
                    {
                        bestPct = pct;
                        best = kv.Key;
                    }
                }
            }
            if (best < minVal) best = minVal;
            if (best > maxVal) best = maxVal;
            return best;
        }

        private double ChooseBest(System.Collections.Generic.Dictionary<double, TradeStats> dict, int minTrades, double minVal, double maxVal, double current)
        {
            double bestPct = -1;
            double best = current;
            foreach (var kv in dict)
            {
                if (kv.Value.Total >= minTrades)
                {
                    double pct = (double)kv.Value.TP / kv.Value.Total * 100.0;
                    if (pct > bestPct)
                    {
                        bestPct = pct;
                        best = kv.Key;
                    }
                }
            }
            if (best < minVal) best = minVal;
            if (best > maxVal) best = maxVal;
            return best;
        }

        private void ApplyAutoLearn()
        {
            try
            {
                string path = System.IO.Path.Combine(NinjaTrader.Core.Globals.UserDataDir, "MagnoDecisionScore_log.csv");
                if (!File.Exists(path))
                    return;
                var lines = File.ReadAllLines(path);
                if (lines.Length < 2)
                    return;

                DateTime startDate = DateTime.Today.AddDays(-AutoLearnDays);
                DateTime endDate = DateTime.Today;

                var tpDict = new System.Collections.Generic.Dictionary<int, TradeStats>();
                var slDict = new System.Collections.Generic.Dictionary<int, TradeStats>();
                var slopeDict = new System.Collections.Generic.Dictionary<double, TradeStats>();
                var volDict = new System.Collections.Generic.Dictionary<double, TradeStats>();

                int total = 0;
                int tpCount = 0;
                int slCount = 0;
                double sumTpTicks = 0;
                double sumSlTicks = 0;
                double sumSlopeWin = 0;
                double sumVolWin = 0;
                int winCount = 0;

                for (int i = 1; i < lines.Length; i++)
                {
                    var line = lines[i];
                    if (string.IsNullOrWhiteSpace(line))
                        continue;
                    var parts = line.Split(',');
                    if (parts.Length < 13)
                        continue;
                    DateTime time;
                    if (!DateTime.TryParse(parts[0], out time))
                        continue;
                    if (time.Date < startDate || time.Date >= endDate)
                        continue;
                    string result = parts[12].Trim();
                    bool isTP = string.Equals(result, "TP", StringComparison.OrdinalIgnoreCase);
                    bool isSL = string.Equals(result, "SL", StringComparison.OrdinalIgnoreCase);
                    if (!isTP && !isSL)
                        continue;

                    double entry, tpPrice, slPrice, slopeVal, volVal;
                    if (!double.TryParse(parts[2], NumberStyles.Any, CultureInfo.InvariantCulture, out entry) ||
                        !double.TryParse(parts[3], NumberStyles.Any, CultureInfo.InvariantCulture, out tpPrice) ||
                        !double.TryParse(parts[4], NumberStyles.Any, CultureInfo.InvariantCulture, out slPrice) ||
                        !double.TryParse(parts[6], NumberStyles.Any, CultureInfo.InvariantCulture, out slopeVal) ||
                        !double.TryParse(parts[7], NumberStyles.Any, CultureInfo.InvariantCulture, out volVal))
                        continue;

                    int tpTicks = (int)Math.Round(Math.Abs(tpPrice - entry) / TickSize);
                    int slTicks = (int)Math.Round(Math.Abs(entry - slPrice) / TickSize);

                    total++;
                    sumTpTicks += tpTicks;
                    sumSlTicks += slTicks;
                    if (isTP)
                    {
                        tpCount++;
                        winCount++;
                        sumSlopeWin += slopeVal;
                        sumVolWin += volVal;
                    }
                    else if (isSL)
                    {
                        slCount++;
                    }

                    UpdateStats(tpDict, tpTicks, isTP);
                    UpdateStats(slDict, slTicks, isTP);
                    UpdateStats(slopeDict, slopeVal, isTP);
                    UpdateStats(volDict, volVal, isTP);
                }

                if (total < MinTradesForAutoLearn)
                {
                    Print($"AutoLearn: datos insuficientes ({total} < {MinTradesForAutoLearn})");
                    return;
                }

                double wr = total > 0 ? (double)tpCount / total * 100.0 : 0.0;
                double slRate = total > 0 ? (double)slCount / total * 100.0 : 0.0;
                double avgTpPts = total > 0 ? (sumTpTicks / total) * TickSize : 0.0;
                double avgSlPts = total > 0 ? (sumSlTicks / total) * TickSize : 0.0;
                double avgSlopeWin = winCount > 0 ? sumSlopeWin / winCount : 0.0;
                double avgVolWin = winCount > 0 ? sumVolWin / winCount : 0.0;

                int bestTP = ChooseBest(tpDict, 10, 10, 50, TakeProfitTicks);
                int bestSL = ChooseBest(slDict, 10, 5, 50, StopLossTicks);
                double bestSlope = ChooseBest(slopeDict, 10, 0.02, 0.10, SlopeMin);
                double bestVol = ChooseBest(volDict, 10, 1.0, 3.0, VolumeThreshold);

                int newTP = LimitChange(TakeProfitTicks, bestTP, 10, 50);
                int newSL = LimitChange(StopLossTicks, bestSL, 5, 50);
                double newSlope = LimitChange(SlopeMin, bestSlope, 0.02, 0.10);
                double newVol = LimitChange(VolumeThreshold, bestVol, 1.0, 3.0);

                Print($"AutoLearn Report (últimos {AutoLearnDays} días):");
                Print($"Total trades analizados: {total}");
                Print($"WR general: {wr:F1}%");
                Print($"SL hit rate: {slRate:F1}%");
                Print($"TP promedio: {avgTpPts:F2} pts");
                Print($"SL promedio: {avgSlPts:F2} pts");
                Print($"Slope promedio ganadores: {avgSlopeWin:F3}");
                Print($"Volumen promedio ganadores: {avgVolWin:F2}");
                Print($"Nuevo TPTicks: {newTP}");
                Print($"Nuevo SLTicks: {newSL}");
                Print($"Nuevo SlopeMin: {newSlope:F3}");
                Print($"Nuevo VolumeThreshold: {newVol:F2}");

                if (AutoLearnMode == AutoLearnModes.Active)
                {
                    TakeProfitTicks = newTP;
                    if (wr >= 50.0)
                    {
                        StopLossTicks = newSL;
                        SlopeMin = newSlope;
                        VolumeThreshold = newVol;
                    }

                    Print($"AutoLearn aplicado: TP={TakeProfitTicks} SL={StopLossTicks} SlopeMin={SlopeMin} VolumeThreshold={VolumeThreshold}");
                    if (logW != null)
                    {
                        logW.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss},SETTINGS_CHANGE,,{TakeProfitTicks},{StopLossTicks},0,{SlopeMin:F3},{VolumeThreshold:F2},0,0,0,0,SETTINGS_CHANGE");
                        logW.Flush();
                    }
                }
                else if (AutoLearnMode == AutoLearnModes.Passive)
                {
                    Print("AutoLearn en modo Passive: ajustes sugeridos no aplicados.");
                }
            }
            catch (Exception ex)
            {
                Print($"AutoLearn error: {ex.Message}");
            }
        }

        private int LimitChange(int current, int proposed, int minVal, int maxVal)
        {
            int delta = proposed - current;
            int maxDelta = (int)Math.Round(current * 0.2);
            if (delta > maxDelta) delta = maxDelta;
            if (delta < -maxDelta) delta = -maxDelta;
            int result = current + delta;
            if (result < minVal) result = minVal;
            if (result > maxVal) result = maxVal;
            return result;
        }

        private double LimitChange(double current, double proposed, double minVal, double maxVal)
        {
            double delta = proposed - current;
            double maxDelta = current * 0.2;
            if (delta > maxDelta) delta = maxDelta;
            if (delta < -maxDelta) delta = -maxDelta;
            double result = current + delta;
            if (result < minVal) result = minVal;
            if (result > maxVal) result = maxVal;
            return result;
        }
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MagnoDecisionScore_v1[] cacheMagnoDecisionScore_v1;
		public MagnoDecisionScore_v1 MagnoDecisionScore_v1(int cooldownBars, int signalPoints, int takeProfitTicks, int stopLossTicks, double volumeThreshold, double slopeMin, double bodyContextRatio, int minScoreToTrade, bool enablePrints, bool enableCsvLog, AutoLearnModes autoLearnMode, int autoLearnDays, int minTradesForAutoLearn, int wrFontSize, TextPosition wrPanelPosition, Brush longArrowColor, Brush shortArrowColor)
		{
			return MagnoDecisionScore_v1(Input, cooldownBars, signalPoints, takeProfitTicks, stopLossTicks, volumeThreshold, slopeMin, bodyContextRatio, minScoreToTrade, enablePrints, enableCsvLog, autoLearnMode, autoLearnDays, minTradesForAutoLearn, wrFontSize, wrPanelPosition, longArrowColor, shortArrowColor);
		}

		public MagnoDecisionScore_v1 MagnoDecisionScore_v1(ISeries<double> input, int cooldownBars, int signalPoints, int takeProfitTicks, int stopLossTicks, double volumeThreshold, double slopeMin, double bodyContextRatio, int minScoreToTrade, bool enablePrints, bool enableCsvLog, AutoLearnModes autoLearnMode, int autoLearnDays, int minTradesForAutoLearn, int wrFontSize, TextPosition wrPanelPosition, Brush longArrowColor, Brush shortArrowColor)
		{
			if (cacheMagnoDecisionScore_v1 != null)
				for (int idx = 0; idx < cacheMagnoDecisionScore_v1.Length; idx++)
					if (cacheMagnoDecisionScore_v1[idx] != null && cacheMagnoDecisionScore_v1[idx].CooldownBars == cooldownBars && cacheMagnoDecisionScore_v1[idx].SignalPoints == signalPoints && cacheMagnoDecisionScore_v1[idx].TakeProfitTicks == takeProfitTicks && cacheMagnoDecisionScore_v1[idx].StopLossTicks == stopLossTicks && cacheMagnoDecisionScore_v1[idx].VolumeThreshold == volumeThreshold && cacheMagnoDecisionScore_v1[idx].SlopeMin == slopeMin && cacheMagnoDecisionScore_v1[idx].BodyContextRatio == bodyContextRatio && cacheMagnoDecisionScore_v1[idx].MinScoreToTrade == minScoreToTrade && cacheMagnoDecisionScore_v1[idx].EnablePrints == enablePrints && cacheMagnoDecisionScore_v1[idx].EnableCsvLog == enableCsvLog && cacheMagnoDecisionScore_v1[idx].AutoLearnMode == autoLearnMode && cacheMagnoDecisionScore_v1[idx].AutoLearnDays == autoLearnDays && cacheMagnoDecisionScore_v1[idx].MinTradesForAutoLearn == minTradesForAutoLearn && cacheMagnoDecisionScore_v1[idx].WrFontSize == wrFontSize && cacheMagnoDecisionScore_v1[idx].WrPanelPosition == wrPanelPosition && cacheMagnoDecisionScore_v1[idx].LongArrowColor == longArrowColor && cacheMagnoDecisionScore_v1[idx].ShortArrowColor == shortArrowColor && cacheMagnoDecisionScore_v1[idx].EqualsInput(input))
						return cacheMagnoDecisionScore_v1[idx];
			return CacheIndicator<MagnoDecisionScore_v1>(new MagnoDecisionScore_v1(){ CooldownBars = cooldownBars, SignalPoints = signalPoints, TakeProfitTicks = takeProfitTicks, StopLossTicks = stopLossTicks, VolumeThreshold = volumeThreshold, SlopeMin = slopeMin, BodyContextRatio = bodyContextRatio, MinScoreToTrade = minScoreToTrade, EnablePrints = enablePrints, EnableCsvLog = enableCsvLog, AutoLearnMode = autoLearnMode, AutoLearnDays = autoLearnDays, MinTradesForAutoLearn = minTradesForAutoLearn, WrFontSize = wrFontSize, WrPanelPosition = wrPanelPosition, LongArrowColor = longArrowColor, ShortArrowColor = shortArrowColor }, input, ref cacheMagnoDecisionScore_v1);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MagnoDecisionScore_v1 MagnoDecisionScore_v1(int cooldownBars, int signalPoints, int takeProfitTicks, int stopLossTicks, double volumeThreshold, double slopeMin, double bodyContextRatio, int minScoreToTrade, bool enablePrints, bool enableCsvLog, AutoLearnModes autoLearnMode, int autoLearnDays, int minTradesForAutoLearn, int wrFontSize, TextPosition wrPanelPosition, Brush longArrowColor, Brush shortArrowColor)
		{
			return indicator.MagnoDecisionScore_v1(Input, cooldownBars, signalPoints, takeProfitTicks, stopLossTicks, volumeThreshold, slopeMin, bodyContextRatio, minScoreToTrade, enablePrints, enableCsvLog, autoLearnMode, autoLearnDays, minTradesForAutoLearn, wrFontSize, wrPanelPosition, longArrowColor, shortArrowColor);
		}

		public Indicators.MagnoDecisionScore_v1 MagnoDecisionScore_v1(ISeries<double> input , int cooldownBars, int signalPoints, int takeProfitTicks, int stopLossTicks, double volumeThreshold, double slopeMin, double bodyContextRatio, int minScoreToTrade, bool enablePrints, bool enableCsvLog, AutoLearnModes autoLearnMode, int autoLearnDays, int minTradesForAutoLearn, int wrFontSize, TextPosition wrPanelPosition, Brush longArrowColor, Brush shortArrowColor)
		{
			return indicator.MagnoDecisionScore_v1(input, cooldownBars, signalPoints, takeProfitTicks, stopLossTicks, volumeThreshold, slopeMin, bodyContextRatio, minScoreToTrade, enablePrints, enableCsvLog, autoLearnMode, autoLearnDays, minTradesForAutoLearn, wrFontSize, wrPanelPosition, longArrowColor, shortArrowColor);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MagnoDecisionScore_v1 MagnoDecisionScore_v1(int cooldownBars, int signalPoints, int takeProfitTicks, int stopLossTicks, double volumeThreshold, double slopeMin, double bodyContextRatio, int minScoreToTrade, bool enablePrints, bool enableCsvLog, AutoLearnModes autoLearnMode, int autoLearnDays, int minTradesForAutoLearn, int wrFontSize, TextPosition wrPanelPosition, Brush longArrowColor, Brush shortArrowColor)
		{
			return indicator.MagnoDecisionScore_v1(Input, cooldownBars, signalPoints, takeProfitTicks, stopLossTicks, volumeThreshold, slopeMin, bodyContextRatio, minScoreToTrade, enablePrints, enableCsvLog, autoLearnMode, autoLearnDays, minTradesForAutoLearn, wrFontSize, wrPanelPosition, longArrowColor, shortArrowColor);
		}

		public Indicators.MagnoDecisionScore_v1 MagnoDecisionScore_v1(ISeries<double> input , int cooldownBars, int signalPoints, int takeProfitTicks, int stopLossTicks, double volumeThreshold, double slopeMin, double bodyContextRatio, int minScoreToTrade, bool enablePrints, bool enableCsvLog, AutoLearnModes autoLearnMode, int autoLearnDays, int minTradesForAutoLearn, int wrFontSize, TextPosition wrPanelPosition, Brush longArrowColor, Brush shortArrowColor)
		{
			return indicator.MagnoDecisionScore_v1(input, cooldownBars, signalPoints, takeProfitTicks, stopLossTicks, volumeThreshold, slopeMin, bodyContextRatio, minScoreToTrade, enablePrints, enableCsvLog, autoLearnMode, autoLearnDays, minTradesForAutoLearn, wrFontSize, wrPanelPosition, longArrowColor, shortArrowColor);
		}
	}
}

#endregion
