NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•"UI" instances representing its default properties on various user interfaces
•The "configured" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select "Indicator"
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses "Apply" or "OK"
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of "Available" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of "Available" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the "Properties" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd "configured" instance you are concerned with developing, but you should also be aware of the "UI" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or "Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
Determines how often OnBarUpdate() is called for each bar. OnBarClose means once at the close of the bar. OnEachTick means on every single tick. OnPriceChange means once for each price change. If there were two ticks in a row with the same price, the second tick would not trigger OnBarUpdate(). This can improve performance if calculations are only needed when new values are possible.
 
 
 
Property Value
An enum value determining the how frequently OnBarUpdate() will be called.  Default value is set to Calculate.OnBarClose
 
 
 
Syntax
Calculate.OnBarClose
Calculate.OnEachTick
Calculate.OnPriceChange
 
 
 
Examples
Definition
Represents the current progression of the object as it advances from setup, processing data, to termination.  These states can be used for setting up or declaring various resources and properties.
 
 
 
Property Value
An enum value representing the current state of the object.  Possible values are:
 
Syntax
State
 
 
 
Examples
 
 
 
¿Qué es la repetición de tick?
La repetición de marca es una propiedad que se puede habilitar opcionalmente en los indicadores y estrategias de NinjaScript que asegurarán que los datos del mercado (oferta / demanda / última) que se introdujeron en la construcción de una barra se carguen en la secuencia exacta de eventos de datos del mercado.  Esto garantiza que sus indicadores y estrategias se calculen históricamente tic por tic exactamente como lo hubieran sido si el indicador / estrategia se ejecutara en vivo durante un período. La repetición de marca puede habilitarse para los indicadores utilizados en Gráficos , Analizadores de mercado y Estrategias .
 
 
 
 
 
Los indicadores y las estrategias solo podrán aprovechar la repetición de ticks si se han programado explícitamente para calcular estos eventos de datos de mercado.  Si usted es un programador y le gustaría aprender cómo utilizar Tick Replay con las secuencias de comandos personalizados, consulte la repetición de garrapatas utilizando la sección de nuestra guía de ayuda NinjaScript.
 
Configuración de repetición de marca
Por defecto, la repetición de marca no estará habilitada.  Para exponer esta propiedad para sus indicadores y estrategias, primero deberá activar la opción de repetición de marca global:
 
•Vaya al menú Centro de control > Herramientas > Opciones y, en la categoría Datos de mercado , marque " Mostrar reproducción de marca"
 

 
Una vez que se haya habilitado la opción " Mostrar reproducción de tick " en la categoría Datos de mercado del menú Opciones, encontrará una opción de " Reproducción de tick " que puede seleccionar al configurar sus indicadores o estrategias, o al ejecutar una estrategia en la Estrategia analizador .
 
 
 

Multi-Series Scripting Overview
NinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.
 
 
It is also important that you understand the following method and properties:
 
•AddDataSeries()
•BarsArray
•BarsInProgress
•CurrentBars
 
        Working With Multi-Time Frame Objects
        Adding Additional Bars Objects to NinjaScript
        Creating Series<T> Objects
        How Bars Data is Referenced
        Using Bars Objects as Input to Indicator Methods
        True Event Driven OnBarUpdate() Method
        Accessing the Price Data in a Multi-Bars NinjaScript
        Entering, Exiting and Retrieving Position Information
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Renko Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType)
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName)
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName, bool?isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Order Flow Volumetric Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, string tradingHoursName, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, int sizeFilter, string tradingHoursName, bool? isResetOnNewTradingDay) (R17 and higher only)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Line Break Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
Examples
Historical Bid/Ask Series Overview
NinjaTrader has the ability to use historical bid and ask price series in your NinjaScript instead of only being able to use a last price series. The following outlines the intricacies of this capability:
 
 
 
Accessing Bid/Ask Series
When calling AddDataSeries() to add an additional Bars object to your script, a constructor overload will be available which takes a MarketDataType enumeration as an argument. This will allow you to specify the price series which will be used in that particular object. If you were to pass in MarketDataType.Ask or MarketDataType.Bid, as in the example below, that particular data series will use that price type for all of its PriceSeries collections, such as Close, Open, High, and Low.
 
 
Example
Definition
Holds an array of int values representing the number of the current bar in a Bars object. An int value is added to this array when calling the AddDataSeries() method. Its purpose is to provide access to the CurrentBar of all Bars objects in a multi-instrument or multi-time frame script.
 
 
 
Property Value
An array of int values.
 
 
 
Syntax
CurrentBars[int barSeriesIndex]
 
Examples
 
 
Definition
The number of bars on a chart required before the script plots.
 
 
 
Property Value
An int value that represents the minimum number of bars required.
 
Syntax
BarsRequiredToPlot
 
Examples
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
The primary Bars object time frame (period type and interval).
 
 
 
Property Value
A Bars series object representing the time frame of the Bars.
 
Syntax
 
 
Examples
 
 
Definition
Determines how often OnBarUpdate() is called for each bar. OnBarClose means once at the close of the bar. OnEachTick means on every single tick. OnPriceChange means once for each price change. If there were two ticks in a row with the same price, the second tick would not trigger OnBarUpdate(). This can improve performance if calculations are only needed when new values are possible.
 
 
 
Property Value
An enum value determining the how frequently OnBarUpdate() will be called.  Default value is set to Calculate.OnBarClose
 
 
 
Syntax
Calculate.OnBarClose
Calculate.OnEachTick
Calculate.OnPriceChange
 
 
 
Examples
Definition
The total number of bars or data points.
 
Property Value
An int value representing the the total number of bars.
 
Syntax
Count
 
 
Examples
 
 
Definition
A number representing the current bar in a Bars object that the OnBarUpdate() method in an indicator or strategy is currently processing. For example, if a chart has 100 bars of data, the very first bar of the chart (left most bar) will be number 0 (zero) and each subsequent bar from left to right is incremented by 1.
 
 
 
Property Value
An int value that represents the current bar.
 
Syntax
CurrentBar
 
 
Examples
Definition
Indicates if the incoming tick is the first tick of a new bar. This property is only of value in scripts that run tick by tick which is when the Calculate property is set to Calculate.OnEachTick or Calculate.OnPriceChange.
 
 
 
 
 
Property Value
This property returns true if the incoming tick is the first tick of a new bar; otherwise, false.
 
Syntax
IsFirstTickOfBar
 
 
Examples
Definition
Determines if the specified bar series is using Break at EOD
 
 
Property Value
A bool[] when true, indicates the specified BarsArray is setup to run Break at EOD; otherwise false.  Default value is false
 
Syntax
IsResetOnNewTradingDays[int idx]
 
 
 
Examples
Definition
Indicates the specified bar series is using Tick Replay.   Please see the help guide topic on using Tick Replay for general information on this mode.
 
 
 
 
 
Property Value
A bool[] when true, indicates the specified BarsArray is setup to run Tick Replay; otherwise false.  Default value is false
 
Syntax
IsTickReplays[int idx]
 
 
Examples
Definition
Forces the OnBarUpdate() method to be called so that indicator values are updated to the current bar.  If the values are already up to date, the Update() method will not be run.
 
 
When indicators are embedded (called) within a NinjaScript strategy, they are optimized to calculate only when they are called upon in a historical backtest. Since the NinjaTrader indicator model is very flexible, it is possible to create public properties on a custom indicator that return values of internal user defined variables. If these properties require that the OnBarUpdate() method is called before returning a value, include a call to this Update() method in the property getter.
 
Syntax
Update()
 
Parameters
 
 
Examples
Definition
An index value of the current Bars object that has called the OnBarUpdate() method. In a multi-bars script, the OnBarUpdate() method is called for each Bars object of a script. This flexibility allows you to separate trading logic from different bar events.
 
 
 
Property Value
An int value represents the Bars object that is calling the OnBarUpdate() method.
 
Syntax
BarsInProgress
 
 
Examples
AddOn Development Basics
The NinjaScript AddOn framework provides functionality reaching across the NinjaTrader platform while granting access to certain core methods and properties not contained within the NinjaScript namespace. In addition to creating your own independent window or modifying the user interface and functionality of existing NinjaTrader windows (charts, etc.), AddOns can also subscribe to live market data, access account information, and more.
 
 
NinjaScript Editor Development Environment (NinjaScript Basic)
The NinjaScript Editor can be used to create and write custom AddOns in C#
 
Pros
•Use the familiar NinjaScript editor (if you are uncomfortable with Visual Studio)
•Changes to the AddOn are reflected immediately upon NS Editor Compile and does not require restart
 
Cons
•If you wish to design a custom NTWindow, XAML files cannot be edited in the NinjaScript editor.
•NinjaScript editor lacks support of common development and debugging tools available in an IDE's like Visual Studio
 
Below is a NinjaScript Editor compatible zip file (which also contains a XAML file)
•Download AddOn Framework NinjaScript Basic file to your desktop
•From the Control Center window select the menu Tools > Import > NinjaScript
•Select the downloaded file
 
Once imported, the AddOn can be launched via the New menu in the Control Center
 
AddOn Development Environment (Visual Studio Advanced)
Since AddOns can include multiple classes, unique user interfaces, and various file types (XAML, sounds, etc.), the recommended development environment for AddOns differs from other NinjaScript Types. Following the guidelines below to set up an AddOn development environment can help to streamline the process.
 
Pros
•Use Visual Studio or a comparable IDE to create a solution linking all project files together
•Use your IDE to build a DLL, rather than exporting through NinjaTrader
•This will allow you to bundle XAML and other files into the DLL
•Set a post-build event to place the DLL into the appropriate folder (NinjaTrader 8/bin/Custom)
•Set a Debug Start Action to launch NinjaTrader
 
Cons
•NinjaTrader needs to be restarted in order to re-load the compiled DLL after changes
 
If you use this setup and build a DLL with your IDE, the IDE will automatically place it where it needs to be and immediately launch the platform for testing any changes.
 
Below is a complete Visual Studio project with this setup in place. Simply unzip the contents of this archive to your desired location, then open the "NinjaTraderAddOnProject.sln" solution in Visual Studio.
 
Download Visual Studio Solution for AddOn Development
 
 
Creating Your Own AddOn Window
NinjaScript developers can utilize the AddOn framework to create free-standing, independent windows to provide custom functionality. Helper classes are available in the framework to instantiate windows styled the same as pre-built NinjaTrader windows, including familiar functionality such as window linking, the tabbed interface, and the ability to save the window and its state in workspaces. In addition, general WPF user interface elements and XAML can be used to style and modify windows using the .NET framework.
 
For a detailed walkthrough of creating your own window using NinjaScript helper classes, see the Creating Your Own AddOn Window page.
 

 
The image above shows a completely new window created by a custom AddOn.
 
Other Uses for an AddOn
An AddOn does not require its own window to function. It can instead be used to accomplish non-UI-driven functionality across the platform, such as monitoring market data or accessing account, position, and order information. AddOns can also be used to add functionality or interface elements to other NinjaTrader windows, such as charts.
 
For detailed information on other common uses of an AddOn, see the Other Uses for an AddOn page.
 

 
In the image above, the custom "Sample button" button has been drawn on a chart window using an AddOn.
Overview
The NinjaScript Editor is a powerful scripting editor that allows you to create custom indicators, strategies, and any other custom NinjaScript types used to enhance the NinjaTrader platform.  The NinjaScript Editor can be opened by selecting the New menu from the NinjaTrader Control Center. Then left mouse click on the menu item NinjaScript Editor
 
1. NinjaScript Explorer - Displays files, folders, and allows for additional file management
2. Tool bar - Moving your mouse over each icon will display the function of the icon button
3. Line numbers
4. Line modification marking - Yellow flags indicate unsaved line modifications where green flags indicate saved modifications
5. Tabs for creating new scripts via the NinjaScript wizard and working on multiple scripts.
 
    
 
Properties and Definitions
 

 
 
The NinjaScript Explorer provides a Folder view of all the supported NinjaScript categories that can be developed in NinjaTrader.  
        Understanding the NinjaScript Explorer display
permalink
        Managing scripts and folders
        Excluding a script from compilation
When compiling a custom indicator or strategy it is possible and likely that you will generate compile errors.
•NinjaTrader will compile ALL NinjaScript files NOT only the file you are working on
•A list of compile errors for all files will be displayed in the lower portion of the NinjaScript Editor
•Double click on an error to load the problem file and highlight the problem area
•Click on the error code to bring up Help Documentation on a specific error
•Right click on the error to exclude the problem file from compilation (see the section on Excluding a script from compilation for more information)
 
The image below illustrates a compile error
1. Section where compile errors are displayed. Errors in the current loaded file are color coded a light color while errors in other files have a darker color code.
2. The file that contains the error
3. A description of the error
4. A error code link that will open the Help Guide with any relevant error code information
5. Line number and column number of the error
6. Error is underlined with a red wavy line
 
The error highlighted by icon (6) below shows that the expression is not closed with a semicolon. The expression should be:
 
double myValue = SMA(20)[0];
 

You can debug your NinjaScript objects using Microsoft Visual Studio. NinjaScript objects are compiled into a single DLL, named "NinjaTrader.Custom.dll." When debugging, a special debug DLL is created for temporary use, with the same name as the release version.
 
 
Using Visual Studio Debugging
1. In the NinjaScript Editor, enable "Debug Mode" via the right-click menu, as seen in the image below. After this, compile your scripts to create the debug DLL.
 

 
2. From the NinjaScript Editor, click on the Visual Studio icon  from the tool bar, which will automatically load the NinjaTrader.Custom project with your installed version of Visual Studio.
 
3. In Visual Studio, select Debug, then select Attach to Process
 

 
4. Select NinjaTrader from the list of processes, then select Attach. Be sure the "Attach to" field is set to "Automatic: Managed code" or "Managed code".
 

 
4. Open the NinjaScript source file within Microsoft Visual Studio and set your break point(s)
 

 
5. Run your NinjaScript object in NinjaTrader and it should stop at your break points and all the debugging tools and information should be available to inspect the current state of the code.
 
The following CS0234 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when an imported DLL (could be a 3rd party indicator) you are referencing no longer exists / has been removed.
 
To resolve this the DLL must be re-imported.
 
To re-import a 3rd party dll:
1.Open the NinjaScript Editor via New > NinjaScript editor.
2.Right mouse click in the NinjaScript Editor main window and select the menu name "References"
3.In the "References" dialog window press the button "Add"
4.Select the 3rd party DLL
 
 
Error Descriptions
The type or namespace name '<name>' could not be found (are you missing a using directive or an assembly reference?)
The type or namespace name '<name>' does not exist in the namespace 'NinjaTrader.Indicator' (are you missing an assembly reference?)
The following CS0019 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
Strings cannot be compared with relational operators (<, >, <=, >=, ==, !=) to other object types. Strings can only be compared to other strings and only through the use of equality operators (==, !=).
 
Error Description #1
Operator '==' cannot be applied to operands of type 'string' and 'int'
 
// Erroneous Sample Code – Cannot compare a string to an integer
if ("string" == 5)
 
// Resolution Sample Code – Compare a string with another string
if ("string" == intValue.ToString());
 
Error Description #2
Operator ‘<’ cannot be applied to operands of type ‘string’ and ‘double’
 
// Erroneous Sample Code - Cannot compare a string to a double
if ("string" >= 1.2)
 
// Resolution Sample Code - Testing to see if the strings are not the same
if ("string" != "string2")
 
Error Description #3
Operator ‘>’ cannot be applied to operands of type ‘string’ and ‘string’
 
// Erroneous Sample Code - Cannot quantitatively compare a string to another string
if ("string" > "string2")
 
// Resolution Sample Code - Testing to see if both strings are the same
if ("string" == "string2")
 
Additional Error Descriptions
Operator ‘<’ cannot be applied to operands of type ‘string’ and ‘string’
Operator ‘<=’ cannot be applied to operands of type ‘string’ and ‘string’
Operator ‘>=’ cannot be applied to operands of type ‘string’ and ‘string’
The following CS0021 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect.  In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This is a common error when calling indicators methods. It occurs when an indicator is called without its required parameter arguments before accessing an indexed value.
 
To fix this error you will need to first pass to the indicator method all the necessary parameter arguments. You can do this with '()' after the indicator name. Please note that you will still need to pass an empty parameter argument list even if your indicator requires no arguments.
 
Error Description #1
Cannot apply indexing with [] to an expression of type 'method group'
 
Example #1
// Erroneous Sample Code - SMA is an indicator and requires parameter arguments
double value = SMA[0];
 
// Resolution Sample Code - SMA() properly called
double value = SMA(14)[0];
 
Example #2
// Erroneous Sample Code - EMA is an indicator and requires parameter arguments
double maDelta = EMA[0] - EMA[1];
 
// Resolution Sample Code - SMA() properly called with an overload method (one of several variations)
double maDelta = EMA(High, 14)[0] - EMA(High, 14)[1];
The following CS0103 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
When a variable is used before declaration, the compiler will not know what it is. This error is also commonly invoked by typos.
 
Please ensure that you have declared your variables prior to using them. If variables are declared or properties already exist, please check for typos.
 
Error Description #1
The name 'identifier' does not exist in the current context
 
Example #1
// Erroneous Sample Code - 'CurentBar' does not exist since it has been spelled incorrectly (missing an 'r')
if (CurentBar < 10)
 
// Resolution Sample Code - 'CurrentBar' exists since it is spelled correctly
if (CurrentBar < 10)
 
Example #2
// Erroneous Sample Code - 'newVariable' is not declared
newVariable = 10;
 
// Resolution Sample Code - 'newVariable' is now declared as an integer
int newVariable = 10;
The following CS0200 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error is most common when you try to assign values to a particular Series<T> index that is read-only. Instead try making your own Series<T> and assign the value there.
 
Error Description
Property or indexer 'NinjaTrader.NinjaScript.ISeries<double>.this[int]' cannot be assigned to -- it is read only
 
Example #1
// Erroneous Sample Code - Cannot assign values to something that is read-only
Close[0] = 25;
 
// Resolution Sample Code - Assigns value to a custom Series<double>
myCustomClose[0] = 25;
 
Example #2
// Erroneous Sample Code - Cannot reassign values to Series<double> indexed value and cannot have an if statement based // on an assignment operator
if (Close[0] = Open[0])
 
// Resolution Sample Code - Properly compares two Series<double> values
if (Close[0] == Open[0])
The following CS0234 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when an imported DLL (could be a 3rd party indicator) you are referencing no longer exists / has been removed.
 
To resolve this the DLL must be re-imported.
 
To re-import a 3rd party dll:
1.Open the NinjaScript Editor via New > NinjaScript editor.
2.Right mouse click in the NinjaScript Editor main window and select the menu name "References"
3.In the "References" dialog window press the button "Add"
4.Select the 3rd party DLL
 
 
Error Descriptions
The type or namespace name '<name>' could not be found (are you missing a using directive or an assembly reference?)
The type or namespace name '<name>' does not exist in the namespace 'NinjaTrader.Indicator' (are you missing an assembly reference?)
The following CS0234 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when an imported DLL (could be a 3rd party indicator) you are referencing no longer exists / has been removed.
 
To resolve this the DLL must be re-imported.
 
To re-import a 3rd party dll:
1.Open the NinjaScript Editor via New > NinjaScript editor.
2.Right mouse click in the NinjaScript Editor main window and select the menu name "References"
3.In the "References" dialog window press the button "Add"
4.Select the 3rd party DLL
 
 
Error Descriptions
The type or namespace name '<name>' could not be found (are you missing a using directive or an assembly reference?)
The type or namespace name '<name>' does not exist in the namespace 'NinjaTrader.Indicator' (are you missing an assembly reference?)
The following CS0428 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you miscall a method such as indicator methods.
 
If you are calling an indicator please ensure that you have both the parameters '()' and the indexing value '[]' set. For other methods please ensure you pass all required parameters through the parameters set '()'.
 
Error Description #1
Cannot convert method group 'SMA' to non-delegate type 'double'. Did you intend to invoke the method?
 
Example #1
// Erroneous Sample Code - SMA() indicator method is improperly called
double myValue = SMA;
 
// Resolution Sample Code - SMA() indicator method is properly called
double myValue = SMA(5)[0];
 
Example #2
// Erroneous Sample Code - ToString is a method and requires round brackets () to be properly called
string str = Close[5].ToString;
 
// Resolution Sample Code - ToString() is properly called
string str = Close[5].ToString();
The following CS0443 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error is most commonly invoked when no index value is used inside the indexing brackets.
 
Please ensure you place a value inside the '[]'.
 
Error Description #1
Syntax error, value expected
 
// Erroneous Sample Code - Missing index value
double myValue = SMA(20)[];
 
// Resolution Sample Code - 'myValue' takes on the current bar's SMA(20) value
double myValue = SMA(20)[0];
The following CS1002 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can be invoked when statements are not ended properly.
 
All statement lines must be closed with a semicolon.
 
Error Description #1
; expected
 
// Erroneous Sample Code - Statement is not closed
double myValue = SMA(20)[0]
 
// Resolution Sample Code - Statement is closed
double myValue = SMA(20)[0];
The following CS1061 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error's code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you try to use a method or access an exposed property that does not exist for your particular object.
 
Please check the methods and exposed property available for your particular object.
 
Error Description #1
'NinjaTrader.Indicator.CurrentDayOHL' does not contain a definition for 'CurentOpen'
// Erroneous Sample Code - CurrentDayOHL()’s property is 'CurrentOpen' not 'CurentOpen' (typo)
double value = CurrentDayOHL().CurentOpen[0];
 
// Resolution Sample Code - 'CurrentOpen' property available
double value = CurrentDayOHL().CurrentOpen[0];
 
The following CS1501 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you use use an overload (method parameter signature) that does not exist. This could be because you are passing in 3 arguments when the method only requires 2.
 
You can cycle through the available overloads with the use of the up and down arrows on the Intelliprompt when you call an indicator method or any other method.
 
Error Description #1
No overload for method 'SMA' takes '0' arguments
 
Example #1
// Erroneous Sample Code - SMA() does not contain an overload that has 3 arguments
double myValue = SMA(Close, 5, 2)[0];
 
// Resolution Sample Code - SMA() has an overload consisting of 2 arguments
double myValue = SMA(Close, 5)[0];
 
Example #2
// Erroneous Sample Code - EMA() does not contain an overload that has 0 arguments
double myValue = EMA()[0];
 
// Resolution Sample Code - EMA() has an overload consisting of 1 argument
double myValue = EMA(5)[0];
 
The following CS1502 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you pass in incorrect parameter object types into a method such as an indicator.
 
Please check the overload methods for the proper parameter object types and pass in the proper object. You can check the overload methods with NinjaScript editor’s Intelliprompt when you call a method.
 
Error Description #1
The best overloaded method match for 'NinjaTrader.NinjaScript.StrategyBase.SetStopLoss(CalculationMode, double)' has some invalid arguments
 
// Erroneous Sample Code - Close is a Series<double> object type and is not a valid value to the SetStopLoss() method
SetStopLoss(CalculationMode.Price, Close);
 
// Resolution Sample Code - The SetStopLoss() method takes a double value so pass in Close[0]
SetStopLoss(CalculationMode.Price, Close[0]);
 
Error Description #2
The best overloaded method match for 'NinjaTrader.Indicator.Indicator.SMA(NinjaTrader.NinjaScript.ISeries<double>, int)' has some invalid arguments
 
// Erroneous Sample Code - Using an integer when the first parameter should be a Series<double>
double myValue = SMA(5, 5);
 
// Resolution Sample Code - 'myValue' will take the value of the current bar's SMA
double myValue = SMA(Close, 5)[0];
The following CS1503 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you try to assign a value to a Series<T> that is not of the correct value type.
 
Series<double> objects can only contain double values. Series<bool> objects can only contain bool values. Etc.
 
Error Description #1
Cannot implicity convert type from 'string' to 'double'
 
// Erroneous Sample Code - Cannot pass in a string to a Series<double>
Value[0] = "Close[0]";
 
// Resolution Sample Code - Sets Series<double> to the current bar's Close value
Value[0] = Close[0];
 
Error Description #2
Cannot implicitly convert type 'NinjaTrader.NinjaScript.Indicators.SMA' to 'double'
 
// Erroneous Sample Code - Cannot pass in a Series<double> object to a Series<double> Set() method
Values[0] = SMA(20);
 
// Resolution Sample Code - Sets Series<double> to the current bar's SMA(20) value
Values[0] = SMA(20)[0];
The following CS1525 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
The compiler detected an invalid character in an expression.
 
Error Description #1
{ expected
 
// Erroneous Sample Code - If statement is not opened
protected override void OnBarUpdate()
{
  if(IsFirstTickOfBar)      
}
 
// Resolution Sample Code - If statement is open and closed
protected override void OnBarUpdate()
{
  if (IsFirstTickOfBar)
  {
    // do something
  }
}
 
Unfortunately we do not have NinjaScript context based Help information on this specific error code. You can check the Microsoft MSDN site section on error codes for futher information.
Using Compiled Assemblies
Compiled assemblies (DLL's) allow you to bundle your scripts into a format that hides your proprietary code along with any supporting resources. Compiled assemblies provide distinct benefits, especially for commercially distributed code, but there are a few considerations to keep in mind. Typecasting and building resource files (sounds, images, etc.) into your assemblies must be approached differently to ensure cleanly packaged, error-free DLL's.
 
Casting Types in a DLL (Using dynamic Types)
Sometimes, you may need to cast your objects to NinjaScript types, such as when iterating through the DrawObjects collection to obtain a reference to a particular Drawing Object on a chart. When running C# code which has not been compiled into an assembly, typecasting can be done normally, as in the example below:
 
 
An obstacle arises with traditional typecasting in a compiled assembly, since the NinjaScript Type you attempt to cast will be present in both your DLL and NinjaTrader's Custom.dll assembly. If you plan to compile your code into a DLL, you will need to use the dynamic Type to avoid this conflict by dynamically assigning the Type at runtime, using the guidelines below:
 
1.Define a variable of Type 'dynamic'
2.Assign a reference to the needed object to the dynamic variable
3.Access the dynamic variable as if it were of the expected Type
 
 
The above dynamic approach will work for primitive types. For instantiating more complex types / classes though, such as adding a new PriceLevel programmatically to an existing drawing tool, Reflection would need to used.
 
 
Working With the dynamic Type
Using dynamic variables in the technique above requires careful attention to accessing members appropriately, and thus should be avoided if you do not intend to use or distribute compiled assemblies.
 
•No Intelliprompt: Since the compiler cannot know which Type you assume a dynamic variable to be, no intelliprompt will be displayed to help search through Type members. The same applies to Visual Studio's Intellisense or similar utilities
 
•No Compile Errors: For the same reason, the compiler cannot know if you are using the variable in a way not supported by its expected Type, trying to access members not present in that Type, or other related errors. Thus, any such errors which would be caught by the compiler when typecasting will be missed, and will result in runtime errors instead. If a runtime error were to be triggered, the error may be more difficult to interpret.
oExample: If you tried to access "line.tag" (improper capitalization) in the examples above, you would receive the following errors:
▪Typecasting / Compile Error: "'NinjaTrader.NinjaScript.DrawingTools.HorizontalLine' does not contain a definition for 'tag' and no extension method accepting a first argument of type 'NinjaTrader.NinjaScript.DrawingTools.HorizontalLine' can be found (are you missing a using directive or an assembly reference?)"
▪dynamic / Runtime Error: "Error on calling 'OnBarUpdate' method on bar 0: 'NinjaTrader.NinjaScript.DrawingTools.DrawingTool.tag' is inaccessible due to its protection level"
 
 
Adding XAML and Other Files Into a DLL
When exporting a compiled assembly through NinjaTrader, no additional resource files can be added. There are two ways around this. The first is to export the DLL from NinjaTrader, then open the exported .zip file, add any additional files, and re-zip the archive, but this will result in your resource files being fully accessible to end users. The second and recommended approach is to use a fully featured IDE such as Visual Studio to build your DLL's.
 
For more information on how to accomplish this with Visual Studio, see the "AddOn Development Environment" section of the AddOn Development Overview page. Although the page focuses on AddOn development, the sample project it provides can be used to develop other NinjaScript Types, as well.
 
Exporting custom drawing tools as assembly / DLL
When planning to distribute your custom drawing tools via assemblies, please understand it's paramount that you implement your own Draw. method to allow the drawing tool getting called programmatically by other NinjaScript objects.
 
The NinjaTrader default drawing tools would implement this via a partial class, for example you would see -
 
 
However since partial classes could not span across two assemblies, therefore a custom non partial Draw. method for your NinjaScript drawing tool would be needed.
 
 
Exports might not be backwards compatible
NinjaScript exports might not be backwards compatible with previous versions of NinjaTrader.
 
This is known to happen every time a new type (e.g. Enum) was introduced, since the newly introduced types are not known to prior releases of NinjaTrader
 
Typically an error message like the following would be seen:
 
"Error on calling 'SetState' method: Could not load type 'NinjaTrader.NinjaScript.Indicators.CumulativeDeltaType' from assembly 'NinjaTrader.Vendor, Version=8.0.12.0, Culture=neutral, PublicKeyToken=null'."
Tick Replay is used to playback 1 tick historical data to build the bars as if they had been build live, this means that tick data will be thrown as Market Data events in historical and subsequently OnMarketData and OnBarUpdate events will be called as if it was live. This provides more granular tick related information and can be helpful if you need to know the most recent last price, last volume, best ask price, or best bid price that occurred on historical data during the bar. An indicator or strategy running Tick Replay needs to have been specifically designed to take advantage of Tick Replay.  In general, this means adding additional logic to the OnMarketData() event handler, however, Tick Replay can also be used to call OnBarUpdate() "OnEachTick" or "OnPriceChange" during historical calculations.
 
How to Enable Tick Replay
To enable tick replay it must be manually enabled on the primary Data Series and the option to allow this mode is hidden by default. The option to allow for Tick Replay is located in Tools > Options > Market Data > "Show Tick Replay". The reason why it is hidden by default is that the tick replay engine utilizes 1 tick data to build historical bars. TickReplay can generate thousands of events per bar and may take an excessive amount of time to load.  It is recommended to optimize your indicators that you plan to calculate on such data by only running them in Calculate On Bar Close mode or reducing the amount of data to load to the minimum amount of data required. Since bars are built with tick data you will only be able to build bars back as far as your historical data provider allows download of tick data.
 
How the Tick Replay Engine Works
Tick Replay guarantees an exact sequence of stored events are played back for both the OnBarUpdate and OnMarketData events.  This mode also ensures the OnMarketData event is called after every OnBarUpdate event used to build the current bar.  Consider the following examples with Tick Replay enabled on a 5-tick input series, each box is when each event occurs during Tick Replay simulation.
 

 
As you can see from the table above, the Calculate setting will have a varying degree of impact on how your indicator or strategies OnBarUpdate event is raised. This process repeats for every historical bar on the chart and would continue as the indicator or strategy transitions to real-time data.
 
Accessing the current best bid and ask at the time of a trade
NinjaTrader stores the best bid price and best ask price as the last trade occurs during the MarketDataType.Last event and provides it per the table below:
 
 
An example below shows how to access historical Bid and Ask prices with Tick Replay
 
Calling a Tick Replay indicator from another Indicator or Strategy
A hosting indicator or strategy must be aware of the requirement to run through another indicator's historical Tick Replay data before it reaches State.Historical. To achieve desired results, you either need to store the reference in State.DataLoaded or (for a strategy) you can call AddChartIndicator().  Either approach ensures that the hosting indicator or strategy is aware of the requirements to process Tick Replay during its State.Historical mode and helps to ensure that the hosted indicator calculates as designed up to its current bar using Tick Replay.  Please see the example below.
 
 
Multi-Threading Overview
With the introduction of multi-threading in NinjaTrader special considerations should be made when programming your NinjaScript objects. Multi-threading basically allows NinjaTrader to take advantage of multi-core CPUs commonplace in modern computing to do multiple tasks at the same time.  While this has many advantages for multi-tasking, it can cause new types of issues you may have not needed to consider before.  This page was designed to serve as a high-level overview of some of the most common scenarios that can arise due to multi-threading, but should not be considered an exhaustive list.  
 
Using A Dispatcher
Depending on your CPU configuration, the NinjaTrader application will usually consist of multiple main UI threads, where various features like Charts or NinjaScript objects run, along with a number of background worker threads where events such as market data updates will be distributed throughout the product.  In principle, an object can only access information related to objects that exist on the same thread.  It is possible (and quite likely), that the thread which a NinjaScript object is running will not be the same thread as the event which is calling the object.  In cases where you need to access objects on the UI from a NinjaScript objects calling event thread, a dispatcher can be used.
 
 
 
 
Thread Access
Since market data is distributed across the entire application by a randomly assigned UI thread, there is no guarantee that your object will be running on the same event thread that is calling the object. Therefore it is recommend that you call Dispatcher.CheckAccess() in order to test if you truly need to dispatch the requested action.
 
 
 
Cross Thread Exceptions
When accessing objects included on the UI, you may receive the following error if you attempt to access a certain property/method from the wrong thread:
 
"Error on calling 'OnBarUpdate' method on bar 0: You are accessing an object which resides on another thread. I.E. creating your own Brush without calling .Freeze(), or trying to access a UI control from the wrong thread without using a Dispatcher"
 
This error can be avoided by invoking the Dispatcher used on the appropriate UI thread.
 
Access Violation Exception
Should you be using custom resources like text files, static members, etc. it is important to protect your resources from concurrent access. If NinjaTrader tried to use the resource at the same time you would run into errors similar to this one:
 
8/20/2010 12:14:29 PM|3|128|Error on calling 'OnBarUpdate' method for strategy 'SampleStrategy/1740b50bfe5d4bd896b0533725622400': The process cannot access the file 'c:\sample.txt' because it is being used by another process.
 
 
Multi-threaded consideration for Order, Execution and Position objects
 
These considerations apply to the OnOrderUpdate(), OnExecutionUpdate() and OnPositionUpdate() handlers, where both the actual 'core' objects are passed by reference and updating method value parameters are provided. Examplary the OnOrderUpdate() is discussed in below.
 
•OnOrderUpdate() method guarantees that you will see each order state change in sequence
•The "order" method parameter represents the core order object updated by NinjaTrader
•The supplementary method parameters provide an updating value representing each order change in sequence.  Think of this as the relevant information on the order at the time the state changed.
•Since the "order"  method parameter represents the current order object state, it is possible for the updating values of that object to be out of sync with the correspond method parameters during a particular order update event.
 
As an example, the NinjaTrader core may have received "Working" and then "PartFilled" order state change events back from the broker API on thread "B". At some point in time (milliseconds later) the NinjaTrader core will take these events and trigger the OnOrderUpdate() method in the strategy on thread "A". Thus, when the strategy receives the first "Working" state for an order, the orderState method parameter will reflect the "Working" state although the actual order.OrderState is really in a state of "Part Filled".  You would see that current value truly reflected in the core Order object method parameter or any order objects returned in any of the order methods such as EnterLong(). Of course, the OnOrderUpdate() method parameters will eventually receive the event for "PartFilled" state in the sequence the events were received.
 
Considering the concept above, if you are unsure if you should be using the core order object value vs the updating method parameter value value, ask your self if you are truly looking for the most current order state, or the sequence of order states:
 
•For the most current order state, use the core "order" object property (e.g., order.OrderState, order.LimitPrice, order.StopPrice, etc)
•For the sequence of order states, use the updating method parameter value (e.g., orderState, limitPrice, stopPrice, etc)
Multi-Threading Overview
With the introduction of multi-threading in NinjaTrader special considerations should be made when programming your NinjaScript objects. Multi-threading basically allows NinjaTrader to take advantage of multi-core CPUs commonplace in modern computing to do multiple tasks at the same time.  While this has many advantages for multi-tasking, it can cause new types of issues you may have not needed to consider before.  This page was designed to serve as a high-level overview of some of the most common scenarios that can arise due to multi-threading, but should not be considered an exhaustive list.  
 
Using A Dispatcher
Depending on your CPU configuration, the NinjaTrader application will usually consist of multiple main UI threads, where various features like Charts or NinjaScript objects run, along with a number of background worker threads where events such as market data updates will be distributed throughout the product.  In principle, an object can only access information related to objects that exist on the same thread.  It is possible (and quite likely), that the thread which a NinjaScript object is running will not be the same thread as the event which is calling the object.  In cases where you need to access objects on the UI from a NinjaScript objects calling event thread, a dispatcher can be used.
 
 
 
 
Thread Access
Since market data is distributed across the entire application by a randomly assigned UI thread, there is no guarantee that your object will be running on the same event thread that is calling the object. Therefore it is recommend that you call Dispatcher.CheckAccess() in order to test if you truly need to dispatch the requested action.
 
 
 
Cross Thread Exceptions
When accessing objects included on the UI, you may receive the following error if you attempt to access a certain property/method from the wrong thread:
 
"Error on calling 'OnBarUpdate' method on bar 0: You are accessing an object which resides on another thread. I.E. creating your own Brush without calling .Freeze(), or trying to access a UI control from the wrong thread without using a Dispatcher"
 
This error can be avoided by invoking the Dispatcher used on the appropriate UI thread.
 
Access Violation Exception
Should you be using custom resources like text files, static members, etc. it is important to protect your resources from concurrent access. If NinjaTrader tried to use the resource at the same time you would run into errors similar to this one:
 
8/20/2010 12:14:29 PM|3|128|Error on calling 'OnBarUpdate' method for strategy 'SampleStrategy/1740b50bfe5d4bd896b0533725622400': The process cannot access the file 'c:\sample.txt' because it is being used by another process.
 
 
Multi-threaded consideration for Order, Execution and Position objects
 
These considerations apply to the OnOrderUpdate(), OnExecutionUpdate() and OnPositionUpdate() handlers, where both the actual 'core' objects are passed by reference and updating method value parameters are provided. Examplary the OnOrderUpdate() is discussed in below.
 
•OnOrderUpdate() method guarantees that you will see each order state change in sequence
•The "order" method parameter represents the core order object updated by NinjaTrader
•The supplementary method parameters provide an updating value representing each order change in sequence.  Think of this as the relevant information on the order at the time the state changed.
•Since the "order"  method parameter represents the current order object state, it is possible for the updating values of that object to be out of sync with the correspond method parameters during a particular order update event.
 
As an example, the NinjaTrader core may have received "Working" and then "PartFilled" order state change events back from the broker API on thread "B". At some point in time (milliseconds later) the NinjaTrader core will take these events and trigger the OnOrderUpdate() method in the strategy on thread "A". Thus, when the strategy receives the first "Working" state for an order, the orderState method parameter will reflect the "Working" state although the actual order.OrderState is really in a state of "Part Filled".  You would see that current value truly reflected in the core Order object method parameter or any order objects returned in any of the order methods such as EnterLong(). Of course, the OnOrderUpdate() method parameters will eventually receive the event for "PartFilled" state in the sequence the events were received.
 
Considering the concept above, if you are unsure if you should be using the core order object value vs the updating method parameter value value, ask your self if you are truly looking for the most current order state, or the sequence of order states:
 
•For the most current order state, use the core "order" object property (e.g., order.OrderState, order.LimitPrice, order.StopPrice, etc)
•For the sequence of order states, use the updating method parameter value (e.g., orderState, limitPrice, stopPrice, etc)
Multi-Series Scripting Overview
NinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.
 
 
It is also important that you understand the following method and properties:
 
•AddDataSeries()
•BarsArray
•BarsInProgress
•CurrentBars
 
        Working With Multi-Time Frame Objects
        Adding Additional Bars Objects to NinjaScript
        Creating Series<T> Objects
        How Bars Data is Referenced
        Using Bars Objects as Input to Indicator Methods
        True Event Driven OnBarUpdate() Method
        Accessing the Price Data in a Multi-Bars NinjaScript
        Entering, Exiting and Retrieving Position Information
NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•"UI" instances representing its default properties on various user interfaces
•The "configured" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select "Indicator"
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses "Apply" or "OK"
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of "Available" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of "Available" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the "Properties" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd "configured" instance you are concerned with developing, but you should also be aware of the "UI" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or "Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
3rd Party Indicators Overview
You can use 3rd party indicators within your strategies or custom indicators. A 3rd party indicator is an indicator that was not developed by NinjaTrader.
 
 
3rd party indicators can be provided to you in one of the following ways:
 
•NinjaScript archive file that can be directly imported into NinjaTrader  
•A custom installer
•A set of files and instructions for saving them in the correct folders
 
If you were provided with a NinjaScript archive file that you have successfully imported via the Control Center window "File > Utilities > Import NinjaScript" menu, you can skip over the information below since NinjaTrader automatically configures the indicators ready for use.
 
If you were provided with a custom installer or a compiled assembly (.DLL) file that you had to manually save in the folder My Documents\NinjaTrader Folder>\bin\Custom then you must follow the instructions below.
 
Vendor File
The 3rd party developer should have either installed a "Vendor" file or provided you with one. Its likely in the format "NinjaTrader.VendorName.cs" where VendorName is the name of the 3rd party vendor. This file allows you to conveniently access their indicators.
 
•If you were provided an installer, you can check with the vendor if this file was included or;
•If they provided you this file, save it to "My Documents\<NinjaTrader Folder>\bin\Custom" and restart NinjaTrader
 
Adding a Reference
1. From within the NinjaScript Editor, right click on your mouse to bring up the context menu and select the sub-menu References... as per the image to the right.

 
2. A References window will appear
 
3. Press the "add" and select the 3rd party vendor DLL file
 
 
4. You will see a reference to the 3rd party vendor DLL in the References window
 
5. Press the OK button
 
You will now be able to access the indicator methods provided by the 3rd party vendor
 

You can create an automated strategy that generates a trade signal that executes a NinjaTrader ATM Strategy.
 
•ATM Strategies operate in real-time only and will not execute on historical data thus they can't be backtested
•Executions resulting from an ATM Strategy that is created from within a NinjaScript automated strategy will not plot on a chart during real-time operation
•Strategy set up parameters such as EntriesPerDirection, EntryHandling, IsExitOnSessionCloseStrategy do not apply when calling the AtmStrategyCreate() method
•Executions from ATM Strategies will not have an impact on the hosting NinjaScript strategy position and PnL - the NinjaScript strategy hands off the execution aspects to the ATM, thus no monitoring via the regular NinjaScript strategy methods will take place (also applies to strategy performance tracking)
•ATM Strategy stop orders can either be StopMarket or StopLimit orders, depending on which type is defined in the ATM Strategy Template (Advanced Options) you call in the AtmStrategyCreate() method in your NinjaScript strategy. To make the distinction clear which is used, following a naming convention for the template name is highly suggested (i.e. AtmStrategyTemplate_STPLMT)
•A general sample for calling ATM's is preinstalled with NinjaTrader under the 'SampleATMStrategy' script - for a script showing how to implement reversal type setups, please see this link to our online resources.
 
There is a Clear Line...
There is a clear line between a NinjaScript Strategy and an ATM Strategy. The use model for creating an ATM Strategy within a NinjaScript Strategy is when you want to programmatically monitor and generate an entry signal and then manualy manage the resulting open position via an ATM Strategy in one of NinjaTrader's order entry windows.
 
!!! IMPORTANT: Manually Closing an ATM Strategy from an Order Entry Window such as the SuperDOM
It is crucial that when running ATM Strategies created by a NinjaScript strategy that you understand how to properly manually close the ATM Strategy from any of the order entry windows.
 
•If the order entry window ATM Strategy Selection Mode is NOT in "DisplaySelectedATMStrategyOnly" click on the "CLOSE" button via your middle mouse button (scroll wheel)
•If the order entry window ATM Strategy Selection Mode is in "DisplaySelectedATMStrategyOnly" you can click on the "CLOSE" button with your left mouse button to close the selected active ATM strategy
 
Following the approaches above will internally close the ATM Strategy. Not following the approach will close the account/instrument position, terminate all strategies and cancel all orders. The result is that your NinjaScript strategy will be terminated.
Images as Buttons Overview
BitmapImage objects can be used to apply an image as a background to a Button object added to a NinjaTrader window.
 
 
Using an image as the background for a button can be achieved through a fairly straightforward process using some of the .NET framework's Controls and Imaging methods
 
There are a few best practices to keep in mind when working with Buttons:
•Dispose of any leftover objects in State.Terminated for efficient memory use
•Use your object's main Dispatcher when adding or removing Buttons to or from your chart, to ensure that the correct thread is used
•Be aware of the proper States in which to initialize objects related to the Button (State.Configure), apply the Button (State.Historical), and dispose of unneeded objects (State.Terminated)
 
Adding a Button to a Chart Toolbar Using an Image as the Background
The example below walks through the process of adding a Button to a chart toolbar specifically, and applying a .jpg image as the Button's background. This example also displays several best practices when working with Buttons, such as proper object disposal and ensuring that the Button is not populated when the indicator is applied in an inactive chart tab.
 
Images as Buttons Overview
BitmapImage objects can be used to apply an image as a background to a Button object added to a NinjaTrader window.
 
 
Using an image as the background for a button can be achieved through a fairly straightforward process using some of the .NET framework's Controls and Imaging methods
 
There are a few best practices to keep in mind when working with Buttons:
•Dispose of any leftover objects in State.Terminated for efficient memory use
•Use your object's main Dispatcher when adding or removing Buttons to or from your chart, to ensure that the correct thread is used
•Be aware of the proper States in which to initialize objects related to the Button (State.Configure), apply the Button (State.Historical), and dispose of unneeded objects (State.Terminated)
 
Adding a Button to a Chart Toolbar Using an Image as the Background
The example below walks through the process of adding a Button to a chart toolbar specifically, and applying a .jpg image as the Button's background. This example also displays several best practices when working with Buttons, such as proper object disposal and ensuring that the Button is not populated when the indicator is applied in an inactive chart tab.
 
Custom Icon Overview
When overriding the Icon method in a Bars Type, Share Service, Drawing Object, or Chart Style, you can use a variety of inputs to specify what will be displayed on the icon, including UniCode characters (if they exist in the icon pack for the font family used in NinjaTrader), custom Geometry Paths from the System.Windows.Shapes namespace, or image files. Using an image file for a custom icon can allow the flexibility of creating your icon's visuals outside of your code via image editing software. For more information about adding custom Icons, see the "Icon" page under the topics for each of the NinjaScript object types listed above.
 
        Using an Image as an Icon
permalink
        Using Geometry on an Icon
 
Historical Bid/Ask Series Overview
NinjaTrader has the ability to use historical bid and ask price series in your NinjaScript instead of only being able to use a last price series. The following outlines the intricacies of this capability:
 
 
 
Accessing Bid/Ask Series
When calling AddDataSeries() to add an additional Bars object to your script, a constructor overload will be available which takes a MarketDataType enumeration as an argument. This will allow you to specify the price series which will be used in that particular object. If you were to pass in MarketDataType.Ask or MarketDataType.Bid, as in the example below, that particular data series will use that price type for all of its PriceSeries collections, such as Close, Open, High, and Low.
 
 
Example
Custom Icon Overview
When overriding the Icon method in a Bars Type, Share Service, Drawing Object, or Chart Style, you can use a variety of inputs to specify what will be displayed on the icon, including UniCode characters (if they exist in the icon pack for the font family used in NinjaTrader), custom Geometry Paths from the System.Windows.Shapes namespace, or image files. Using an image file for a custom icon can allow the flexibility of creating your icon's visuals outside of your code via image editing software. For more information about adding custom Icons, see the "Icon" page under the topics for each of the NinjaScript object types listed above.
 
        Using an Image as an Icon
        Using Geometry on an Icon
permalink
 
In order to achieve custom rendering for various chart related objects, a Brush is used to "paint" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
permalink
        Understanding custom brushes
        Using brushes defined on the user interface
        Using advanced brush types (SharpDX)
In order to achieve custom rendering for various chart related objects, a Brush is used to "paint" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
        Understanding custom brushes
permalink
        Using brushes defined on the user interface
        Using advanced brush types (SharpDX)
In order to achieve custom rendering for various chart related objects, a Brush is used to "paint" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
        Understanding custom brushes
        Using brushes defined on the user interface
permalink
        Using advanced brush types (SharpDX)
In order to achieve custom rendering for various chart related objects, a Brush is used to "paint" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
        Understanding custom brushes
        Using brushes defined on the user interface
        Using advanced brush types (SharpDX)
permalink
Price Data Overview
The core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.
 
Definitions
 
 
Referencing Series
 
You will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:
 
 High[1] < High[0];
 
You could write a statement to calculate the average closing price of the last three bars like this:
 
 ( Close[2] + Close[1] + Close[0] ) / 3;
 
As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.
 
 
 
Referencing Indicator Data
NinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.
 
All indicator values can be accessed in the following way:
 
 indicator(parameters)[int barsAgo]
 
where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.
 
As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:
 
 Close[0] > SMA(20)[0];
 
If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:
 
 Close[0] > SMA(High, 20)[0];
 
You could write a statement to see if a 14 period CCI indicator is rising like this:
 
 CCI(14)[0] > CCI(14)[1];
 
Value of a 10 period CCI 1 bar ago = CCI(10)[1]
 
Please review the Indicator Methods section for proper syntax for accessing different indicator values.
Native Methods
The Microsoft .NET environment has a rich class library that you can access when developing custom indicators and strategies. There is a plethora of information available online and in print that details class libraries in great depth. Below are quick links to the Microsoft Developers Network for some of the basic classes whose functionality you may harness when developing in NinjaScript.
 
Complete list of classes in the Microsoft .NET environment.
 
MSDN (Microsoft Developers Network) C# Language Reference
Keywords
Operators
Arrays
 
System.Math
Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.
Full list of member of the System.Math class.
 
 
System.DateTime
Represents an instant in time, typically expressed as a data and time of day.
Full list of members of the Sytem.DateTime structure.
 
 
System.String
Represents text; that is, a series of unicode characters.
Full list of members of the System.String class.
 
Pular para o conteúdo principal
Aprender
Descobrir
Documentação do produto
Linguagens de desenvolvimento
Tópicos
Entrar
 Não estamos mais atualizando este conteúdo regularmente. Verifique o Microsoft Product Lifecycle para obter informações sobre como este produto, serviço, tecnologia ou API é suportado.
Retornar ao site principal
Dispensar alerta
Principio del formulario
Procurar
Final del formulario
Referência da biblioteca de classes do .NET Framework
Aprender 
 
Versões anteriores 
C#
Salvar



Referência da biblioteca de classes do .NET Framework
Artigo
15/09/2008
Neste artigo
Espaços de nomes
Veja também
A biblioteca de classes do .NET Framework é uma biblioteca de classes, interfaces e tipos de valor que estão incluídos no Microsoft .NET Framework. Esta biblioteca fornece acesso à funcionalidade do sistema e é projetada para ser a base sobre a qual os aplicativos, componentes e controles do .NET Framework são criados.
Espaços de nomes
A biblioteca de classes do .NET Framework fornece os seguintes namespaces:
Microsoft.Aspnet.Snapin
Contém classes necessárias para que o aplicativo de console de gerenciamento ASP.NET interaja com o Microsoft Management Console (MMC).
Microsoft.Build.BuildEngine
Contém as classes que representam o mecanismo MSBuild.
Microsoft.Build.Framework
Contém classes que compõem as tarefas, registradores e eventos do MSBuild.
Microsoft.Build.Tasks
Contém a implementação de todas as tarefas enviadas com o MSBuild.
Microsoft.Build.Tasks.Deployment.Bootstrapper
Contém classes usadas internamente pelo MSBuild.
Microsoft.Build.Tasks.Deployment.ManifestUtilities
Contém classes usadas internamente pelo MSBuild.
Microsoft.Build.Utilities
Fornece classes auxiliares que você pode usar para criar seus próprios registradores e tarefas do MSBuild.
Microsoft.Csharp
Contém classes que oferecem suporte à compilação e geração de código usando a linguagem C#.
Microsoft.JScript
Contém classes que oferecem suporte à compilação e geração de código usando a linguagem JScript.
Microsoft.SqlServer.Server
Contém classes específicas para a integração do componente CLR (Common Language Runtime) do Microsoft .NET Framework no Microsoft SQL Server e no ambiente de execução do processo do mecanismo de banco de dados do SQL Server.
Microsoft.VisualBasic
Contém classes que oferecem suporte à compilação e geração de código usando a linguagem Visual Basic.
Microsoft.VisualBasic.ApplicationServices
Contém tipos que suportam o Modelo de Aplicativo do Visual Basic e fornecem acesso às informações do aplicativo.
Microsoft.VisualBasic.CompilerServices
Contém tipos somente de uso interno que suportam o compilador Visual Basic.
Microsoft.VisualBasic.Devices
Contém tipos que suportam os objetos My relacionados a dispositivos no Visual Basic.
Microsoft.VisualBasic.FileIO
Contém tipos que suportam o objeto Meu sistema de arquivos no Visual Basic.
Microsoft.VisualBasic.Logging
Contains types that support the My logging objects in Visual Basic and provides a simple log listener that directs logging output to file.
Microsoft.VisualBasic.MyServices
Contains types that support My in Visual Basic.
Microsoft.VisualBasic.MyServices.Internal
Contains internal-use only types that support My in Visual Basic.
Microsoft.VisualBasic.Vsa
Microsoft.VisualC
Microsoft.Vsa
Contains interfaces that allow you to integrate script for the .NET Framework script engines into applications, and to compile and execute code at run time.
Microsoft.Vsa.Vb.CodeDOM
Microsoft.Win32
Provides two types of classes: those that handle events raised by the operating system and those that manipulate the system registry.
Microsoft.Win32.SafeHandles
Contains classes that are abstract derivations of safe handle classes that provide common functionality supporting file and operating system handles.
Microsoft.WindowsCE.Forms
Contains classes for developing Pocket PC and Smartphone Windows Forms applications using the .NET Compact Framework.
Microsoft.WindowsMobile.DirectX
Contains classes for developing DirectX applications on devices with the .NET Compact Framework. Requires a future release of Windows Mobile to run the applications.
Microsoft.WindowsMobile.DirectX.Direct3D
Contains classes for developing Direct3D applications on devices with the .NET Compact Framework. Requires a future release of Windows Mobile to run the applications.
Microsoft_VsaVb
System
Contains fundamental classes and base classes that define commonly used value and reference data types, events and event handlers, interfaces, attributes, and processing exceptions. Other classes provide services supporting data type conversion, method parameter manipulation, mathematics, remote and local program invocation, application environment management, and supervision of managed and unmanaged applications.
System.CodeDom
Contains classes that can be used to represent the elements and structure of a source code document. These elements can be used to model the structure of a source code document that can be output as source code in a supported language using the functionality provided by the System.CodeDom.Compiler namespace.
System.CodeDom.Compiler
Contains types for managing the generation and compilation of source code in supported programming languages. Code generators can each produce source code in a particular programming language based on the structure of Code Document Object Model (CodeDOM) source code models consisting of elements provided by the System.CodeDom namespace.
System.Collections
Contains interfaces and classes that define various collections of objects, such as lists, queues, bit arrays, hashtables and dictionaries.
System.Collections.Generic
Contains interfaces and classes that define generic collections, which allow users to create strongly typed collections that provide better type safety and performance than non-generic strongly typed collections.
System.Collections.ObjectModel
Contains classes that can be used as collections in the object model of a reusable library. Use these classes when properties or methods return collections.
System.Collections.Specialized
Contains specialized and strongly typed collections; for example, a linked list dictionary, a bit vector, and collections that contain only strings.
System.ComponentModel
Provides classes that are used to implement the run-time and design-time behavior of components and controls. This namespace includes the base classes and interfaces for implementing attributes and type converters, binding to data sources, and licensing components.
System.ComponentModel.Design
Contains classes that developers can use to build custom design-time behavior for components and user interfaces for configuring components at design time. The design time environment provides systems that enable developers to arrange components and configure their properties.
System.ComponentModel.Design.Data
Contains classes for implementing design-time behavior of data-related components.
System.ComponentModel.Design.Serialization
Provides types that support customization and control of serialization at design time.
System.Configuration
Contains the types that provide the programming model for handling configuration data.
System.Configuration.Assemblies
Contains classes that are used to configure an assembly.
System.Configuration.Install
Provides classes that allow you to write custom installers for your own components. The Installer class is the base class for all custom installers in the .NET Framework.
System.Configuration.Provider
Contains the base classes shared by both server and client applications to support a pluggable model to easily add or remove functionality.
System.Data
Contains classes that constitute most of the ADO.NET architecture. The ADO.NET architecture enables you to build components that efficiently manage data from multiple data sources. In a disconnected scenario (such as the Internet), ADO.NET provides the tools to request, update, and reconcile data in multiple tier systems. The ADO.NET architecture is also implemented in client applications, such as Windows Forms, or HTML pages created by ASP.NET.
System.Data.Common
Contains classes shared by the .NET Framework data providers. A .NET Framework data provider describes a collection of classes used to access a data source, such as a database, in the managed space.
System.Data.Design
Contains classes that can be used to generate a custom typed-dataset.
System.Data.Linq
Contains classes to access relational data as objects. DataContext and related classes can be used for Reading, Creating, Updating and Deleting objects mapped to a database using mapping specified as attributes in your object model or in a separate external XML file.
System.Data.Linq.Mapping
Provides programmatic access to mapping information used by LINQ to SQL.
System.Data.Odbc
Contains classes that encapsulate the .NET Framework Data Provider for ODBC. The .NET Framework Data Provider for ODBC describes a collection of classes used to access an ODBC data source in the managed space.
System.Data.OleDb
Contains classes that encapsulate the .NET Framework Data Provider for OLE DB. The .NET Framework Data Provider for OLE DB describes a collection of classes used to access an OLE DB data source in the managed space.
System.Data.OracleClient
Contains classes that encapsulate the .NET Framework Data Provider for Oracle. The .NET Framework Data Provider for Oracle describes a collection of classes used to access an Oracle data source in the managed space.
System.Data.Sql
Contains classes that support SQL Server-specific functionality. The API extensions in this class add to the .NET Framework Data Provider for SQL Server (System.Data.SqlClient).
System.Data.SqlClient
Contains classes that encapsulate the .NET Framework Data Provider for SQL Server. The .NET Framework Data Provider for SQL Server describes a collection of classes used to access a SQL Server database in the managed space.
System.Data.SqlServerCE
Describes a collection of classes that can be used to access a database in SQL Server CE from Windows CE-based devices in the managed environment. With this namespace you can create SQL Server CE databases on a device and also establish connections to SQL Server databases that are on a device or on a remote server.
System.Data.SqlTypes
Contains classes for native data types within SQL Server. These classes provide a faster alternative to other data types. Using the classes in this namespace helps prevent type conversion errors caused in situations where loss of precision could occur. Because other data types are converted to and from SqlTypes behind the scenes, explicitly creating and using objects within this namespace results in faster code as well.
System.Diagnostics
Provides classes that allow you to interact with system processes, event logs, and performance counters. This namespace also provides classes that allow you to debug your application and to trace the execution of your code. For more information, see the Trace and Debug classes.
System.Diagnostics.CodeAnalysis
Contains classes for interaction with code analysis tools. Code analysis tools are used to analyze code for conformance to coding conventions such as naming or security rules.
System.Diagnostics.Design
Contains classes that can be used to extend design-time support for application monitoring and instrumentation.
System.Diagnostics.SymbolStore
Provides classes that allow you to read and write debug symbol information, such as source line to Microsoft intermediate language (MSIL) maps. Compilers targeting the .NET Framework can store the debug symbol information into programmer's database (PDB) files. Debuggers and code profiler tools can read the debug symbol information at run time.
System.DirectoryServices
Provides easy access to Active Directory from managed code. The namespace contains two component classes, DirectoryEntry and DirectorySearcher, which use the Active Directory Services Interfaces (ADSI) technology. ADSI is the set of interfaces that Microsoft provides as a flexible tool for working with a variety of network providers. ADSI gives the administrator the ability to locate and manage resources on a network with relative ease, regardless of the network's size.
System.DirectoryServices.ActiveDirectory
Provides a high level abstraction object model that builds around Microsoft® Active Directory® directory service tasks. The Active Directory® directory service concepts such as forest, domain, site, subnet, partition and schema are part of the object model.
System.DirectoryServices.Protocols
Provides the methods defined in the Lightweight Directory Access Protocol (LDAP) version 3 (V3) and Directory Services Markup Language (DSML) version 2 (V2) standards.
System.Drawing
Provides access to GDI+ basic graphics functionality. More advanced functionality is provided in the System.Drawing.Drawing2D, System.Drawing.Imaging, and System.Drawing.Text namespaces.
System.Drawing.Design
Contains classes that extend design-time user interface (UI) logic and drawing. You can further extend this design-time functionality to create custom toolbox items, type-specific value editors that can edit and graphically represent values of their supported types, or type converters that can convert values between certain types. This namespace provides the basic frameworks for developing extensions to the design-time UI.
System.Drawing.Drawing2D
Provides advanced 2-dimensional and vector graphics functionality. This namespace includes the gradient brushes, the Matrix class (used to define geometric transforms), and the GraphicsPath class.
System.Drawing.Imaging
Provides advanced GDI+ imaging functionality. Basic graphics functionality is provided by the System.Drawing namespace.
System.Drawing.Printing
Provides print-related services. Typically, you create a new instance of the PrintDocument class, set the properties that describe what to print, and call the Print method to actually print the document.
System.Drawing.Text
Provides advanced GDI+ typography functionality. Basic graphics functionality is provided by the System.Drawing namespace. The classes in this namespace allow users to create and use collections of fonts.
System.EnterpriseServices
Provides an important infrastructure for enterprise applications. COM+ provides a services architecture for component programming models deployed in an enterprise environment. This namespace provides .NET Framework objects with access to COM+ services, making the .NET Framework objects more practical for enterprise applications.
System.EnterpriseServices.CompensatingResourceManager
Provides classes that allow you to use a Compensating Resource Manager (CRM) in managed code. A CRM is a service provided by COM+ that enables you to include non-transactional objects in Microsoft Distributed Transaction Coordinator (DTC) transactions. Although CRMs do not provide the capabilities of a full resource manager, they do provide transactional atomicity (all-or-nothing behavior) and durability through the recovery log.
System.EnterpriseServices.Internal
Provides infrastructure support for COM+ services. The classes and interfaces in this namespace are specifically intended to support calls into System.EnterpriseServices from the unmanaged COM+ classes.
System.Globalization
Contains classes that define culture-related information, including the language, the country/region, the calendars in use, the format patterns for dates, currency, and numbers, and the sort order for strings. These classes are useful for writing globalized (internationalized) applications.
System.IO
Contains types that allow synchronous and asynchronous reading and writing on data streams and files.
System.IO.Compression
Contains classes that provide basic compression and decompression for streams.
System.IO.IsolatedStorage
Contains types that allow the creation and use of isolated stores. With these stores, you can read and write data that less trusted code cannot access and help prevent the exposure of sensitive information that can be saved elsewhere on the file system. Data is stored in compartments that are isolated by the current user and by the assembly in which the code exists.
System.IO.Ports
Contains classes that control serial ports, providing a framework for synchronous and event-driven I/O, access to pin and break states, access to serial driver properties, and enumerations for specifying port characteristics.
System.Linq
Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).
System.Linq.Expressions
Contains classes, interfaces and enumerations that enable language-level code expressions to be represented as objects in the form of expression trees.
System.Management
Provides access to a rich set of management information and management events about the system, devices, and applications instrumented to the Windows Management Instrumentation (WMI) infrastructure.
System.Management.Instrumentation
Provides the classes necessary for instrumenting applications for management and exposing their management information and events through WMI to potential consumers. Consumers such as Microsoft Application Center or Microsoft Operations Manager can then manage your application easily, and monitoring and configuring of your application is available for administrator scripts or other applications, both managed as well as unmanaged.
System.Messaging
Provides classes that allow you to connect to, monitor, and administer message queues on the network and send, receive, or peek messages.
System.Messaging.Design
Contains classes that can be used to extend design-time support for System.Messaging classes.
System.Net
Provides a simple programming interface for many of the protocols used on networks today. The WebRequest and WebResponse classes form the basis of what are called pluggable protocols, an implementation of network services that enables you to develop applications that use Internet resources without worrying about the specific details of the individual protocols.
System.Net.Cache
Defines the types and enumerations used to define cache policies for resources obtained using the WebRequest and HttpWebRequest classes.
System.Net.Configuration
Contains classes that applications use to programmatically access and update configuration settings for the System.Net namespaces.
System.Net.Mail
Contains classes used to send electronic mail to a Simple Mail Transfer Protocol (SMTP) server for delivery.
System.Net.Mime
Holds types that are used to represent Multipurpose Internet Mail Exchange (MIME) headers. These types are used with the types in the System.Net.Mail namespace to specify Content-Type, Content-Disposition and Content-transfer-Encoding headers when sending email using the SmtpClient class.
System.Net.NetworkInformation
Provides access to network traffic data, network address information, and notification of address changes for the local computer. The namespace also contains classes that implement the Ping utility. You can use Ping and related classes to check whether a computer is reachable across the network.
System.Net.Sockets
Provides a managed implementation of the Windows Sockets (Winsock) interface for developers who need to help control access to the network.
System.Reflection
Contains classes and interfaces that provide a managed view of loaded types, methods, and fields, with the ability to dynamically create and invoke types.
System.Reflection.Emit
Contains classes that allow a compiler or tool to emit metadata and Microsoft intermediate language (MSIL) and optionally generate a PE file on disk. The primary clients of these classes are script engines and compilers.
System.Resources
Provides classes and interfaces that allow developers to create, store, and manage various culture-specific resources used in an application.
System.Resources.Tools
Contains the StronglyTypedResourceBuilder class, which provides support for strongly-typed resources. Beginning with the .NET Framework version 2.0, this compile-time feature encapsulates access to resources by creating classes that contain a set of static read-only (get) properties, thus making it easier to consume resources.
System.Runtime
Contains advanced types that support diverse namespaces such as System, the Runtime namespaces, and the Security namespaces.
System.Runtime.ConstrainedExecution
Defines a set of types that enumerate and define a contract for reliability between the author of some code, and the developers who take a dependency on that code.
System.Runtime.Hosting
Contains advanced types that are used in application activation within application domains.
System.Runtime.CompilerServices
Provides functionality for compiler writers using managed code to specify attributes in metadata that affect the run-time behavior of the common language runtime. The classes in this namespace are for compiler writers use only.
System.Runtime.InteropServices
Provides a wide variety of members that support COM interop and platform invoke services. If you are unfamiliar with these services, see Interoperating with Unmanaged Code.
System.Runtime.InteropServices.ComTypes
Contains methods that are definitions of COM functions for managed code. These functions replace the now-obsolete UCOM* methods in the System.Runtime.InteropServices namespace.
System.Runtime.InteropServices.CustomMarshalers
Supports the .NET infrastructure and is not intended to be used directly from your code.
System.Runtime.InteropServices.Expando
Contains the IExpando interface which allows modification of an object by adding or removing its members.
System.Runtime.Remoting
Provides classes and interfaces that allow developers to create and configure distributed applications.
System.Runtime.Remoting.Activation
Provides classes and objects that support server and client activation of remote objects.
System.Runtime.Remoting.Channels
Contains classes that support and handle channels and channel sinks, which are used as the transport medium when a client calls a method on a remote object.
System.Runtime.Remoting.Channels.Http
Contains channels that use the HTTP protocol to transport messages and objects to and from remote locations. By default, the HTTP channels encode objects and method calls in SOAP format for transmission, but other encoding and decoding formatter sinks can be specified in the configuration properties of a channel.
System.Runtime.Remoting.Channels.Ipc
Defines a communication channel for remoting that uses the Interprocess Communication (IPC) system of the Windows operating system. Because it does not use network communication, the IPC channel is much faster than the HTTP and TCP channels, but it can only be used for communication between application domains on the same physical computer.
System.Runtime.Remoting.Channels.Tcp
Contains channels that use the TCP protocol to transport messages and objects to and from remote locations. By default, the TCP channels encode objects and method calls in binary format for transmission, but other encoding and decoding formatter sinks can be specified in the configuration properties of a channel.
System.Runtime.Remoting.Contexts
Contains objects that define the contexts all objects reside within. A context is an ordered sequence of properties that defines an environment for the objects within it. Contexts are created during the activation process for objects that are configured to require certain automatic services such synchronization, transactions, just-in-time (JIT) activation, security, and so on. Multiple objects can live inside a context.
System.Runtime.Remoting.Lifetime
Contains classes that manage the lifetime of remote objects. Traditionally, distributed garbage collection uses reference counts and pinging for control over the lifetime of objects. This works well when there are a few clients per service, but doesn't scale well when there are thousands of clients per service. The remoting lifetime service associates a lease with each service, and deletes a service when its lease time expires. The lifetime service can take on the function of a traditional distributed garbage collector, and it also adjusts well when the numbers of clients per server increases.
System.Runtime.Remoting.Messaging
Contains classes used to create and remote messages. The remoting infrastructure uses messages to communicate with remote objects. Messages are used to transmit remote method calls, to activate remote objects, and to communicate information. A message object carries a set of named properties, including action identifiers, envoy information, and parameters.
System.Runtime.Remoting.Metadata
Contains classes and attributes that can be used to customize generation and processing of SOAP for objects and fields. The classes of this namespace can be used to indicate the SOAPAction, type output, XML element name, and the method XML namespace URI.
System.Runtime.Remoting.Metadata.W3cXsd2001
Contains the XML Schema Definition (XSD) defined by the World Wide Web Consortium (W3C) in 2001. The XML Schema Part2: Data types specification from W3C identifies format and behavior of various data types. This namespace contains wrapper classes for the data types that conform to the W3C specification. All date and time types conform to the ISO standards specification.
System.Runtime.Remoting.MetadataServices
Contains the classes used by the Soapsuds.exe command line tool and the user code to convert metadata to and from XML schema for the remoting infrastructure.
System.Runtime.Remoting.Proxies
Contains classes that control and provide functionality for proxies. A proxy is a local object that is an image of a remote object. Proxies enable clients to access objects across remoting boundaries.
System.Runtime.Remoting.Services
Contains service classes that provide functionality to the .NET Framework.
System.Runtime.Serialization
Contains classes that can be used for serializing and deserializing objects. Serialization is the process of converting an object or a graph of objects into a linear sequence of bytes for either storage or transmission to another location. Deserialization is the process of taking in stored information and recreating objects from it.
System.Runtime.Serialization.Formatters
Provides common enumerations, interfaces, and classes that are used by serialization formatters.
System.Runtime.Serialization.Formatters.Binary
Contains the BinaryFormatter class, which can be used to serialize and deserialize objects in binary format.
System.Runtime.Serialization.Formatters.Soap
Contains the SoapFormatter class, which can be used to serialize and deserialize objects in the SOAP format.
System.Security
Provides the underlying structure of the .NET Framework security system, including base classes for permissions.
System.Security.AccessControl
 
System.Security.Cryptography
Provides cryptographic services, including secure encoding and decoding of data, as well as many other operations, such as hashing, random number generation, and message authentication.
System.Security.Cryptography.Pkcs
Provides programming elements for Public Key Cryptography Standards (PKCS), including methods for signing data, exchanging keys, requesting certificates, public key encryption and decryption, and other security functions.
System.Security.Cryptography.X509Certificates
Contains the common language runtime implementation of the Authenticode X.509 v.3 certificate. This certificate is signed with a private key that uniquely and positively identifies the holder of the certificate.
System.Security.Cryptography.Xml
Contains classes to support the creation and validation of XML digital signatures. The classes in this namespace implement the World Wide Web Consortium Recommendation, "XML-Signature Syntax and Processing", described at https://www.w3.org/TR/xmldsig-core/.
System.Security.Permissions
Defines classes that control access to operations and resources based on policy.
System.Security.Policy
Contains code groups, membership conditions, and evidence. These three types of classes are used to create the rules applied by the .NET Framework security policy system. Evidence classes are the input to security policy and membership conditions are the switches; together these create policy statements and determine the granted permission set. Policy levels and code groups are the structure of the policy hierarchy. Code groups are the encapsulation of a rule and are arranged hierarchically in a policy level.
System.Security.Principal
Defines a principal object that represents the security context under which code is running.
System.ServiceProcess
Provides classes that allow you to implement, install, and control Windows service applications. Services are long-running executables that run without a user interface. Implementing a service involves inheriting from the ServiceBase class and defining specific behavior to process when start, stop, pause, and continue commands are passed in, as well as custom behavior and actions to take when the system shuts down.
System.Text
Contains classes representing ASCII, Unicode, UTF-7, and UTF-8 character encodings; abstract base classes for converting blocks of characters to and from blocks of bytes; and a helper class that manipulates and formats String objects without creating intermediate instances of String.
System.Text.RegularExpressions
Contains classes that provide access to the .NET Framework regular expression engine. The namespace provides regular expression functionality that can be used from any platform or language that runs within the Microsoft .NET Framework.
System.Threading
Provides classes and interfaces that enable multithreaded programming. In addition to classes for synchronizing thread activities and access to data (Mutex, Monitor, Interlocked, AutoResetEvent, and so on), this namespace includes a ThreadPool class that allows you to use a pool of system-supplied threads, and a Timer class that executes callback methods on thread pool threads.
System.Timers
Provides the Timer component, which allows you to raise an event on a specified interval.
System.Transactions
Contains classes that allow your code to participate in transactions. The classes support transactions with multiple, distributed participants, multiple phase notifications, and durable enlistments..
System.Transactions.Configuration
Contains classes that describe configuration options used by System.Transactions classes
System.Web
Supplies classes and interfaces that enable browser-server communication. This namespace includes the HttpRequest class, which provides extensive information about the current HTTP request, the HttpResponse class, which manages HTTP output to the client, and the HttpServerUtility class, which provides access to server-side utilities and processes. System.Web also includes classes for cookie manipulation, file transfer, exception information, and output cache control.
System.Web.Caching
Provides classes for caching frequently used data on the server. This includes the Cache class, a dictionary that allows you to store arbitrary data objects, such as hash tables and data sets. It also provides expiration functionality for those objects, and methods that allow you to add and remove the objects. You can also add the objects with a dependency upon other files or cache entries, and perform a callback to notify your application when an object is removed from the cache.
System.Web.Compilation
Contains classes for generating and compiling custom file types within the ASP.NET build environment.
System.Web.Configuration
Contains classes that are used to set up ASP.NET configuration.
System.Web.Handlers
Contains HTTP handler classes that process HTTP requests to a Web server.
System.Web.Hosting
Provides the functionality for hosting ASP.NET applications from managed applications outside of Microsoft Internet Information Services (IIS).
System.Web.Mail
The classes in this namespace are obsolete; use the classes in the System.Net.Mail namespace. Contains classes that enable you to construct and send messages using the CDOSYS message component. The mail message is delivered through either the SMTP mail service built into Microsoft Windows 2000 or through an arbitrary SMTP server. The classes in this namespace can be used either from ASP.NET or from any managed application.
System.Web.Management
Contains classes and interfaces for managing and monitoring the health of Web applications.
System.Web.Mobile
Contains the core capabilities, including authentication and error-handling, required for building ASP.NET mobile Web applications.
System.Web.Profile
Contains classes that are used to implement the ASP.NET user profile in Web server applications.
System.Web.RegularExpressions
Provides regular expressions used to parse ASP.NET files. All members of the System.Web.RegularExpressions namespace are descendants of the Regex class.
System.Web.Security
Contains classes that are used to implement ASP.NET security in Web server applications.
System.Web.Services
Consists of the classes that enable you to create XML Web services using ASP.NET and XML Web service clients. XML Web services are applications that provide the ability to exchange messages in a loosely coupled environment using standard protocols such as HTTP, XML, XSD, SOAP, and WSDL. XML Web services enable the building of modular applications within and across companies in heterogeneous environments making them interoperable with a broad variety of implementations, platforms and devices. The SOAP-based XML messages of these applications can have well-defined (structured and typed), or loosely defined parts (using arbitrary XML). The ability of the messages to evolve over time without breaking the protocol is fundamental to the flexibility and robustness of XML Web services as a building block for the future of the Web.
System.Web.Services.Configuration
Consists of the classes that configure how XML Web services created using ASP.NET run.
System.Web.Services.Description
Consists of the classes that enable you to publicly describe an XML Web service by using the Web Services Description Language (WSDL). Each class in this namespace corresponds to a specific element in the WSDL specification, and the class hierarchy corresponds to the XML structure of a valid WSDL document.
System.Web.Services.Discovery
Consists of the classes that allow XML Web service clients to locate the available XML Web services on a Web server through a process called XML Web services Discovery.
System.Web.Services.Protocols
Consists of the classes that define the protocols used to transmit data across the wire during the communication between XML Web service clients and XML Web services created using ASP.NET.
System.Web.SessionState
Supplies classes and interfaces that enable storage of data specific to a single client within a Web application on the server. The session state data is used to give the client the appearance of a persistent connection with the application. State information can be stored within local process memory or, for Web farm configurations, out-of-process using either the ASP.NET State Service or a SQL Server database.
System.Web.UI
Provides classes and interfaces that allow you to create controls and pages that will appear in your Web applications as user interface on a Web page. This namespace includes the Control class, which provides all controls, whether HTML, Web, or User controls, with a common set of functionality. It also includes the Page control, which is generated automatically whenever a request is made for a page in your Web application. Also provided are classes which provide the Web Forms Server Controls data binding functionality, the ability to save the view state of a given control or page, as well as parsing functionality for both programmable and literal controls.
System.Web.UI.Adapters
Contains the base classes for control adapters and page adapters, which you can use to override lifecycle states of pages and controls to modify their default markup or behavior for new markup standards or for specific browsers.
System.Web.UI.Design
Contains classes that can be used to extend design-time support for Web Forms and Web server controls.
System.Web.UI.Design.MobileControls
Obsolete. Contains classes that provide design-time support for the classes in the System.Web.UI.MobileControls namespace. The classes in this namespace are obsolete; use the classes in System.Web.UI.Design.WebControls instead.
System.Web.UI.Design.MobileControls.Converters
Contains classes that provide design-time support for data type converters in mobile controls.
System.Web.UI.Design.WebControls
Contains classes that can be used to extend design-time support for Web server controls.
System.Web.UI.Design.WebControls.WebParts
Contains classes that provide design-time support for controls derived from classes in the System.Web.UI.WebControls.WebParts namespace.
System.Web.UI.HtmlControls
Consists of a collection of classes that allow you to create HTML server controls on a Web Forms page. HTML server controls run on the server and map directly to standard HTML tags supported by most browsers. This allows you to programmatically control the HTML elements on a Web Forms page.
System.Web.UI.MobileControls
Obsolete. Contains a set of ASP.NET server controls that can intelligently render your application for different mobile devices. The classes in this namespace are obsolete; use the controls in System.Web.UI.WebControls instead.
System.Web.UI.MobileControls.Adapters
Contains classes you can use to override lifecycle stages of a mobile control to modify its default HTML, CHTML, or WML markup or behavior for new markup standards or for specific browsers and mobile devices.
System.Web.UI.MobileControls.Adapters.XhtmlAdapters
Contains classes you can use to override lifecycle stages of a mobile control to modify its default XHTML markup or behavior for new markup standards or for specific browsers and mobile devices.
System.Web.UI.WebControls
Contains classes that allow you to create Web server controls on a Web page. Web server controls run on the server and include form controls such as buttons and text boxes. They also include special purpose controls such as a calendar. Because Web server controls run on the server, you can programmatically control these elements. Web server controls are more abstract than HTML server controls. Their object model does not necessarily reflect HTML syntax.
System.Web.UI.WebControls.Adapters
Contains classes you can use to override lifecycle stages of a Web control to modify a control's default markup or behavior for new markup standards or for specific browsers.
System.Web.UI.WebControls.WebParts
Contains an integrated set of classes and interfaces for creating Web pages whose appearance and behavior can be modified (personalized) by end users. The user-defined settings for each page are saved for future browser sessions.
System.Web.Util
Contains classes that enable callback methods to be run under the scope of a transaction and that enable work to be posted to separate threads.
System.Windows.Forms
Contains classes for creating Windows-based applications that take full advantage of the rich user interface features available in the Microsoft Windows operating system.
System.Windows.Forms.ComponentModel.Com2Interop
Contains helper classes that Visual Studio uses to display property pages while in design mode.
System.Windows.Forms.Design
Contains classes that support design-time configuration and behavior for Windows Forms components. These classes consist of: Designer classes that provide support for Windows Forms components, a set of design time services, UITypeEditor classes for configuring certain types of properties, and classes for importing ActiveX controls.
System.Windows.Forms.Design.Behavior
Contains classes for creating custom user interface behavior for components at design time.
System.Windows.Forms.Layout
Contains classes that support design-time and run-time layout behaviors.
System.Windows.Forms.PropertyGridInternal
Provides internal support for the PropertyGrid control. The classes in this namespace support the .NET Framework infrastructure and are not intended to be used directly from your code
System.Xml
Provides standards-based support for processing XML.
System.Xml.Schema
Contém as classes XML que fornecem suporte baseado em padrões para esquemas de linguagem de definição de esquemas XML (XSD).
System.Xml.Serialization
Contém classes que são usadas para serializar objetos em documentos ou fluxos no formato XML.
System.Xml.XPath
Contém o analisador XPath e o mecanismo de avaliação. Ele suporta a Recomendação W3C XML Path Language (XPath) Versão 1.0 ( www.w3.org/TR/xpath ).
System.Xml.Xsl
Fornece suporte para transformações Extensible Stylesheet Transformation (XSLT). Ele suporta a Recomendação W3C XSL Transformations (XSLT) Versão 1.0 ( www.w3.org/TR/xslt ).
System.Xml.Xsl.Runtime
Fornece suporte interno para as classes no namespace System.Xml.Xsl . As classes neste namespace suportam a infraestrutura do .NET Framework e não devem ser usadas diretamente do seu código.
Veja também
Conceitos
Referência geral do .NET Framework
Visão geral da biblioteca de classes do .NET Framework
Inglês (Estados Unidos)
Suas escolhas de privacidade
Tema
Versões anteriores
Blogue
Contribuir
Privacidade
Termos de Uso
Marcas registradas
© Microsoft 2025


