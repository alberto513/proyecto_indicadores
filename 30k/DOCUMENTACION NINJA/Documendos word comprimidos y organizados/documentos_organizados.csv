Filename,Text
Converting Strategies to Indicators Guide.docx,"The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
permalink
        Signature Changes Overview
permalink
        Name Changes Overview
permalink
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
Definition
A custom TypeConverter class handling the designed behavior of an indicator's property descriptor collection.  Use this as a base class for any custom TypeConverter you are applying to an indicator class.
 
 
 
Relevant base methods
 
 
Syntax
public class IndicatorBaseConverter : TypeConverter
 
 
 
 
 
Examples
Welcome to the NinjaTrader 8 Beta Release!
We are very excited to openly release NinjaTrader 8 Beta to our general user base. The purpose of this program is to have you start testing the platform to in order to solicit feedback in the form of bug reports and constructive criticism. The beta process is a critical step in the software development cycle during which time we jointly work towards improving quality and performance with a goal of reaching a stable product ready for general release.
 
This release marks the introduction of our next generation trading platform. NinjaTrader 8 adds over 500+ new features and functionality on top of a re-designed architecture built to take advantage of new development practices and modern technologies. This is our most ambitious project to date and we are excited to get it in the hands of our customers.
 
 
 
Bug reports and providing feedback
Support will be driven via our NinjaTrader Support Forum NinjaTrader 8 section. When running into unexpected behavior please create a bug report in the NinjaTrader support forum's bug report section. Bug reports will be reviewed by our support and development staff inside of a 48 hour period. If you are unable to post to the bug section of the forum please contact platformsupport@ninjatrader.com.  
        Installation Guide
permalink
        Expectations during beta
permalink
        NinjaScript
permalink
Welcome to the NinjaTrader 8 Beta Release!
We are very excited to openly release NinjaTrader 8 Beta to our general user base. The purpose of this program is to have you start testing the platform to in order to solicit feedback in the form of bug reports and constructive criticism. The beta process is a critical step in the software development cycle during which time we jointly work towards improving quality and performance with a goal of reaching a stable product ready for general release.
 
This release marks the introduction of our next generation trading platform. NinjaTrader 8 adds over 500+ new features and functionality on top of a re-designed architecture built to take advantage of new development practices and modern technologies. This is our most ambitious project to date and we are excited to get it in the hands of our customers.
 
 
 
Bug reports and providing feedback
Support will be driven via our NinjaTrader Support Forum NinjaTrader 8 section. When running into unexpected behavior please create a bug report in the NinjaTrader support forum's bug report section. Bug reports will be reviewed by our support and development staff inside of a 48 hour period. If you are unable to post to the bug section of the forum please contact platformsupport@ninjatrader.com.  
        Installation Guide
permalink
        Expectations during beta
permalink
        NinjaScript
permalink

"
Creating Custom Indicators Template.docx,"NinjaTrader makes it easy to distribute complete packages for your clients. Not only can you distribute your indicators and strategies, but you can also seamlessly deploy your own custom assemblies, native DLLs, chart templates, and Market Analyzer templates to your clients.
 
 
Creating the distribution package
To create a distribution package, please follow the steps shown here for creating a Export file containing your NinjaScript indicators and/or strategies.
 
It is strongly recommended that you export your scripts as an assembly and use SecureTeam's Agile.NET. Only this process will provide you with the highest level of security possible in order to protect your intellectual property. For more information on using SecureTeam's Agile.NET please see the Protection/DLL Security section.
 
After you finish using the Export utility you will find the distribution package as a .zip file located in My Documents\NinjaTrader 8\bin\Custom\ExportNinjaScript. If you only wanted to distribute your NinjaScript files then providing your customers with this .zip and having them go through the Import process would install it on their machines. If you wish to add more custom files to your distribution package, please see the sections below.
 
Critical: It is important to let your customers know that NinjaTrader 8 indicators and strategies are NOT necessarily compatible with NinjaTrader Version 7.
        Adding custom assemblies or native DLLs
permalink
        Adding templates
permalink
        Adding workspaces
permalink
        Adding custom resource files
permalink
 
In order to achieve custom rendering for various chart related objects, a Brush is used to ""paint"" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
permalink
        Understanding custom brushes
permalink
        Using brushes defined on the user interface
permalink
        Using advanced brush types (SharpDX)
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
Release Date
July 11, 2016
 
Code Breaking Changes
Compile Errors
•The NinjaScript Strategy ""AccountSize"" concept was removed due to limited functionality.  This change would also impact strategies which were coded to use SetOrderQuantity.ByAccountSize.  Please use your own variables to set quantities by account size. Tip:  NinjaTrader 8 can read real-world account values for live trading purposes through the Account class, e.g., Account.Get(AccountItem.CashValue, Currency.UsDollar) provides a method for returning a double value representing the current cash value of the account.
 
Implementation changes
•The concept used to force plot series objects through ForcePlotsMaximumBarsLookBackInfinite was disabled and tagged as obsolete.  You should set any indicator/strategy plots to MaximumBarsLookBack.Infinite during its construction.
•It is recommended that any strategies generated with the 'Strategy Builder' tool via Control Center > New > Strategy Builder be removed and recreated after installing B12. If you had invested significant effort in a Strategy Builder generated strategy in B11 which you would like to continue to use, please contact us platformsupport@ninjatrader.com
 
Notes
NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•""UI"" instances representing its default properties on various user interfaces
•The ""configured"" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select ""Indicator""
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses ""Apply"" or ""OK""
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of ""Available"" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of ""Available"" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the ""Properties"" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd ""configured"" instance you are concerned with developing, but you should also be aware of the ""UI"" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or ""Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
Definition
Adds a Bars object for developing a multi-series (multi-time frame or multi-instrument) NinjaScript.
 
Related Methods and Properties
 
 
Syntax
The following syntax will add another Bars object for the primary instrument of the script.
AddDataSeries(BarsPeriod barsPeriod)
AddDataSeries(BarsPeriodType periodType, int period)
 
The following syntax allows you to add another Bars object for a different instrument to the script:
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period)
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period, MarketDataType marketDataType)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, int barsToLoad, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName) //only for R15 and higher
 
 
 
Parameters
 
 
 
 
Examples
 
 

"
Draw Object Methods Documentation.docx,"The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
permalink
        Signature Changes Overview
permalink
        Name Changes Overview
permalink
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
        Signature Changes Overview
        Name Changes Overview
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
        Signature Changes Overview
        Name Changes Overview
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink

"
Drawing Methods Reference.docx,"The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
permalink
        Signature Changes Overview
permalink
        Name Changes Overview
permalink
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
Understanding the SharpDX .NET Library
NinjaTrader Chart objects (such as Indicators, Strategies, DrawingTools, ChartStyles) implement an OnRender() method aimed to render custom lines, shapes, and text to the chart.  To achieve the level of performance required to keep up with market data events, NinjaTrader uses a 3rd-party open-source .NET library named SharpDX.  This 3rd party library provides a C# wrapper for the powerful Microsoft DirectX API used for graphics processing and known for its hardware-accelerated performance, including 2D vector and text layout graphics used for NinjaTrader Chart Rendering.  The SharpDX/DirectX library is extensive, although NinjaTrader only uses a handful of namespaces and classes, which are documented as a guide in this reference.  In addition to this educational resource, we have also compiled a more focused collection of SharpDX SDK Reference resources to help you learn the SharpDX concepts used in NinjaTrader Chart Rendering.
 
 
There are three main SharpDX namespaces you need to be familiar with:
 
 
The rest of this page will help you navigate the fundamental concepts needed to achieve custom rendering to your charts.
        SharpDX Vectors and Charting Coordinates
permalink
        SharpDX Brush Resources
permalink
        SharpDX RenderTarget
permalink
        SharpDX Lines and Shapes
permalink
        SharpDX Text Rendering
permalink
        SharpDX Stroke Style
permalink
         Best Practices for SharpDX Resources
permalink
Release Date
August 31st, 2016
 
This release marks our first NinjaTrader 8 Release Candidate.  Since the very first NinjaTrader 8 beta version, we have resolved over 4500 bugs thanks to the ongoing efforts of our beta community, and we feel confident we are closer than ever to a production NinjaTrader 8 release.  If you have installed a NinjaTrader 8 beta version and reported feedback to our support team - thank you!
 
As this is a release candidate, NinjaTrader 8.0.0.13 is still considered a beta product and we will continue to focus on product quality.  Please continue to report any issues you may encounter to our support staff.   We will monitor the status of this release to determine when we will announce and launch the production release of NinjaTrader 8.
 
 
 
Code Breaking Changes
Compile Errors
•The Stroke object .Dispose() method was removed due to technical redundancy.  To remove memory resources from any stroke objects, simply set the stroke to null.
•Removed property Bars.IsTimebased -> please use Bars.BarsType.IsTimeBased instead
•Account.Accounts was renamed to Account.All
 
Implementation changes
•The common signature ""isInclude60"" used in various SessionIterator methods was renamed to ""includesEndTimeStamp"" to be more specific
•Category display order values of standard NinjaTrader Property Grid Categories were updated to be more consistent application wide.  These changes could impact any customization you were doing using the CategoryOrderAttribute, however, the documentation was also updated to reflect the implementation more accurately and will allow you to use this attribute reliably.
•To assist with transitioning historical order objects to real-time order references, please use the new GetRealtimeOrder() method.
 
Notes
Definition
Represents an interface that exposes information regarding a Text IDrawingTool.
 
Methods and Properties
 
 
 
Example
Definition
Represents an interface that exposes information regarding a Text Fixed IDrawingTool.
 
Methods and Properties
 
 
 
Example
 
 
 
 
 
Definition
Represents an object that can receive drawing commands.
(See also unmanaged API documentation)
 
Syntax
class RenderTarget
 
 
 
Methods and Properties
Rendering methods and properties can be useful when carrying out custom drawing tasks for chart objects. Event handlers such as OnCalculateMinMax() and OnRender() allow you to override behavior at key points in the rendering process.
 
 
 
Methods and Properties
In order to achieve custom rendering for various chart related objects, a Brush is used to ""paint"" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
permalink
        Understanding custom brushes
permalink
        Using brushes defined on the user interface
permalink
        Using advanced brush types (SharpDX)
permalink

"
Historical Values Storage Methods.docx,"Once market replay data or historical tick data is available by either recording or downloading (See the ""Set Up"" page of the Help Guide), it can be replayed in all NinjaTrader windows.
        How to connect to Market Replay data
permalink
        How to work with replay data
permalink
        Understanding how the Playback works
permalink
Historical data can be imported from a text file with a "".txt"" extension within the Loaded section of the Historical Data Window. Several formats and data types are supported and NinjaTrader can optionally build 'Minute' bars from tick data as well as 'Day' bars from tick or minute data.
 
        Understanding import options
permalink
        Understanding import file and data formats
permalink
        How to import historical data from a text file
permalink
        Formatting data from Tick Data, LLC
permalink
Historical data saved in NinjaTrader can be edited via the Edit section of the Historical Data Window.
        How to edit historical data
permalink
        How to delete historical data
permalink
Historical data can be downloaded from the data provider via the Download section.
 

"
Historical Values Storage MethodsBack to Index.docx,"When creating Indicators or Strategies you may find that you need to store values in a way that is similar to the way price data is stored in NinjaTrader.
 
Series<T> objects are useful for storing various types of values.
 
Since they are linked to your historical bars object, you can store and link a value to each bar. This allows you the flexibility of accessing the values at any point in the future for further calculations or plotting.
 
 
Key concepts in this example
•Creating objects that store data
•Storing and retrieving values from these objects
 
Important related documentation
•Series<T>
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
SampleCustomSeries_NT8.zip
// 
// Copyright (C) 2016, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA);
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				if (CurrentBar == 0)
					Value[0] = Input[0];
				else
				{
					double last = Value[1] * Math.Min(CurrentBar, Period);

					if (CurrentBar >= Period)
						Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);
					else
						Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));
				}
			}
			else
			{
				if (IsFirstTickOfBar)
					priorSum = sum;

				sum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
				Value[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
     public class SampleCustomSeries : Indicator
     {		
		// Defines the Series object
		private Series<double> myDoubleSeries;

        protected override void OnStateChange()
        {
			if (State == State.SetDefaults)
			{
				// Adds a plot to our NinjaScript Indicator
	            AddPlot(new Stroke(Brushes.Orange, 1), PlotStyle.Bar, ""Average Range"");
				
				Period					= 5;
				Name					= ""Sample custom series"";
	            Calculate				= Calculate.OnBarClose;
	            IsOverlay				= false;
			}
			
			else if (State == State.DataLoaded)
			{
				// Create a new Series object and assign it to the variable myDoubleSeries declared in the ‘Variables’ region above
				myDoubleSeries = new Series<double>(this);
			}
        }

        protected override void OnBarUpdate()
        {
			/* To set values to our Series object we use the [] method. Here we are setting the DataSeries
			object for the current bar to take on the absolute value of the difference between the current bar's
			open and close. */
			
			myDoubleSeries[0] = Math.Abs(Close[0] - Open[0]);
			
			/* Take note that the method for setting the value to be plotted is the same as for setting a value
			to a DataSeries object. The difference here is that the custom DataSeries object is not plotted while
			this ""Average Range"" is plotted.
			
			In this case we are plotting the Simple Moving Average of the intermediate calculation step stored in our
			Series object. */
			
            Value[0] = SMA(myDoubleSeries, Period)[0];
        }

        #region Properties
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }

		#endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleCustomSeries[] cacheSampleCustomSeries;
		public SampleCustomSeries SampleCustomSeries(int period)
		{
			return SampleCustomSeries(Input, period);
		}

		public SampleCustomSeries SampleCustomSeries(ISeries<double> input, int period)
		{
			if (cacheSampleCustomSeries != null)
				for (int idx = 0; idx < cacheSampleCustomSeries.Length; idx++)
					if (cacheSampleCustomSeries[idx] != null && cacheSampleCustomSeries[idx].Period == period && cacheSampleCustomSeries[idx].EqualsInput(input))
						return cacheSampleCustomSeries[idx];
			return CacheIndicator<SampleCustomSeries>(new SampleCustomSeries(){ Period = period }, input, ref cacheSampleCustomSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

#endregion
Definition
Holds an array of ISeries<double> objects holding hold the indicator's underlying calculated values. ISeries<double> values are added to this array when calling the AddPlot() method. In case of a MultiSeries indicator synched to the primary series.
 
Property Value
A collection of ISeries<double> objects.
 
Syntax
Values[int index]
 
 
Examples
Definition
The Values array holds an 5 values corresponding to each Cbi.PerformanceUnit. NinjaTrader will then access the Values property to display the calculated performance metric in the UI. You can also access these performance metrics for a NinjaScript strategy.
 
Syntax
public double[] Values
{ get; private set; }
 
Calculating Values OnAddTrade Example
 
Calculating Values On Demand Example
There may be cases where you want to have your indicator calculate non-plotted values that you will want to access when using this indicator inside of another indicator or strategy.
 
Key concepts in this example
•Creating exposed BoolSeries objects
•Storing and retrieving values from BoolSeries objects
 
Important related documentation
•Series<T>
We suggest using an available class that implements the Series interface.
•Price Series
•Time Series
•Volume Series
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
SampleBoolSeries_NT8.zip
// 
// Copyright (C) 2016, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The MACD (Moving Average Convergence/Divergence) is a trend following momentum indicator 
	/// that shows the relationship between two moving averages of prices.
	/// </summary>
	public class MACD : Indicator
	{
		private	Series<double>		fastEma;
		private	Series<double>		slowEma;
		private double				constant1;
		private double				constant2;
		private double				constant3;
		private double				constant4;
		private double				constant5;
		private double				constant6;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMACD;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMACD;
				Fast						= 12;
				IsSuspendedWhileInactive	= true;
				Slow						= 26;
				Smooth						= 9;

				AddPlot(Brushes.Green,									NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMACD);
				AddPlot(Brushes.DarkViolet,								NinjaTrader.Custom.Resource.NinjaScriptIndicatorAvg);
				AddPlot(new Stroke(Brushes.Navy, 2),	PlotStyle.Bar,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorDiff);
				AddLine(Brushes.DarkGray,				0,				NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.Configure)
			{
				constant1	= 2.0 / (1 + Fast);
				constant2	= (1 - (2.0 / (1 + Fast)));
				constant3	= 2.0 / (1 + Slow);
				constant4	= (1 - (2.0 / (1 + Slow)));
				constant5	= 2.0 / (1 + Smooth);
				constant6	= (1 - (2.0 / (1 + Smooth)));
				fastEma		= new Series<double>(this);
				slowEma		= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			double input0	= Input[0];

			if (CurrentBar == 0)
			{	
				fastEma[0]		= input0;
				slowEma[0]		= input0;
				Value[0]		= 0;
				Avg[0]			= 0;
				Diff[0]			= 0;
			}
			else
			{
				double fastEma0	= constant1 * input0 + constant2 * fastEma[1];
				double slowEma0	= constant3 * input0 + constant4 * slowEma[1];
				double macd		= fastEma0 - slowEma0;
				double macdAvg	= constant5 * macd + constant6 * Avg[1];

				fastEma[0]		= fastEma0;
				slowEma[0]		= slowEma0;
				Value[0]		= macd;
				Avg[0]			= macdAvg;
				Diff[0]			= macd - macdAvg;
			}
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Avg
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Default
		{
			get { return Values[0]; }
		}
		
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Diff
		{
			get { return Values[2]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Fast"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Slow"", GroupName = ""NinjaScriptParameters"", Order = 1)]
		public int Slow
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Smooth"", GroupName = ""NinjaScriptParameters"", Order = 2)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MACD[] cacheMACD;
		public MACD MACD(int fast, int slow, int smooth)
		{
			return MACD(Input, fast, slow, smooth);
		}

		public MACD MACD(ISeries<double> input, int fast, int slow, int smooth)
		{
			if (cacheMACD != null)
				for (int idx = 0; idx < cacheMACD.Length; idx++)
					if (cacheMACD[idx] != null && cacheMACD[idx].Fast == fast && cacheMACD[idx].Slow == slow && cacheMACD[idx].Smooth == smooth && cacheMACD[idx].EqualsInput(input))
						return cacheMACD[idx];
			return CacheIndicator<MACD>(new MACD(){ Fast = fast, Slow = slow, Smooth = smooth }, input, ref cacheMACD);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MACD MACD(int fast, int slow, int smooth)
		{
			return indicator.MACD(Input, fast, slow, smooth);
		}

		public Indicators.MACD MACD(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.MACD(input, fast, slow, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MACD MACD(int fast, int slow, int smooth)
		{
			return indicator.MACD(Input, fast, slow, smooth);
		}

		public Indicators.MACD MACD(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.MACD(input, fast, slow, smooth);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
    public class SampleBoolSeries : Indicator
    {
		/* We declare two Series<bool> objects here. We will expose these objects with the use of 
		public properties later. When we want to expose an object we should always use the associated
		ISeries class type with it. This will ensure that the value accessed is kept up-to-date. */
		private Series<bool> bearIndication;
		private Series<bool> bullIndication;
		
		/* If you happen to have an object that does not have an ISeries class that can be used, you
		will need to manually ensure its values are kept up-to-date. This process will be done in the
		""Properties"" region of the code. */
		private double exposedVariable;

        protected override void OnStateChange()
        {
			if(State == State.SetDefaults)
			{
				Name					= ""Sample bool series"";
	            Calculate				= Calculate.OnBarClose;
	            IsOverlay				= true;
			}
			
			else if(State == State.Configure)
			{
				/* ""this"" syncs the Series<bool> to the historical bar object of the indicator. It will generate
				one bool value for every price bar. */
				bearIndication			= new Series<bool>(this);
				bullIndication			= new Series<bool>(this);
			}
        }

        protected override void OnBarUpdate()
        {
			// MACD Crossover: Fast Line cross above Slow Line
			if (CrossAbove(MACD(12, 26, 9), MACD(12, 26, 9).Avg, 1))
			{
				// Paint the current price bar lime to draw our attention to it
				BarBrushes[0]		= Brushes.Lime;
				
				/* This crossover condition is considered bullish so we set the ""bullIndication"" Series<bool> object to true.
				We also set the ""bearIndication"" object to false so it does not take on a null value. */
				bullIndication[0]	= (true);
				bearIndication[0]	= (false);
			}
			
			// MACD Crossover: Fast Line cross below Slow Line
			else if (CrossBelow(MACD(12, 26, 9), MACD(12, 26, 9).Avg, 1))
			{
				// Paint the current price bar magenta to draw our attention to it
				BarBrushes[0]		= Brushes.Magenta;
				
				/* This crossover condition is considered bearish so we set the ""bearIndication"" Series<bool> object to true.
				We also set the ""bullIndication"" object to false so it does not take on a null value. */
				bullIndication[0]	= (false);
				bearIndication[0]	= (true);
			}
			
			// MACD Crossover: No cross
			else
			{
				/* Since no crosses occured we are not receiving any bullish or bearish signals so we
				set our Series<bool> objects both to false. */
				bullIndication[0] = (false);
				bearIndication[0] = (false);
			}
			
			// We set our variable to the close value.
			exposedVariable = Close[0];
        }

		// Important code segment in the Properties section. Please expand to view.
        #region Properties
		// Creating public properties that access our internal Series<bool> allows external access to this indicator's Series<bool>
		[Browsable(false)]
		[XmlIgnore]
        public Series<bool> BearIndication
        {
            get { return bearIndication; }	// Allows our public BearIndication Series<bool> to access and expose our interal bearIndication Series<bool>
        }
		
		[Browsable(false)]
		[XmlIgnore]		
        public Series<bool>  BullIndication
        {
            get { return bullIndication; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }

        public double ExposedVariable
        {
			// We need to call the Update() method to ensure our exposed variable is in up-to-date.
            get { Update(); return exposedVariable; }
        }
        #endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleBoolSeries[] cacheSampleBoolSeries;
		public SampleBoolSeries SampleBoolSeries()
		{
			return SampleBoolSeries(Input);
		}

		public SampleBoolSeries SampleBoolSeries(ISeries<double> input)
		{
			if (cacheSampleBoolSeries != null)
				for (int idx = 0; idx < cacheSampleBoolSeries.Length; idx++)
					if (cacheSampleBoolSeries[idx] != null &&  cacheSampleBoolSeries[idx].EqualsInput(input))
						return cacheSampleBoolSeries[idx];
			return CacheIndicator<SampleBoolSeries>(new SampleBoolSeries(), input, ref cacheSampleBoolSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleBoolSeries SampleBoolSeries()
		{
			return indicator.SampleBoolSeries(Input);
		}

		public Indicators.SampleBoolSeries SampleBoolSeries(ISeries<double> input )
		{
			return indicator.SampleBoolSeries(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleBoolSeries SampleBoolSeries()
		{
			return indicator.SampleBoolSeries(Input);
		}

		public Indicators.SampleBoolSeries SampleBoolSeries(ISeries<double> input )
		{
			return indicator.SampleBoolSeries(input);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Strategies in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Strategies
{
	public class SampleBoolSeriesStrategy : Strategy
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= @""Sample strategy demonstrating how to call an exposed BoolSeries object"";
				Name						= ""SampleBoolSeriesStrategy"";
				Calculate					= Calculate.OnBarClose;
				EntriesPerDirection			= 1;
				EntryHandling				= EntryHandling.AllEntries;
				IsExitOnSessionCloseStrategy= true;
				ExitOnSessionCloseSeconds	= 30;
				IsFillLimitOnTouch			= false;
				MaximumBarsLookBack			= MaximumBarsLookBack.TwoHundredFiftySix;
				OrderFillResolution			= OrderFillResolution.Standard;
				Slippage					= 0;
				StartBehavior				= StartBehavior.WaitUntilFlat;
				TimeInForce					= TimeInForce.Gtc;
				TraceOrders					= false;
				RealtimeErrorHandling		= RealtimeErrorHandling.StopCancelClose;
				StopTargetHandling			= StopTargetHandling.PerEntryExecution;
				BarsRequiredToTrade			= 20;
			}
			else if (State == State.Configure)
			{
				AddChartIndicator(MACD(12,26,9));
				AddChartIndicator(SampleBoolSeries());
			}
		}

		protected override void OnBarUpdate()
		{
			/* When our indicator gives us a bull signal we enter long. Notice that we are accessing the
			public BoolSeries we made in the indicator. */
			if (SampleBoolSeries().BullIndication[0])
				EnterLong();
			
			// When our indicator gives us a bear signal we enter short
			if (SampleBoolSeries().BearIndication[0])
				EnterShort();
			
			/* NOTE: This strategy is based on reversals thus there are no explicit exit orders. When you
			are long you will be closed and reversed into a short when the bear signal is received. The vice
			versa is true if you are short. */
			
			/* Print our exposed variable. Because we manually kept it up-to-date it will print values that
			match the bars object. */
			Print(SampleBoolSeries().ExposedVariable);
		}
	}
}
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Definition
Represents historical data as an ISeries<double> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Definition
Represents historical time stamps as an ISeries<DateTime> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<DateTime>
 
 
Multi-Time Frame ISeries<DateTime>
 
Definition
Represents historical volume data as ISeries<double> interface which can be used for custom NinjaScript object calculations
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In NinjaScript we are able to access the bars we want through proper use of the bar's indexing.
 
The bar's indexing is setup in a reverse chronological order. This means ""0"" refers to the most recent bar, ""1"" refers to the previous bar, ""2"" refers to the bar before that one, etc.
 
For example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:
 
Now that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are CurrentBar and BarsSinceNewTradingDay.
 
CurrentBar
CurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.
 
For example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:
 
 
BarsSinceNewTradingDay
BarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.
 
For example, if you wanted to find the open of the current session you could do this:
 
The example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.
 
 
Other Properties and Methods
There are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:
BarsSinceEntryExecution()
BarsSinceExitExecution()
GetBar()
GetDayBar()
HighestBar()
LowestBar()
LRO()
MRO()
Definition
Returns the number of bars that have elapsed since the last specified entry.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous entry does not exist.
 
Syntax
BarsSinceEntryExecution()
BarsSinceEntryExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceEntryExecution(int barsInProgressIndex, string signalName, int entryExecutionsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars that have elapsed since the last specified exit.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous exit does not exist.
 
Syntax
BarsSinceExitExecution()
BarsSinceExitExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceExitExecution(int barsInProgressIndex, string signalName, int exitExecutionsAgo)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Returns the first bar that matches the time stamp of the ""time"" parameter provided.  
 
 
 
Method Return Value
An int value representing an absolute bar index value.
 
Syntax
Bars.GetBar(DateTime time)
 
Parameters
 
 
Examples
Definition
Returns a virtual historical Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.
 
 
 
Method Return Value
A virtual bar object representing the current configured session. Otherwise null if there is insufficient intraday data
 
Syntax
The properties below return double values:
Bars.GetDayBar(int tradingDaysBack).Open
Bars.GetDayBar(int tradingDaysBack).High
Bars.GetDayBar(int tradingDaysBack).Low
Bars.GetDayBar(int tradingDaysBack).Close
 
The property below returns a DateTime structure:
Bars.GetDayBar(int tradingDaysBack).Time
 
The property below returns an int value:
Bars.GetDayBar(int tradingDaysBack).Volume
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the highest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
HighestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the lowest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
LowestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars. The LRO() method start from the furthest bar away and works toward the current bar.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
LRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Most Recent Occurrence(MRO)
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars.  The MRO() method starts from the current bar works away (backward) from it.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
MRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Least Recent Occurrence(LRO)
Normally calculated values are carried over between trading sessions, but sometimes you may want to reset these values to begin a trading session fresh. The technique demonstrated in this reference sample can be useful to do things like resetting counters you may be running or clearing bool flags you may have set.
 
Key concepts in this example
•Resetting a variable at the beginning of a new trading session
•Limiting the number of trades a strategy can make per trading session
 
Important related documentation
•IsFirstBarOfSession
•IsFirstTickOfBar
•EnterLong()
•ExitLong()
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
https://ninjatrader.com/support/helpGuides/nt8/samples/SampleTradeLimiter_NT8.zip
Definition
Indicates if the current bar processing is the first bar updated in a trading session.
 
 
 
Property Value
This property returns true if the bar is the first processed in a session; otherwise, false.  This property is read-only.
 
 
 
Syntax
Bars.IsFirstBarOfSession
 
 
 
Examples
Definition
Indicates if the incoming tick is the first tick of a new bar. This property is only of value in scripts that run tick by tick which is when the Calculate property is set to Calculate.OnEachTick or Calculate.OnPriceChange.
 
 
 
 
 
Property Value
This property returns true if the incoming tick is the first tick of a new bar; otherwise, false.
 
Syntax
IsFirstTickOfBar
 
 
Examples
Definition
Generates a buy market order to enter a long position.
 
Method Return Value
An Order read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the Advanced Order Handling section.
 
Syntax
EnterLong()
EnterLong(string signalName)
EnterLong(int quantity)
EnterLong(int quantity, string signalName)
 
The following method variation is for experienced programmers who fully understand Advanced Order Handling concepts:
EnterLong(int barsInProgressIndex, int quantity, string signalName)
 
 
 
 
Parameters
 
 
Examples
Definition
Generates a sell market order to exit a long position.
 
Method Return Value
An Order read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the Advanced Order Handling section.
 
Syntax
ExitLong()
ExitLong(int quantity)
ExitLong(string fromEntrySignal)
ExitLong(string signalName, string fromEntrySignal)
ExitLong(int quantity, string signalName, string fromEntrySignal)
 
The following method variation is for experienced programmers who fully understand Advanced Order Handling concepts:
 
ExitLong(int barsInProgressIndex, int quantity, string signalName, string fromEntrySignal)
 
 
Parameters
 
 
Examples
 
// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Average Directional Index measures the strength of a prevailing trend as well as whether movement 
	/// exists in the market. The ADX is measured on a scale of 0  100. A low ADX value (generally less than 20) 
	/// can indicate a non-trending market with low volumes whereas a cross above 20 may indicate the start of
	///  a trend (either up or down). If the ADX is over 40 and begins to fall, it can indicate the slowdown of a current trend.
	/// </summary>
	public class ADX : Indicator
	{
		private Series<double>		dmPlus;
		private Series<double>		dmMinus;
		private Series<double>		sumDmPlus;
		private Series<double>		sumDmMinus;
		private Series<double>		sumTr;
		private Series<double>		tr;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionADX;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameADX;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				
				AddPlot(Brushes.Green, ""ADX"");
				AddLine(Brushes.DarkViolet, 25, ""Lower"");
				AddLine(Brushes.YellowGreen, 75, ""Upper"");
			}
			else if (State == State.Configure)
			{
				dmPlus		= new Series<double>(this);
				dmMinus		= new Series<double>(this);
				sumDmPlus	= new Series<double>(this);
				sumDmMinus	= new Series<double>(this);
				sumTr		= new Series<double>(this);
				tr			= new Series<double>(this);
			}
		}
		
		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];
			
			if (CurrentBar == 0)
			{
				tr[0]				= high0 - low0;
				dmPlus[0]			= 0;
				dmMinus[0]			= 0;
				sumTr[0]			= tr[0];
				sumDmPlus[0]		= dmPlus[0];
				sumDmMinus[0]		= dmMinus[0];
				Value[0]			= 50;
			}
			else
			{
				double high1		= High[1];
				double low1			= Low[1];
				double close1		= Close[1];

				tr[0]				= Math.Max(Math.Abs(low0 - close1), Math.Max(high0 - low0, Math.Abs(high0 - close1)));
				dmPlus[0]			= high0 - high1 > low1 - low0 ? Math.Max(high0 - high1, 0) : 0;
				dmMinus[0]			= low1 - low0 > high0 - high1 ? Math.Max(low1 - low0, 0) : 0;

				if (CurrentBar < Period)
				{
					sumTr[0]		= sumTr[1] + tr[0];
					sumDmPlus[0]	= sumDmPlus[1] + dmPlus[0];
					sumDmMinus[0]	= sumDmMinus[1] + dmMinus[0];
				}
				else
				{
					double sumTr1		= sumTr[1];
					double sumDmPlus1	= sumDmPlus[1];
					double sumDmMinus1	= sumDmMinus[1];
						
					sumTr[0]			= sumTr1 - sumTr1 / Period + tr[0];
					sumDmPlus[0]		= sumDmPlus1 - sumDmPlus1 / Period + dmPlus[0];
					sumDmMinus[0]		= sumDmMinus1 - sumDmMinus1 / Period + dmMinus[0];
				}
				
				double sumTr0		= sumTr[0];
				double diPlus		= 100 * (sumTr0.ApproxCompare(0) == 0 ? 0 : sumDmPlus[0] / sumTr[0]);
				double diMinus		= 100 * (sumTr0.ApproxCompare(0) == 0 ? 0 : sumDmMinus[0] / sumTr[0]);
				double diff			= Math.Abs(diPlus - diMinus);
				double sum			= diPlus + diMinus;

				Value[0]			= sum.ApproxCompare(0) == 0 ? 50 : ((Period - 1) * Value[1] + 100 * diff / sum) / Period;
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ADX[] cacheADX;
		public ADX ADX(int period)
		{
			return ADX(Input, period);
		}

		public ADX ADX(ISeries<double> input, int period)
		{
			if (cacheADX != null)
				for (int idx = 0; idx < cacheADX.Length; idx++)
					if (cacheADX[idx] != null && cacheADX[idx].Period == period && cacheADX[idx].EqualsInput(input))
						return cacheADX[idx];
			return CacheIndicator<ADX>(new ADX(){ Period = period }, input, ref cacheADX);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ADX ADX(int period)
		{
			return indicator.ADX(Input, period);
		}

		public Indicators.ADX ADX(ISeries<double> input , int period)
		{
			return indicator.ADX(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ADX ADX(int period)
		{
			return indicator.ADX(Input, period);
		}

		public Indicators.ADX ADX(ISeries<double> input , int period)
		{
			return indicator.ADX(input, period);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Plots the open, high, and low values from the session starting on the current day.
	/// </summary>
	public class CurrentDayOHL : Indicator
	{
		private DateTime				currentDate			=	Core.Globals.MinDate;
		private double					currentOpen			=	double.MinValue;
		private double					currentHigh			=	double.MinValue;
		private double					currentLow			=	double.MaxValue;
		private Data.SessionIterator	sessionIterator;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionCurrentDayOHL;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameCurrentDayOHL;
				IsAutoScale					= false;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				PlotCurrentValue			= false;
				ShowLow						= true;
				ShowHigh					= true;
				ShowOpen					= true;
				BarsRequiredToPlot			= 0;

				AddPlot(new Stroke() { Brush = Brushes.Orange,	Width = 2, DashStyleHelper	= DashStyleHelper.Dash }, PlotStyle.Square, ""Current Open"");
				AddPlot(new Stroke() { Brush = Brushes.Green,	Width = 2, DashStyleHelper	= DashStyleHelper.Dash }, PlotStyle.Square, ""Current High"");
				AddPlot(new Stroke() { Brush = Brushes.Red,		Width = 2, DashStyleHelper	= DashStyleHelper.Dash }, PlotStyle.Square, ""Current Low"");
			}
			else if (State == State.Configure)
			{
				currentDate			= Core.Globals.MinDate;
				currentOpen			= double.MinValue;
				currentHigh			= double.MinValue;
				currentLow			= double.MaxValue;
				sessionIterator		= null;
			}
		}

		protected override void OnBarUpdate()
		{
			if (!Bars.BarsType.IsIntraday)
			{
				Draw.TextFixed(this, ""error msg"", Custom.Resource.CurrentDayOHLError, TextPosition.BottomRight);
				return;
			}

			if (sessionIterator == null)
				sessionIterator = new Data.SessionIterator(BarsArray[0]);

			bool sameDay = true;
			if (currentDate != sessionIterator.GetTradingDay(Time[0]) || currentOpen == double.MinValue)
			{
				currentOpen 	= Open[0];
				currentHigh 	= High[0];
				currentLow		= Low[0];
				sameDay			= false;
			}

			currentHigh 		= Math.Max(currentHigh, High[0]);
			currentLow			= Math.Min(currentLow, Low[0]);
			
			if (ShowOpen)
			{
				if (!PlotCurrentValue || !sameDay)
					CurrentOpen[0] = currentOpen;
				else
					for (int idx = 0; idx < CurrentBar - 1; idx++)
						CurrentOpen[idx] = currentOpen;
			}

			if (ShowHigh)
			{
				if (!PlotCurrentValue || currentHigh != High[0])
					CurrentHigh[0] = currentHigh;
				else
					for (int idx = 0; idx < CurrentBar - 1; idx++)
						CurrentHigh[idx] = currentHigh;
			}

			if (ShowLow)
			{
				if (!PlotCurrentValue || currentLow != Low[0])
					CurrentLow[0] = currentLow;
				else
					for (int idx = 0; idx < CurrentBar - 1; idx++)
						CurrentLow[idx] = currentLow;
			}

			currentDate = sessionIterator.GetTradingDay(Time[0]);
		}

		#region Properties
        [Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
        [XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
        public Series<double> CurrentOpen
        {
            get { return Values[0]; }
        }

        [Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
        [XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
        public Series<double> CurrentHigh
        {
            get { return Values[1]; }
        }

        [Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
        [XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
        public Series<double> CurrentLow
        {
            get { return Values[2]; }
        }

		[Display(ResourceType = typeof(Custom.Resource), Name = ""Plot current value"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public bool PlotCurrentValue
        { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = ""Show high"", GroupName = ""NinjaScriptParameters"", Order = 1)]
        public bool ShowHigh
        { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = ""Show low"", GroupName = ""NinjaScriptParameters"", Order = 2)]
        public bool ShowLow
        { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = ""Show open"", GroupName = ""NinjaScriptParameters"", Order = 3)]
        public bool ShowOpen
        { get; set; }
        #endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private CurrentDayOHL[] cacheCurrentDayOHL;
		public CurrentDayOHL CurrentDayOHL()
		{
			return CurrentDayOHL(Input);
		}

		public CurrentDayOHL CurrentDayOHL(ISeries<double> input)
		{
			if (cacheCurrentDayOHL != null)
				for (int idx = 0; idx < cacheCurrentDayOHL.Length; idx++)
					if (cacheCurrentDayOHL[idx] != null &&  cacheCurrentDayOHL[idx].EqualsInput(input))
						return cacheCurrentDayOHL[idx];
			return CacheIndicator<CurrentDayOHL>(new CurrentDayOHL(), input, ref cacheCurrentDayOHL);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.CurrentDayOHL CurrentDayOHL()
		{
			return indicator.CurrentDayOHL(Input);
		}

		public Indicators.CurrentDayOHL CurrentDayOHL(ISeries<double> input )
		{
			return indicator.CurrentDayOHL(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.CurrentDayOHL CurrentDayOHL()
		{
			return indicator.CurrentDayOHL(Input);
		}

		public Indicators.CurrentDayOHL CurrentDayOHL(ISeries<double> input )
		{
			return indicator.CurrentDayOHL(input);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all strategies and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Strategies
{
	public class SampleTradeLimiter : Strategy
	{
		private int aDXPeriod 		= 14; // Default setting for ADXPeriod
		private int tradeCounter	= 0;  // This variable represents the number of trades taken per day.
		private int maxTrades		= 5;  // This variable sets the maximum number of trades to take per day.

		protected override void OnStateChange()
		{
			if(State == State.SetDefaults)
			{
				ADXPeriod	= 14;
				MaxTrades	= 5;
				Calculate 	= Calculate.OnBarClose;
				Name		= ""Sample Trade Limiter"";
			}
			else if(State == State.Configure)
			{
				// Add the current day open, high, low indicator to visually see entry conditions.
				AddChartIndicator(CurrentDayOHL());
			}
		}

		protected override void OnBarUpdate()
		{
			// Make sure there are enough bars.
			if (CurrentBar < 1)
				return;
			
			// Reset the tradeCounter value at the first tick of the first bar of each session.
			if (Bars.IsFirstBarOfSession && IsFirstTickOfBar)
			{
				Print(""resetting tradeCounter"");
				tradeCounter = 0;	
			}
			
			// If the amount of trades is less than the permitted value and the position is flat, go on to the next set of conditions.
			if (tradeCounter < MaxTrades && Position.MarketPosition == MarketPosition.Flat)
			{
				/* If a new low is made, enter short and increase the trade count by 1.
				In C#, ++ means increment by one. An equilivent would be tradeCounter = tradeCounter + 1; */
				if (CurrentDayOHL().CurrentLow[0] < CurrentDayOHL().CurrentLow[1])
				{
					tradeCounter++;
					EnterShort();
				}
				// If a new high is made, enter long and increase the trade count by 1.
				else if (CurrentDayOHL().CurrentHigh[0] > CurrentDayOHL().CurrentHigh[1])
				{
					tradeCounter++;
					EnterLong();
				}
			}
			
			/* Exit a position if ""the trend has ended"" as indicated by ADX.
			If the current ADX value is less than the previous ADX value, the trend strength is weakening. */
			if (ADX(ADXPeriod)[0] < ADX(ADXPeriod)[1] && Position.MarketPosition != MarketPosition.Flat)
			{
				if (Position.MarketPosition == MarketPosition.Long)
					ExitLong();
				else if (Position.MarketPosition == MarketPosition.Short)
					ExitShort();
			}
		}

		#region Properties
		[Display(GroupName=""Parameters"", Description=""Period for the ADX indicator"")]
		public int ADXPeriod
		{
			get { return aDXPeriod; }
			set { aDXPeriod = Math.Max(1, value); }
		}

		[Display(GroupName=""Parameters"", Description=""Maximum number of trades to take per day."")]
		public int MaxTrades
		{
			get { return maxTrades; }
			set { maxTrades = Math.Max(1, value); }
		}
		#endregion
	}
}
"
Indicator Methods and Properties.docx,"The methods and properties covered in this section are unique to custom indicator development.  Indicator configuration properties globally define various behaviors of indicators. All properties have default values and can be overridden by setting them in the OnStateChange() method of the indicator.
 
 
 
Methods and Properties
Definition
Adds line objects on a chart.
 
 
Methods and Properties
Syntax
AddLine(Brush brush, double value, string name)
AddLine(Stroke stroke, double value, string name)
 
 
Parameters
 
 
Examples
 
 
 
Definition
Adds plot objects that define how an indicator or strategy data series render on a chart. When this method is called to add a plot, an associated Series<double> object is created held in the Values collection.
 
 
Methods and Properties
 
Syntax
AddPlot(Brush brush, string name)
AddPlot(Stroke stroke, PlotStyle plotStyle, string name)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
 
 
Definition
The number of bars on a chart required before the script plots.
 
 
 
Property Value
An int value that represents the minimum number of bars required.
 
Syntax
BarsRequiredToPlot
 
Examples
Definition
Determines if plot(s) display in the chart data box.
 
Property Value
This property returns true if the indicator plot(s) values display in the chart data box; otherwise, false. Default set to true.
 
 
 
Syntax
DisplayInDataBox
 
Examples
Definition
Plots horizontal grid lines on the indicator panel.
 
 
 
Property Value
This property returns true if horizontal grid lines are plotted on the indicator panel; otherwise, false. Default set to true.
 
 
 
Syntax
DrawHorizontalGridLines
 
Examples
Definition
Determines the chart panel the draw objects renders
 
Property Value
This property returns true if the indicator paints draw objects on the price panel; otherwise when false, draw objects are painted on the actual indicator panel itself. Default set to true.
 
 
Syntax
DrawOnPricePanel
 
Examples
Definition
A custom TypeConverter class handling the designed behavior of an indicator's property descriptor collection.  Use this as a base class for any custom TypeConverter you are applying to an indicator class.
 
 
 
Relevant base methods
 
 
Syntax
public class IndicatorBaseConverter : TypeConverter
 
 
 
 
 
Examples
Definition
If true, any indicator will be only available for charting usage - indicators with this property enabled would for example not be expected to show if called in a SuperDOM or MarketAnalyzer window.
 
Property Value
This property returns true if the indicator can only be used on a chart; otherwise, false. Default set to false.
 
 
 
Syntax
IsChartOnly
 
Examples
Definition
If true, any indicator will be only available for charting usage - indicators with this property enabled would for example not be expected to show if called in a SuperDOM or MarketAnalyzer window.
 
Property Value
This property returns true if the indicator can only be used on a chart; otherwise, false. Default set to false.
 
 
 
Syntax
IsChartOnly
 
Examples
Definition
Prevents OnBarUpdate from being raised while the indicators display is not in use.  Enabling this property in your indicator helps save CPU cycles while the indicator is suspended and not in use by a user.  Once the indicator is in a state that would no longer be considered suspended, the historical OnBarUpdate() events will be triggered allowing the indicator to catch up to current real-time values.  
 
Suspension occurs in the following scenarios:
 
•Minimized Chart
•Minimized Market Analyzer
•Minimized Hot List Analyzer
•Minimized SuperDOM
•Background tabs of above features are considered ""minimized""
•Inactive workspaces in the background
 
 
 
Scenarios where suspension will not occur
The IsSuspendedWhileInactive property will be ignored and real-time events will be processed as normal under the following cases:
 
•Indicators running in Automated NinjaScript Strategies
•Indicators which have manually configured alerts
•Indicators which have been manually attached to orders
 
Property Value
This property returns true if indicator can take advantage of suspension optimization; otherwise, false. Default set to false.
 
 
 
 
 
Syntax
IsSuspendedWhileInactive
 
Examples
Definition
If true, any indicator plot values display price markers in the y-axis.
 
Property Value
This property returns true if the indicator plot values display in the y-axis; otherwise, false. Default set to true.
 
 
 
Syntax
PaintPriceMarkers
 
Examples
Definition
Determines if plot(s) values which are set to a Transparent brush display in the chart data box.  The default behavior is to hide any plots which have been configured as a Transparent brush, however this behavior can be changed by setting ShowTransparentPlotsInDataBox to true on the indicator.
 
Property Value
This property returns true if transparent indicator plot(s) values display in the chart data box; otherwise, false. Default set to false.
 
 
 
Syntax
ShowTransparentPlotsInDataBox
 
Examples
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
Definition
Adds line objects on a chart.
 
 
Methods and Properties
Syntax
AddLine(Brush brush, double value, string name)
AddLine(Stroke stroke, double value, string name)
 
 
Parameters
 
 
Examples
 
 
 
Definition
Adds plot objects that define how an indicator or strategy data series render on a chart. When this method is called to add a plot, an associated Series<double> object is created held in the Values collection.
 
 
Methods and Properties
 
Syntax
AddPlot(Brush brush, string name)
AddPlot(Stroke stroke, PlotStyle plotStyle, string name)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
 
 
Definition
Determines if programmatically drawn DrawObjects are allowed to remove manually from the chart
 
Property Value
When set to true, the draw objects from the indicator or strategy can be deleted from the chart manually by a user. If false, draw objects from the indicator or strategy can only be removed from the chart if the script removes the drawing object, or the script is terminates.  Default set to false.
 
Syntax
AllowRemovalOfDrawObjects
 
Examples
Definition
Determines if the line(s) used in an indicator are configurable from within the indicator dialog window.
 
 
Property Value
A bool which true if any indicator line(s) are configurable; otherwise, false. Default set to true.
 
Syntax
AreLinesConfigurable
 
 
Examples
Definition
Determines if the plot(s) used in an indicator are configurable within the indicator dialog window.
 
Property Value
A bool which returns true if any indicator plot(s) are configurable; otherwise, false. Default set to true.
 
Syntax
ArePlotsConfigurable
 
Examples
Definition
Sets the brush used for painting the chart panel's background color for the current bar.
 
 
Property Value
A Brush object that represents the color of the current chart bar.
 
Syntax
BackBrush
 
 
 
Examples
 
 


 
Definition
A collection of prior back brushes used for the background colors for all chart panels.
 
Property Value
A Brush object that represents the color of the current chart bar.
 
 
Syntax
BackBrushAll
 
 
 
Examples
 
 

Definition
A collection of prior back brushes used for the background colors of the chart panel.
 
Property Value
A brush series type object. Accessing this property via an index value [int barsAgo] returns a Brush object representing the color of the background color on the referenced bar.
 
Syntax
BackBrushes
BackBrushes[int barsAgo]
 
 
 
Examples
Definition
A collection of historical brushes used for the background colors for all chart panels.
 
Property Value
A brush series type object. Accessing this property via an index value [int barsAgo] returns a Brush object representing the color of the background color on the referenced bar for all chart panels.
 
Syntax
BackBrushesAll
BackBrushesAll[int barsAgo]
 
 
 
Examples
Definition
Sets the brush used for painting the color of a price bar's body.
 
Property Value
A Brush object that represents the color of this price bar.
 
 
Syntax
BarBrush
 
 
 
Examples
Definition
A collection of historical brushes used for painting the color of a price bar's body.
 
Property Value
A brush series type object. Accessing this property via an index value [int barsAgo] returns a Brush object representing the referenced bar's color.
 
 
Syntax
BarBrushes
BarBrushes[int barsAgo]
 
 
 
Examples
Definition
Sets the outline Brush of a candlestick.
 
Property Value
A brush object that represents the color of this price bar.
 
Syntax
CandleOutlineBrush
 
 
 
Examples
Definition
A collection of historical outline brushes for candlesticks.
 
Property Value
A brush series type object. Accessing this property via an index value [int barsAgo] returns a brush structure representing the referenced bar's outline color.
 
 
 
Syntax
CandleOutlineBrushes
CandleOutlineBrushes[int barsAgo]
 
 
 
Examples
Definition
Determines if plot(s) display in the chart data box.
 
Property Value
This property returns true if the indicator plot(s) values display in the chart data box; otherwise, false. Default set to true.
 
 
 
Syntax
DisplayInDataBox
 
Examples
Definition
Determines if indicator plot(s) are drawn on the chart panel over top of price.  Setting this value to true will also allow an Indicator to be used as a SuperDOM Indicator.
 
Property Value
This property returns true if any indicator plot(s) are drawn on the chart panel; otherwise, false. Default set to false.
 
 
Syntax
IsOverlay
 
Examples
Definition
Holds an array of color series objects holding historical bar colors. A color series object is added to this array when calling the AddPlot() method in a custom Indicator for plots. Its purpose is to provide access to the color property of all bars.
 
Property Value
An array of color series objects.
 
Syntax
PlotBrushes[int PlotIndex][int barsAgo]
 
Examples
Definition
A collection holding all of the Plot objects that define their visualization characteristics.
 
Property Value
A collection of Plot objects.
 
Syntax
Plots[int index]
 
 
 
Example
Definition
A collection of historical brushes used for painting the color of a price bar's body.
 
Property Value
A brush series type object. Accessing this property via an index value [int barsAgo] returns a Brush object representing the referenced bar's color.
 
 
Syntax
BarBrushes
BarBrushes[int barsAgo]
 
 
 
Examples
Definition
If true, the drawing tool will call CalculateMinMax() in order to determine the drawing tool's MinValue and MaxValue value used to scale the Y-axis of the chart.
 
Property Value
This property returns true if the drawing tool plot(s) are included in the y-scale; otherwise, false. Default set to false.
 
 
Syntax
IsAutoScale
 
Example
Definition
Determines which scale an indicator will be plotted on.
 
 
 
Property Value
This property returns a ScaleJustification value of either:
 
NinjaTrader.Gui.Charts.ScaleJustification.Left;
NinjaTrader.Gui.Charts.ScaleJustification.Overlay;
NinjaTrader.Gui.Charts.ScaleJustification.Right;
 
 
Syntax
ScaleJustification
 
Examples
Definition
Draws an Andrew's Pitchfork.
 
Method Return Value
An AndrewsPitchfork object that represents the draw object.
 
Syntax
Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, Brush brush, DashStyleHelper dashStyle, int width)
Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime anchor1Time, double anchor1Y, DateTime anchor2Time, double anchor2Y, DateTime anchor3Time, double anchor3Y, Brush brush, DashStyleHelper dashStyle, int width)
Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, int anchor1BarsAgo, double anchor1Y, int anchor2BarsAgo, double anchor2Y, int anchor3BarsAgo, double anchor3Y, bool isGlobal, string templateName)
Draw.AndrewsPitchfork(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime anchor1Time, double anchor1Y, DateTime anchor2Time, double anchor2Y, DateTime anchor3Time, double anchor3Y, bool isGlobal, string templateName)
 
 
 
Parameters
 
 
Examples
Definition
Draws an arc.
 
Method Return Value
An Arc object that represents the draw object.
 
Syntax
Draw.Arc(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)
Draw.Arc(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)
Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)
Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width)
Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.Arc(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.Arc(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)
Draw.Arc(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)
 
 
Parameters
 
 
 
Examples

 
Definition
Draws an arrow pointing down.
 
Method Return Value
An ArrowDown object that represents the draw object.
 
Syntax
Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)
Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)
Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)
Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)
Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)
Draw.ArrowDown(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)
 
Parameters
 
 
 
 
Examples
Definition
Draws an arrow line.
 
Method Return Value
An ArrowLine object that represents the draw object.
 
Syntax
Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)
Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)
Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)
Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.ArrowLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.ArrowLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)
Draw.ArrowLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)
 
Parameters
 
 
Examples
Definition
Draws a diamond.
 
Method Return Value
A Diamond object that represents the draw object.
 
Syntax
Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)
Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)
Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)
Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)
Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)
Draw.Diamond(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)
 
Parameters
 
 
 
 
Examples
Definition
Draws a dot.
 
Method Return Value
A Dot object that represents the draw object.
 
Syntax
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)
 
Parameters
 
 
 
 
Examples
Definition
Draws an ellipse.
 
Method Return Value
An Ellipse object that represents the draw object.
 
Syntax
Draw.Ellipse(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)
Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity)
Draw.Ellipse(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)
Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity)
Draw.Ellipse(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, bool drawOnPricePanel)
Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)
Draw.Ellipse(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, bool drawOnPricePanel)
Draw.Ellipse(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, Brush areaBrush, int areaOpacity, bool drawOnPricePanel)
Draw.Ellipse(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)
Draw.Ellipse(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)
 
 
Parameters
 
 
Examples
Definition
Draws a line with infinite end points.
 
Method Return Value
An ExtendedLine object that represents the draw object.
 
Syntax
Draw.ExtendedLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush)
Draw.ExtendedLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush)
Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width)
Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width)
Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.ExtendedLine(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.ExtendedLine(NinjaScriptBase owner, string tag, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)
Draw.ExtendedLine(NinjaScriptBase owner, string tag, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)
 
 
Parameters
 
 
Examples
Definition
Draws a fibonacci circle.
 
Method Return Value
A FibonacciCircle object that represents the draw object.
 
Syntax
Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY)
Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY)
Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)
Draw.FibonacciCircle(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)
 
 
Parameters
 
 
Examples
Definition
Draws a fibonacci extension.
 
Method Return Value
A FibonacciExtensions object that represents the draw object.
 
Syntax
Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, int extensionBarsAgo, double extensionY)
Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, DateTime extensionTime, double extensionY)
Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, DateTime extensionTime, double extensionY, bool isGlobal, string templateName)
Draw.FibonacciExtensions(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, int extensionBarsAgo, double extensionY, bool isGlobal, string templateName)
 
 
Parameters
 
 
Examples
Definition
Draws a fibonacci retracement.
 
Method Return Value
A FibonacciRetracements object that represents the draw object.
 
Syntax
Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY)
Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY)
Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime startTime, double startY, DateTime endTime, double endY, bool isGlobal, string templateName)
Draw.FibonacciRetracements(NinjaScriptBase owner, string tag, bool isAutoScale, int startBarsAgo, double startY, int endBarsAgo, double endY, bool isGlobal, string templateName)
 
 
Parameters
 
 
Examples
Definition
Removes a draw object from the chart based on its tag value.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
RemoveDrawObject(string tag)
 
 
Parameters
 
 
Examples
Definition
Removes all draw objects originating from the indicator or strategy from the chart.
 
 
 
Method Return Value
This method does not return a value
 
 
Syntax
RemoveDrawObjects()
 
 
Examples
Definition
Draws text.
 
Method Return Value
A Text object that represents the draw object.
 
Syntax
Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y)
Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y, Brush textBrush)
Draw.Text(NinjaScriptBase owner, string tag, string text, int barsAgo, double y, bool isGlobal, string templateName)
Draw.Text(NinjaScriptBase owner, string tag, bool isAutoScale, string text, int barsAgo, double y, int yPixelOffset, Brush textBrush, SimpleFont font, TextAlignment alignment, Brush outlineBrush, Brush areaBrush, int areaOpacity)
Draw.Text(NinjaScriptBase owner, string tag, bool isAutoScale, string text, DateTime time, double y, int yPixelOffset, Brush textBrush, SimpleFont font, TextAlignment alignment, Brush outlineBrush, Brush areaBrush, int areaOpacity)
 
 
Parameters
 
Examples
 
 
 
 
Definition
Draws a dot.
 
Method Return Value
A Dot object that represents the draw object.
 
Syntax
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, Brush brush, bool drawOnPricePanel)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, Brush brush, bool drawOnPricePanel)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, DateTime time, double y, bool isGlobal, string templateName)
Draw.Dot(NinjaScriptBase owner, string tag, bool isAutoScale, int barsAgo, double y, bool isGlobal, string templateName)
 
Parameters
 
 
 
 
Examples
Definition
Represents an interface that exposes information regarding a Horizontal Line IDrawingTool.
 
Methods and Properties
 
 
Example
Definition
Draws a horizontal line.
 
Method Return Value
A HorizontalLine object that represents the draw object.
 
Syntax
Draw.HorizontalLine(NinjaScriptBase owner, string tag, double y, Brush brush)
Draw.HorizontalLine(NinjaScriptBase owner, string tag, bool isAutoScale, double y, Brush brush, DashStyleHelper dashStyle, int width)
Draw.HorizontalLine(NinjaScriptBase owner, string tag, bool isAutoscale, double y, Brush brush, bool drawOnPricePanel)
Draw.HorizontalLine(NinjaScriptBase owner, string tag, double y, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.HorizontalLine(NinjaScriptBase owner, string tag, double y, bool isGlobal, string templateName)
 
 
Parameters
 
 
Examples
Definition
Draws a vertical line.
 
Method Return Value
A VerticalLine object that represents the draw object.
 
Syntax
Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, Brush brush)
Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, Brush brush)
Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, Brush brush, DashStyleHelper dashStyle, int width, bool drawOnPricePanel)
Draw.VerticalLine(NinjaScriptBase owner, string tag, int barsAgo, bool isGlobal, string templateName)
Draw.VerticalLine(NinjaScriptBase owner, string tag, DateTime time, bool isGlobal, string templateName)
 
 
Parameters
 
 
Examples
Definition
Represents an interface that exposes information regarding a Vertical Line IDrawingTool.
 
Methods and Properties
 
 
Examples
Definition
A collection holding all of the drawn chart objects on the chart, for all series. The draw objects can be manually drawn or script generated objects.
 
 
 
Property Value
A collection of IDrawingTool objects.
 
Syntax
DrawObjects
DrawObjects[string tag]
DrawObjects.Count
 
 
Examples
 
 
 
 
 
 
Definition
Determines the chart panel the draw objects renders
 
Property Value
This property returns true if the indicator paints draw objects on the price panel; otherwise when false, draw objects are painted on the actual indicator panel itself. Default set to true.
 
 
Syntax
DrawOnPricePanel
 
Examples
Definition
Determines if programmatically drawn DrawObjects are allowed to remove manually from the chart
 
Property Value
When set to true, the draw objects from the indicator or strategy can be deleted from the chart manually by a user. If false, draw objects from the indicator or strategy can only be removed from the chart if the script removes the drawing object, or the script is terminates.  Default set to false.
 
Syntax
AllowRemovalOfDrawObjects
 
Examples
Definition
Removes a draw object from the chart based on its tag value.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
RemoveDrawObject(string tag)
 
 
Parameters
 
 
Examples
Definition
Removes all draw objects originating from the indicator or strategy from the chart.
 
 
 
Method Return Value
This method does not return a value
 
 
Syntax
RemoveDrawObjects()
 
 
Examples
The methods and properties covered in this section are unique to custom indicator development.  Indicator configuration properties globally define various behaviors of indicators. All properties have default values and can be overridden by setting them in the OnStateChange() method of the indicator.
 
 
 
Methods and Properties
Definition
Adds line objects on a chart.
 
 
Methods and Properties
Syntax
AddLine(Brush brush, double value, string name)
AddLine(Stroke stroke, double value, string name)
 
 
Parameters
 
 
Examples
 
 
 
Definition
Adds plot objects that define how an indicator or strategy data series render on a chart. When this method is called to add a plot, an associated Series<double> object is created held in the Values collection.
 
 
Methods and Properties
 
Syntax
AddPlot(Brush brush, string name)
AddPlot(Stroke stroke, PlotStyle plotStyle, string name)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
 
 
 
Definition
The number of bars on a chart required before the script plots.
 
 
 
Property Value
An int value that represents the minimum number of bars required.
 
Syntax
BarsRequiredToPlot
 
Examples
Definition
Determines if plot(s) display in the chart data box.
 
Property Value
This property returns true if the indicator plot(s) values display in the chart data box; otherwise, false. Default set to true.
 
 
 
Syntax
DisplayInDataBox
 
Examples
Definition
Plots horizontal grid lines on the indicator panel.
 
 
 
Property Value
This property returns true if horizontal grid lines are plotted on the indicator panel; otherwise, false. Default set to true.
 
 
 
Syntax
DrawHorizontalGridLines
 
Examples
Definition
Determines the chart panel the draw objects renders
 
Property Value
This property returns true if the indicator paints draw objects on the price panel; otherwise when false, draw objects are painted on the actual indicator panel itself. Default set to true.
 
 
Syntax
DrawOnPricePanel
 
Examples
Definition
Determines the chart panel the draw objects renders
 
Property Value
This property returns true if the indicator paints draw objects on the price panel; otherwise when false, draw objects are painted on the actual indicator panel itself. Default set to true.
 
 
Syntax
DrawOnPricePanel
 
Examples
Definition
A custom TypeConverter class handling the designed behavior of an indicator's property descriptor collection.  Use this as a base class for any custom TypeConverter you are applying to an indicator class.
 
 
 
Relevant base methods
 
 
Syntax
public class IndicatorBaseConverter : TypeConverter
 
 
 
 
 
Examples
Definition
If true, any indicator will be only available for charting usage - indicators with this property enabled would for example not be expected to show if called in a SuperDOM or MarketAnalyzer window.
 
Property Value
This property returns true if the indicator can only be used on a chart; otherwise, false. Default set to false.
 
 
 
Syntax
IsChartOnly
 
Examples
Definition
Prevents OnBarUpdate from being raised while the indicators display is not in use.  Enabling this property in your indicator helps save CPU cycles while the indicator is suspended and not in use by a user.  Once the indicator is in a state that would no longer be considered suspended, the historical OnBarUpdate() events will be triggered allowing the indicator to catch up to current real-time values.  
 
Suspension occurs in the following scenarios:
 
•Minimized Chart
•Minimized Market Analyzer
•Minimized Hot List Analyzer
•Minimized SuperDOM
•Background tabs of above features are considered ""minimized""
•Inactive workspaces in the background
 
 
 
Scenarios where suspension will not occur
The IsSuspendedWhileInactive property will be ignored and real-time events will be processed as normal under the following cases:
 
•Indicators running in Automated NinjaScript Strategies
•Indicators which have manually configured alerts
•Indicators which have been manually attached to orders
 
Property Value
This property returns true if indicator can take advantage of suspension optimization; otherwise, false. Default set to false.
 
 
 
 
 
Syntax
IsSuspendedWhileInactive
 
Examples
Definition
Prevents OnBarUpdate from being raised while the indicators display is not in use.  Enabling this property in your indicator helps save CPU cycles while the indicator is suspended and not in use by a user.  Once the indicator is in a state that would no longer be considered suspended, the historical OnBarUpdate() events will be triggered allowing the indicator to catch up to current real-time values.  
 
Suspension occurs in the following scenarios:
 
•Minimized Chart
•Minimized Market Analyzer
•Minimized Hot List Analyzer
•Minimized SuperDOM
•Background tabs of above features are considered ""minimized""
•Inactive workspaces in the background
 
 
 
Scenarios where suspension will not occur
The IsSuspendedWhileInactive property will be ignored and real-time events will be processed as normal under the following cases:
 
•Indicators running in Automated NinjaScript Strategies
•Indicators which have manually configured alerts
•Indicators which have been manually attached to orders
 
Property Value
This property returns true if indicator can take advantage of suspension optimization; otherwise, false. Default set to false.
 
 
 
 
 
Syntax
IsSuspendedWhileInactive
 
Examples
Definition
If true, any indicator plot values display price markers in the y-axis.
 
Property Value
This property returns true if the indicator plot values display in the y-axis; otherwise, false. Default set to true.
 
 
 
Syntax
PaintPriceMarkers
 
Examples
Definition
Determines if plot(s) values which are set to a Transparent brush display in the chart data box.  The default behavior is to hide any plots which have been configured as a Transparent brush, however this behavior can be changed by setting ShowTransparentPlotsInDataBox to true on the indicator.
 
Property Value
This property returns true if transparent indicator plot(s) values display in the chart data box; otherwise, false. Default set to false.
 
 
 
Syntax
ShowTransparentPlotsInDataBox
 
Examples
The first step in creating a custom indicator is to use the custom indicator wizard. The wizard will generate the required NinjaScript code that will serve as the foundation for your custom indicator.
 
1. Within the NinjaTrader Control Center window select the Tools-->New NinjaScript-->Indicator... menu
2. Press the ""Next >"" button
 
Defining Indicator Properties and Name
Below you will define your indicators name and several indicator properties.
 
//screen shot
 
3. Enter the information as shown above
4. We have checked the option ""Overlay on price"" which means that this will be a price overlay indicator (will plot on top of the price data instead of in its own indicator panel)
5. Press the ""Next >"" button
 
Defining Input Parameters
Below you will define your indicator's input parameters. These are any parameters that can be changed by the user and used in the calculation of the indicators value(s). If your indicator does not require any parameters leave the ""Name"" fields blank.
 
//screen shot
 
6. Enter the information as shown above
7. Press the ""Next >"" button
 
Defining Plots
Below you will define how your indicator is plotted on a chart.
 
//screen shot
 
8. Enter the information as shown above.
9. Press the ""Next >"" button
 
Defining Oscillator Lines
Below you will define any required oscillator lines. This would be the ""Zero"" line in the CCI indicator for example. If your indicator does not require any oscillator lines leave the ""Name"" fields blank.
 
//screen shot
 
10. Enter the information as shown above (make sure the ""Name"" fields are blank since we do not need an oscillator line for a simple moving average indicator)
11. Press the ""Next >"" button
12. We are now finished entering in our indicator set up information. Press ""Finish"" button.
 
* At any time, you can press the ""Generate"" button in the wizard if you do not need to go through each of the wizard steps.
 
You will now see the NinjaScript Editor preloaded with NinjaScript code generated by the wizard. It should look something like the image below.
 
//screen shot
 
Your primary area of concern will be sections ""2"" and ""3"".
 
1. This section provides the indicator with the chart display name and description used in the Indicator Dialog window.
2. The OnStateChange() section is processed only once when the indicator is initially loaded (added to a chart for example) and can be used to set up any indicator configuration requirements. You can see that this wizard generated code that added the plot color and style and set the ""Overlay"" property which we configured in the wizard in step 4 above. The default value of the ""Period"" parameter is set in the ""Variables"" region of the code above OnStateChange().
3. This is the section that is called on each bar update (incoming tick) and is where you will enter your indicator logic
Definition
Adds plot objects that define how an indicator or strategy data series render on a chart. When this method is called to add a plot, an associated Series<double> object is created held in the Values collection.
 
 
Methods and Properties
 
Syntax
AddPlot(Brush brush, string name)
AddPlot(Stroke stroke, PlotStyle plotStyle, string name)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
 
 
 


"
MaximumBarsLookBack 2.docx,"Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Definition
Forces all Series<T> objects including plot series objects to hold the maximum amount of bars possible. This property supercedes the UI property of ""Maximum bars look back"".  
 
 
Method Return Value
A bool value when true, any ISeries<T> interfaces contained in the scripts MaximumBarsLookBack property will be set to MaximumBarsLookBack.Infinite; otherwise will use the default properties configured.  Default is set to false.
 
Syntax
ForcePlotsMaximumBarsLookBackInfinite
 
 
Examples
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Release Date
July 11, 2016
 
Code Breaking Changes
Compile Errors
•The NinjaScript Strategy ""AccountSize"" concept was removed due to limited functionality.  This change would also impact strategies which were coded to use SetOrderQuantity.ByAccountSize.  Please use your own variables to set quantities by account size. Tip:  NinjaTrader 8 can read real-world account values for live trading purposes through the Account class, e.g., Account.Get(AccountItem.CashValue, Currency.UsDollar) provides a method for returning a double value representing the current cash value of the account.
 
Implementation changes
•The concept used to force plot series objects through ForcePlotsMaximumBarsLookBackInfinite was disabled and tagged as obsolete.  You should set any indicator/strategy plots to MaximumBarsLookBack.Infinite during its construction.
•It is recommended that any strategies generated with the 'Strategy Builder' tool via Control Center > New > Strategy Builder be removed and recreated after installing B12. If you had invested significant effort in a Strategy Builder generated strategy in B11 which you would like to continue to use, please contact us platformsupport@ninjatrader.com
 
Notes
Definition
Indicates if the specified input is set at a barsAgo value relative to the current bar.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
Syntax
IsValidDataPoint(int barsAgo)
ISeries<T>.IsValidDataPoint(int barsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Draws a region on a chart.
 
Method Return Value
A Region object that represents the draw object.
 
Syntax
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series, double price, Brush areaBrush, int areaOpacity, int displacement = 0)
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush,
        Brush areaBrush, int areaOpacity, [int displacement])
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series, double price, Brush areaBrush, int areaOpacity)
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush, Brush areaBrush, int areaOpacity)
 
Parameters
 
 
Example
 
 
When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In NinjaScript we are able to access the bars we want through proper use of the bar's indexing.
 
The bar's indexing is setup in a reverse chronological order. This means ""0"" refers to the most recent bar, ""1"" refers to the previous bar, ""2"" refers to the bar before that one, etc.
 
For example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:
 
Now that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are CurrentBar and BarsSinceNewTradingDay.
 
CurrentBar
CurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.
 
For example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:
 
 
BarsSinceNewTradingDay
BarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.
 
For example, if you wanted to find the open of the current session you could do this:
 
The example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.
 
 
Other Properties and Methods
There are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:
BarsSinceEntryExecution()
BarsSinceExitExecution()
GetBar()
GetDayBar()
HighestBar()
LowestBar()
LRO()
MRO()

"
MaximumBarsLookBack.docx,"Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Definition
Forces all Series<T> objects including plot series objects to hold the maximum amount of bars possible. This property supercedes the UI property of ""Maximum bars look back"".  
 
 
Method Return Value
A bool value when true, any ISeries<T> interfaces contained in the scripts MaximumBarsLookBack property will be set to MaximumBarsLookBack.Infinite; otherwise will use the default properties configured.  Default is set to false.
 
Syntax
ForcePlotsMaximumBarsLookBackInfinite
 
 
Examples
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Release Date
July 11, 2016
 
Code Breaking Changes
Compile Errors
•The NinjaScript Strategy ""AccountSize"" concept was removed due to limited functionality.  This change would also impact strategies which were coded to use SetOrderQuantity.ByAccountSize.  Please use your own variables to set quantities by account size. Tip:  NinjaTrader 8 can read real-world account values for live trading purposes through the Account class, e.g., Account.Get(AccountItem.CashValue, Currency.UsDollar) provides a method for returning a double value representing the current cash value of the account.
 
Implementation changes
•The concept used to force plot series objects through ForcePlotsMaximumBarsLookBackInfinite was disabled and tagged as obsolete.  You should set any indicator/strategy plots to MaximumBarsLookBack.Infinite during its construction.
•It is recommended that any strategies generated with the 'Strategy Builder' tool via Control Center > New > Strategy Builder be removed and recreated after installing B12. If you had invested significant effort in a Strategy Builder generated strategy in B11 which you would like to continue to use, please contact us platformsupport@ninjatrader.com
 
Notes
Definition
Indicates if the specified input is set at a barsAgo value relative to the current bar.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
Syntax
IsValidDataPoint(int barsAgo)
ISeries<T>.IsValidDataPoint(int barsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Draws a region on a chart.
 
Method Return Value
A Region object that represents the draw object.
 
Syntax
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series, double price, Brush areaBrush, int areaOpacity, int displacement = 0)
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush,
        Brush areaBrush, int areaOpacity, [int displacement])
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series, double price, Brush areaBrush, int areaOpacity)
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush, Brush areaBrush, int areaOpacity)
 
Parameters
 
 
Example
 
 
When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In NinjaScript we are able to access the bars we want through proper use of the bar's indexing.
 
The bar's indexing is setup in a reverse chronological order. This means ""0"" refers to the most recent bar, ""1"" refers to the previous bar, ""2"" refers to the bar before that one, etc.
 
For example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:
 
Now that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are CurrentBar and BarsSinceNewTradingDay.
 
CurrentBar
CurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.
 
For example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:
 
 
BarsSinceNewTradingDay
BarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.
 
For example, if you wanted to find the open of the current session you could do this:
 
The example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.
 
 
Other Properties and Methods
There are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:
BarsSinceEntryExecution()
BarsSinceExitExecution()
GetBar()
GetDayBar()
HighestBar()
LowestBar()
LRO()
MRO()
Definition
Returns the number of bars that have elapsed since the last specified entry.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous entry does not exist.
 
Syntax
BarsSinceEntryExecution()
BarsSinceEntryExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceEntryExecution(int barsInProgressIndex, string signalName, int entryExecutionsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars that have elapsed since the last specified exit.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous exit does not exist.
 
Syntax
BarsSinceExitExecution()
BarsSinceExitExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceExitExecution(int barsInProgressIndex, string signalName, int exitExecutionsAgo)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Returns the first bar that matches the time stamp of the ""time"" parameter provided.  
 
 
 
Method Return Value
An int value representing an absolute bar index value.
 
Syntax
Bars.GetBar(DateTime time)
 
Parameters
 
 
Examples
Definition
Returns a virtual historical Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.
 
 
 
Method Return Value
A virtual bar object representing the current configured session. Otherwise null if there is insufficient intraday data
 
Syntax
The properties below return double values:
Bars.GetDayBar(int tradingDaysBack).Open
Bars.GetDayBar(int tradingDaysBack).High
Bars.GetDayBar(int tradingDaysBack).Low
Bars.GetDayBar(int tradingDaysBack).Close
 
The property below returns a DateTime structure:
Bars.GetDayBar(int tradingDaysBack).Time
 
The property below returns an int value:
Bars.GetDayBar(int tradingDaysBack).Volume
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the highest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
HighestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the lowest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
LowestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars. The LRO() method start from the furthest bar away and works toward the current bar.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
LRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Most Recent Occurrence(MRO)
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars.  The MRO() method starts from the current bar works away (backward) from it.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
MRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Least Recent Occurrence(LRO)

"
Multi-Colored Plots.docx,"With multi-colored plots it becomes easy to pick out changes in value of your indicator from a quick glance.
 
Key concepts in this example
•Adding plots for each color used
•Plotting a SMA line with three different colors depending on the rising, falling, or neutral nature of the line
 
Important related documentation
•AddPlot()
•IsFalling()
•IsRising()
•PlotBrushes
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
SampleMultiColoredPlot_NT8.zip
Definition
Adds plot objects that define how an indicator or strategy data series render on a chart. When this method is called to add a plot, an associated Series<double> object is created held in the Values collection.
 
 
Methods and Properties
 
Syntax
AddPlot(Brush brush, string name)
AddPlot(Stroke stroke, PlotStyle plotStyle, string name)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
 
 
 
Definition
Determines if the plot(s) used in an indicator are configurable within the indicator dialog window.
 
Property Value
A bool which returns true if any indicator plot(s) are configurable; otherwise, false. Default set to true.
 
Syntax
ArePlotsConfigurable
 
Examples
Definition
An offset value that shifts the visually displayed value of an indicator.
 
Property Value
An int value that represents the number of bars ago to offset with.
 
Syntax
Displacement
 
Examples
Definition
Holds an array of color series objects holding historical bar colors. A color series object is added to this array when calling the AddPlot() method in a custom Indicator for plots. Its purpose is to provide access to the color property of all bars.
 
Property Value
An array of color series objects.
 
Syntax
PlotBrushes[int PlotIndex][int barsAgo]
 
Examples
Definition
A collection holding all of the Plot objects that define their visualization characteristics.
 
Property Value
A collection of Plot objects.
 
Syntax
Plots[int index]
 
 
 
Example
Definition
Evaluates a falling condition which is true when the current value is less than the value of 1 bar ago.
 
Method Return Value
This method returns true if a falling condition is present; otherwise, false.
 
Syntax
IsFalling(ISeries<double> series)
 
Parameters
 
 
Examples
Definition
Evaluates a rising condition which is true when the current value is greater than the value of 1 bar ago.
 
Method Return Value
This method returns true if a rising condition is present; otherwise, false.
 
Syntax
IsRising(ISeries<double> series)
 
Parameters
 
 
Examples
 
Definition
Holds an array of color series objects holding historical bar colors. A color series object is added to this array when calling the AddPlot() method in a custom Indicator for plots. Its purpose is to provide access to the color property of all bars.
 
Property Value
An array of color series objects.
 
Syntax
PlotBrushes[int PlotIndex][int barsAgo]
 
Examples
// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				AddPlot(Brushes.Orange, ""SMA"");
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (IsFirstTickOfBar)
				priorSum = sum;
			
			sum			= priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
			Value[0]	= sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion//
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	public class SampleMultiColoredPlot : Indicator
	{
		private int 				period;	// Default setting for the SMA's period
		private Series<double>		middle;	// This DataSeries stores the average of a upper and lower SMA

		protected override void OnStateChange()
		{
			if(State == State.SetDefaults)
			{
				AddPlot(Brushes.SkyBlue, ""Upper"");
				AddPlot(Brushes.SkyBlue, ""Lower"");
				// Increase the default widths of the plots
				Plots[0].Width 		= 2;
				Plots[1].Width 		= 2;
				Calculate 			= Calculate.OnBarClose;
				IsOverlay 			= true;
				Name				= ""Sample multi-colored Plot"";
				Period 				= 14;
			}
			else if(State == State.Configure)
			{
				// Initialize the DataSeries.
				middle = new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			// Check that we have enough bars on our chart before processing
			if(CurrentBar < Period) 
				return;
			
			// Set the plots and the DataSeries.
 			Values[0][0] 	= SMA(High, Period)[0];
			Values[1][0]	= SMA(Low, Period)[0];
			middle[0] 		= (SMA(Low, Period)[0] + SMA(High, Period)[0]) / 2;
			
			// If the average of the two plots is rising, change the plot colors.
			if (IsRising(middle))
			{
				// The indexers for PlotBrushes are PlotBrushes[plot index][bars back], so the below code would set 
				// the first plot (Upper) to black and the second plot (Lower) to green.
				PlotBrushes[0][0] = Brushes.Black;
				PlotBrushes[1][0] = Brushes.LimeGreen;
			}
			// If the average is falling, change the plot colors.
			else if (IsFalling(middle))
			{
				PlotBrushes[0][0] = Brushes.Red;
				PlotBrushes[1][0] = Brushes.Black;
			}
			// If the average remains the same, set both plots to the same color.
			else
			{
				PlotBrushes[0][0] = Brushes.Blue;
				PlotBrushes[1][0] = Brushes.Blue;
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleMultiColoredPlot[] cacheSampleMultiColoredPlot;
		public SampleMultiColoredPlot SampleMultiColoredPlot(int period)
		{
			return SampleMultiColoredPlot(Input, period);
		}

		public SampleMultiColoredPlot SampleMultiColoredPlot(ISeries<double> input, int period)
		{
			if (cacheSampleMultiColoredPlot != null)
				for (int idx = 0; idx < cacheSampleMultiColoredPlot.Length; idx++)
					if (cacheSampleMultiColoredPlot[idx] != null && cacheSampleMultiColoredPlot[idx].Period == period && cacheSampleMultiColoredPlot[idx].EqualsInput(input))
						return cacheSampleMultiColoredPlot[idx];
			return CacheIndicator<SampleMultiColoredPlot>(new SampleMultiColoredPlot(){ Period = period }, input, ref cacheSampleMultiColoredPlot);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleMultiColoredPlot SampleMultiColoredPlot(int period)
		{
			return indicator.SampleMultiColoredPlot(Input, period);
		}

		public Indicators.SampleMultiColoredPlot SampleMultiColoredPlot(ISeries<double> input , int period)
		{
			return indicator.SampleMultiColoredPlot(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleMultiColoredPlot SampleMultiColoredPlot(int period)
		{
			return indicator.SampleMultiColoredPlot(Input, period);
		}

		public Indicators.SampleMultiColoredPlot SampleMultiColoredPlot(ISeries<double> input , int period)
		{
			return indicator.SampleMultiColoredPlot(input, period);
		}
	}
}

#endregion
Definition
Returns the first bar that matches the time stamp of the ""time"" parameter provided.  
 
 
 
Method Return Value
An int value representing an absolute bar index value.
 
Syntax
Bars.GetBar(DateTime time)
 
Parameters
 
 
Examples
Description
Returns the highest value over the specified period.
 
 
Syntax
MAX(int period)
MAX(ISeries<double> input, int period)
 
Returns default value
MAX(int period)[int barsAgo]
MAX(ISeries<double> input, int period)[int barsAgo]
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Example
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
Description
Returns the lowest value over the specified period.
 
 
Syntax
MIN(int period)
MIN(ISeries<double> input, int period)
 
Returns default value
MIN(int period)[int barsAgo]
MIN(ISeries<double> input, int period)[int barsAgo]
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Example
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Maximum shows the maximum of the last n bars.
	/// </summary>
	public class MAX : Indicator
	{
		private int		lastBar;
		private double	lastMax;
		private double	runningMax;
		private int		runningBar;
		private int		thisBar;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMAX;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMAX;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				AddPlot(Brushes.Green, ""MAX"");
			}
			else if (State == State.Configure)
			{
				lastBar		= 0;
				lastMax		= 0;
				runningMax	= 0;
				runningBar	= 0;
				thisBar		= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				runningMax	= Input[0];
				lastMax		= Input[0];
				runningBar	= 0;
				lastBar		= 0;
				thisBar		= 0;
				Value[0]	= Input[0];
				return;
			}

			if (CurrentBar - runningBar >= Period)
			{
				runningMax = double.MinValue;
				for (int barsBack = Math.Min(CurrentBar, Period - 1); barsBack > 0; barsBack--)
					if (Input[barsBack] >= runningMax)
					{
						runningMax = Input[barsBack];
						runningBar = CurrentBar - barsBack;
					}
			}

			if (thisBar != CurrentBar)
			{
				lastMax = runningMax;
				lastBar = runningBar;
				thisBar = CurrentBar;
			}

			if (Input[0] >= lastMax)
			{
				runningMax = Input[0];
				runningBar = CurrentBar;
			}
			else
			{
				runningMax = lastMax;
				runningBar = lastBar;
			}

			Value[0] = runningMax;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MAX[] cacheMAX;
		public MAX MAX(int period)
		{
			return MAX(Input, period);
		}

		public MAX MAX(ISeries<double> input, int period)
		{
			if (cacheMAX != null)
				for (int idx = 0; idx < cacheMAX.Length; idx++)
					if (cacheMAX[idx] != null && cacheMAX[idx].Period == period && cacheMAX[idx].EqualsInput(input))
						return cacheMAX[idx];
			return CacheIndicator<MAX>(new MAX(){ Period = period }, input, ref cacheMAX);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MAX MAX(int period)
		{
			return indicator.MAX(Input, period);
		}

		public Indicators.MAX MAX(ISeries<double> input , int period)
		{
			return indicator.MAX(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MAX MAX(int period)
		{
			return indicator.MAX(Input, period);
		}

		public Indicators.MAX MAX(ISeries<double> input , int period)
		{
			return indicator.MAX(input, period);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Minimum shows the minimum of the last n bars.
	/// </summary>
	public class MIN : Indicator
	{
		private int		lastBar;
		private double	lastMin;
		private double	runningMin;
		private int		runningBar;
		private int		thisBar;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMIN;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMIN;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				AddPlot(Brushes.Green, ""MIN"");
			}
			else if (State == State.Configure)
			{
				lastBar		= 0;
				lastMin		= 0;
				runningMin	= 0;
				runningBar	= 0;
				thisBar		= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (CurrentBar == 0)
			{
				runningMin  = Input[0];
				lastMin     = Input[0];
				runningBar  = 0;
				lastBar		= 0;
				thisBar		= 0;
				Value[0]	= Input[0];
				return;
			}

			if (CurrentBar - runningBar >= Period)
			{
				runningMin = double.MaxValue;
				for (int barsBack = Math.Min(CurrentBar, Period - 1); barsBack > 0; barsBack--)
					if (Input[barsBack] <= runningMin)
					{
						runningMin  = Input[barsBack];
						runningBar  = CurrentBar - barsBack;
					}
			}

			if (thisBar != CurrentBar)
			{
				lastMin = runningMin;
				lastBar = runningBar;
				thisBar = CurrentBar;
			}

			if (Input[0] <= lastMin)
			{
				runningMin = Input[0];
				runningBar = CurrentBar;
			}
			else
			{
				runningMin = lastMin;
				runningBar = lastBar;
			}

			Value[0] = runningMin;
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MIN[] cacheMIN;
		public MIN MIN(int period)
		{
			return MIN(Input, period);
		}

		public MIN MIN(ISeries<double> input, int period)
		{
			if (cacheMIN != null)
				for (int idx = 0; idx < cacheMIN.Length; idx++)
					if (cacheMIN[idx] != null && cacheMIN[idx].Period == period && cacheMIN[idx].EqualsInput(input))
						return cacheMIN[idx];
			return CacheIndicator<MIN>(new MIN(){ Period = period }, input, ref cacheMIN);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MIN MIN(int period)
		{
			return indicator.MIN(Input, period);
		}

		public Indicators.MIN MIN(ISeries<double> input , int period)
		{
			return indicator.MIN(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MIN MIN(int period)
		{
			return indicator.MIN(Input, period);
		}

		public Indicators.MIN MIN(ISeries<double> input , int period)
		{
			return indicator.MIN(input, period);
		}
	}
}

#endregion//
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	public class SampleGetHighLowByTimeRange : Indicator
	{ 
		protected override void OnStateChange()
		{
			
			if (State == State.SetDefaults)
			{
				Description					= @""Determines the highest high and lowest low in a specified time range"";
				Name						= ""Sample get high low by time range"";
				Calculate					= Calculate.OnBarClose;
				IsOverlay					= true;
				DisplayInDataBox			= true;
				DrawOnPricePanel			= true;
				DrawHorizontalGridLines		= true;
				DrawVerticalGridLines		= true;
				PaintPriceMarkers			= true;
				ScaleJustification 			= NinjaTrader.Gui.Chart.ScaleJustification.Right;
				StartHour					= 9;
				StartMinute					= 30;
				EndHour						= 10;
				EndMinute					= 15;
				AddPlot(Brushes.Green, ""HighestHigh"");
				AddPlot(Brushes.Red, ""LowestLow"");
			}
		}
		
		private DateTime startDateTime;
		private DateTime endDateTime;
		protected override void OnBarUpdate()
		{
			// Check to make sure the end time is not earlier than the start time
			if (EndHour < StartHour)
			    return;
			
			
			//Do not calculate the high or low value when the ending time of the desired range is less than the current time of the bar being processed
			if (ToTime(EndHour,EndMinute,0) > ToTime(Time[0]))
			    return;   
			
			

			// If the stored date time date is not the same date as the bar time date, create a new DateTime object
			if (startDateTime.Date != Time[0].Date)
			{
			    startDateTime = new DateTime(Time[0].Year, Time[0].Month, Time[0].Day, StartHour, StartMinute, 0);
			    endDateTime = new DateTime(Time[0].Year, Time[0].Month, Time[0].Day, EndHour, EndMinute, 0);	
			}

			// Calculate the number of bars ago for the start and end bars of the specified time range
			int startBarsAgo = Bars.GetBar(startDateTime);
			int endBarsAgo = Bars.GetBar(endDateTime);
			 
			/* Now that we have the start and end bars ago values for the specified time range we can calculate the highest high for this range
			 
			Note: We add 1 to the period range for MAX and MIN to compensate for the difference between ""period"" logic and ""bars ago"" logic.
			""Period"" logic means exactly how many bars you want to check including the current bar.
			""Bars ago"" logic means how many bars we are going to go backwards. The current bar is not counted because on that bar we aren't going back any bars so it would be ""bars ago = 0"" */
			double highestHigh = MAX(High, endBarsAgo - startBarsAgo  + 1)[CurrentBar - endBarsAgo];
			 
			// Now that we have the start and end bars ago values for the specified time range we can calculate the lowest low for this range
			double lowestLow = MIN(Low, endBarsAgo - startBarsAgo + 1)[CurrentBar - endBarsAgo];

			// Set the plot values
			HighestHigh[0] = highestHigh;
			LowestLow[0] = lowestLow;			
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> HighestHigh
		{
			get { return Values[0]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> LowestLow
		{
			get { return Values[1]; }
		}
		
		
		[Range(0,23)]
		[NinjaScriptProperty]
		[Display(Name=""Start hour"", Description = ""Enter start hour, Military time format 0 - 23"", Order=1, GroupName=""Parameters"")]
		public int StartHour
		{ get; set; }

		[Range(0, 59)]
		[NinjaScriptProperty]
		[Display(Name=""Start minute"", Description = ""Enter start minute(s) 0 - 59"",Order=2, GroupName=""Parameters"")]
		public int StartMinute
		{ get; set; }

		[Range(0, 23)]
		[NinjaScriptProperty]
		[Display(Name=""End hour"", Description = ""Enter end hour, Military time format 0 - 23"",Order=3, GroupName=""Parameters"")]
		public int EndHour
		{ get; set; }

		[Range(0, 59)]
		[NinjaScriptProperty]
		[Display(Name=""End minute"",Description = "" Enter end minute(s) 0 - 59"", Order=4, GroupName=""Parameters"")]
		public int EndMinute
		{ get; set; }

		#endregion

	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleGetHighLowByTimeRange[] cacheSampleGetHighLowByTimeRange;
		public SampleGetHighLowByTimeRange SampleGetHighLowByTimeRange(int startHour, int startMinute, int endHour, int endMinute)
		{
			return SampleGetHighLowByTimeRange(Input, startHour, startMinute, endHour, endMinute);
		}

		public SampleGetHighLowByTimeRange SampleGetHighLowByTimeRange(ISeries<double> input, int startHour, int startMinute, int endHour, int endMinute)
		{
			if (cacheSampleGetHighLowByTimeRange != null)
				for (int idx = 0; idx < cacheSampleGetHighLowByTimeRange.Length; idx++)
					if (cacheSampleGetHighLowByTimeRange[idx] != null && cacheSampleGetHighLowByTimeRange[idx].StartHour == startHour && cacheSampleGetHighLowByTimeRange[idx].StartMinute == startMinute && cacheSampleGetHighLowByTimeRange[idx].EndHour == endHour && cacheSampleGetHighLowByTimeRange[idx].EndMinute == endMinute && cacheSampleGetHighLowByTimeRange[idx].EqualsInput(input))
						return cacheSampleGetHighLowByTimeRange[idx];
			return CacheIndicator<SampleGetHighLowByTimeRange>(new SampleGetHighLowByTimeRange(){ StartHour = startHour, StartMinute = startMinute, EndHour = endHour, EndMinute = endMinute }, input, ref cacheSampleGetHighLowByTimeRange);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleGetHighLowByTimeRange SampleGetHighLowByTimeRange(int startHour, int startMinute, int endHour, int endMinute)
		{
			return indicator.SampleGetHighLowByTimeRange(Input, startHour, startMinute, endHour, endMinute);
		}

		public Indicators.SampleGetHighLowByTimeRange SampleGetHighLowByTimeRange(ISeries<double> input , int startHour, int startMinute, int endHour, int endMinute)
		{
			return indicator.SampleGetHighLowByTimeRange(input, startHour, startMinute, endHour, endMinute);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleGetHighLowByTimeRange SampleGetHighLowByTimeRange(int startHour, int startMinute, int endHour, int endMinute)
		{
			return indicator.SampleGetHighLowByTimeRange(Input, startHour, startMinute, endHour, endMinute);
		}

		public Indicators.SampleGetHighLowByTimeRange SampleGetHighLowByTimeRange(ISeries<double> input , int startHour, int startMinute, int endHour, int endMinute)
		{
			return indicator.SampleGetHighLowByTimeRange(input, startHour, startMinute, endHour, endMinute);
		}
	}
}

#endregion
Drawing text on a chart can be useful for outputting information, but when all information is displayed with the same font and size it could be difficult to quickly see the key information. Since NinjaScript is based on C#, it is possible to use Font objects to create more styles for your text
 
Key concepts in this example
•Drawing text on a chart
•Changing the font size on a chart
 
Important related documentation
•Text()
•SimpleFont()
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
SampleChangeFont_NT8.zip
Definition
Represents an interface that exposes information regarding a Text IDrawingTool.
 
Methods and Properties
 
 
 
Example
Definition
Defines a particular font configuration.  
 
 
 
Constructors
 
 
Methods and Properties
 
 
 
 
Examples
// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				AddPlot(Brushes.Orange, ""SMA"");
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (IsFirstTickOfBar)
				priorSum = sum;
			
			sum			= priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
			Value[0]	= sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion
"
Multiple Value Series Management.docx,"Modifying Existing NinjaTrader Windows
To modify an existing type of NinjaTrader window (for example, to add a button to all charts), you will first need to obtain a reference to each individual window of that type that is open. This can be done by overriding the OnWindowCreated() method, then declaring an object of the Type of the window you are looking for, and finally assigning the object a reference to the Window passed into the method:
 
 
If you are unsure of the Type name for a particular type of window, you can open an instance of that window then run the code below, which will print the Type to the Output Window:
 
 
Once you've obtained a reference to a window, you can then directly manipulate the WPF grids, controls, and other elements to customize its user interface or functionality. For example, if your goal was to add a new button to Chart Trader on all charts, you could use your reference to Chart objects to first locate their attached Chart Trader instances, then place a custom-defined button directly into the WPF grid used to lay out buttons in Chart Trader. Since this code would run within OnWindowCreated(), it would be applied to every Chart Trader instance that is open. You would not be changing the format used to create Chart Traders in the first place, but would rather be detecting every open instance and adding the buttons into them. This is an important distinction to make, because this approach requires that you also remove the elements you've added when each window is destroyed.
 
 
Since we are dynamically adding elements to open windows, it is important to clean up any unused resources and detach any event handlers when the affected windows are destroyed. You can use the same approach as shown above to obtain a reference to each affected window within the OnWindowDestroyed() method:
 
 
Below is another example of adding elements into chart windows. In this example, we add a new panel to the top of all chart windows, then take all existing chart content and move it into a row beneath the panel we've just added:
 
 
Accessing Account Data
From time to time, you may need to access certain global data, such as account values, order states, position info, etc. In these cases, you can subscribe to an appropriate event using a custom event handler method. Below is a list of a few such events which can be captured:
 
 
 
Accessing Market Data
Market data can be accessed via a BarsRequest object, which can provide real-time or snapshot data for use by your classes. A BarsRequest object can be loaded with a series of bar data without the need to actually draw bars on a chart. The BarsRequest object can then be accessed via the BarsUpdateEventArgs object passed into your event handler via the BarsRequest's Update method. The process for using a BarsRequest is as follows:
 
1.Instantiate an Instrument object
2.Instantiate and parameterize a BarsRequest object
3.Hook the BarsRequest's Update event to a custom event handler
4.Call the BarsRequest's Request() method
5.Access bars data directly from the BarsRequest object within your event handler method
 
The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
permalink
        Signature Changes Overview
permalink
        Name Changes Overview
permalink
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
Description
Camarilla pivots are a price analysis too that generates potential support and resistance levels by multiplying the prior range then adding or subtracting it from the close.
 
Syntax
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
 
Returns R1 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]
 
Returns R2 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]
 
Returns R3 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]
 
Returns R4 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R4[int barsAgo]
 
Returns S1 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]
 
Returns S2 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]
 
Returns S3 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]
Pivots(ISeries<double>input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]
 
Returns S4 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]
Pivots(ISeries<double>input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S4[int barsAgo]
 
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
 
Definition
Used to render custom drawing to a chart from various chart objects, such as an Indicator, DrawingTool or Strategy.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
 
}
 
 
 
Method Parameters
 
 
 
 
Examples
 
 
 
 
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
An event driven method which is called while the chart scale is being updated.  This method is used to determine the highest and lowest value that can be used for the chart scale and is only called when the chart object is set to IsAutoScale.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
You must override the method in your NinjaScript object with the following syntax:
 
public override void OnCalculateMinMax()
{
 
}
 
Method Parameters
This method does not accept any parameters.
 
Examples
Definition
Adds a Bars object for developing a multi-series (multi-time frame or multi-instrument) NinjaScript.
 
Related Methods and Properties
 
 
Syntax
The following syntax will add another Bars object for the primary instrument of the script.
AddDataSeries(BarsPeriod barsPeriod)
AddDataSeries(BarsPeriodType periodType, int period)
 
The following syntax allows you to add another Bars object for a different instrument to the script:
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period)
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period, MarketDataType marketDataType)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, int barsToLoad, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName) //only for R15 and higher
 
 
 
Parameters
 
 
 
 
Examples
 
 
The ChartScale class includes a range of properties related to the Y-Axis values of the ChartPanel on which the calling script resides.  The ChartScale can be configured to Right, Left, or Overlay.
 

 
Methods and Properties
Definition
The primary Bars object time frame (period type and interval).
 
 
 
Property Value
A Bars series object representing the time frame of the Bars.
 
Syntax
 
 
Examples
 
 
Definition
BarsRequest can be used to request Bars data and subscribe to real-time Bars data events.
 
 
 
Syntax
BarsRequest(Cbi.Instrument instrument, int barsBack)
BarsRequest(Cbi.Instrument instrument, DateTime fromLocal, DateTime toLocal)
 
Parameters
 
 
Methods and Properties
 
 
Examples
Definition
Represents various account variables used to reflect values the status of the account.  Each account connected in NinjaTrader will have it's own unique AccountItem values.
 
 
 
Syntax
AccountItem
 
Parameters
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Code Snippets can provide you with useful code templates to speed up your coding process.
        Understanding Code Snippet shortcuts
permalink
        How to use Code Snippet shortcuts via the keyboard
permalink
        How to insert Code Snippets via the mouse or F2 key
permalink
In C#, square brackets represent a way to access values stored within an collection. NinjaScript comes with quite a few collections that we call ISeries objects which could be accessed with square brackets. ISeries objects are linked to the underlying bars series in that they hold the same number of values as the number of bars on a chart. For example, to get the close price one bar ago, you would use Close[1] since the value of 1 within the square brackets represents the number of bars ago whose value you wish to reference. As another example, to get the high three bars ago, you would use High[3].
 
 
Many of NinjaTrader's indicators store their values in Series as well, generally in a Plot. Plots are essentially a Series<double> object and to retrieve values from them you need to specify which value you want to access. In most cases, you'd like the current value, so you could use SMA(14)[0], not just SMA(14). SMA(14) is the Indicator its self or Series, and you can't access its values by calling it directly. Using SMA(14)[0] retrieves the part of the Series you're interested in--the most current value.
 
 
Most of the time, you need an index value (number in the square brackets), but there are also cases when you need to use the ISeries instead. CrossAbove() and CrossBelow() are two key examples. If you look at the reference page for CrossAbove(), the two method signatures (overloads) look like this:
 
 
This means the first variable must always be a ISeries<double> object, and the second variable can be either another ISeries<double> or a double value (100, 70.25, etc). To specify a ISeries<double> object, you can just leave off the square brackets. For example if(CrossAbove(SMA(14), SMA(28), 1)) checks if the 14 period SMA has crossed above the 28 period SMA within the last bar. if(CrossAbove(SMA(14)[0], SMA(28)[0], 1)) would give you a compile error because it expects a ISeries<double> as input, not a double value (which is returned when an index is present).
 
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Kagi Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType)
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName)
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Point-and-Figure Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType)
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName)
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Returns the series value on the chart scale determined by a y pixel coordinate on the chart.
 
Method Return Value
A double value representing a series value on the chart scale.  This is normally a price value, but can represent indicator plot values as well.
 
Syntax
<chartScale>.GetValueByY(float y)
 
Method Parameters
 
 
Examples
 
 
In the image below, we pass a value of 1 for the y value, which tells us the pixel coordinate of 1 is located at a price of 2106.19 on the chart scale
 

Description
The correlation indicator will plot the correlation of the data series to a desired instrument. Values close to 1 indicate movement in the same direction. Values close to -1 indicate movement in opposite directions. Values near 0 indicate no correlation.
 
 
Syntax
Correlation(int period, string correlationSeries)
string correlationSeies(ISeries<double> input, int period, string correlationSeies)
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Order Flow Volumetric Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, string tradingHoursName, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, int sizeFilter, string tradingHoursName, bool? isResetOnNewTradingDay) (R17 and higher only)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Heiken Ashi Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType)
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName)
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Line Break Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
Examples
Definition
Returns the series value on the chart scale determined by a WPF coordinate on the chart.  
 
Method Return Value
A double value representing a series value on the chart scale.  This is normally a price value, but can represent indicator plot values as well.
 
Syntax
<chartScale>.GetValueByYWpf(double y)
 
Method Parameters
 
 
Examples
 
 
In the image below, we used the Chart Control property MouseDownPoint as the ""wpfy"" variable, which in return tells us the user clicked on a Y value of 2105.499 on the chart scale.
 

8.0.5.0 Release
March 6, 2017
 
 
8.0.5.1 Release
March 8, 2017
 
 
8.0.5.2 Release
March 15, 2017
 
Release Date
August 31st, 2016
 
This release marks our first NinjaTrader 8 Release Candidate.  Since the very first NinjaTrader 8 beta version, we have resolved over 4500 bugs thanks to the ongoing efforts of our beta community, and we feel confident we are closer than ever to a production NinjaTrader 8 release.  If you have installed a NinjaTrader 8 beta version and reported feedback to our support team - thank you!
 
As this is a release candidate, NinjaTrader 8.0.0.13 is still considered a beta product and we will continue to focus on product quality.  Please continue to report any issues you may encounter to our support staff.   We will monitor the status of this release to determine when we will announce and launch the production release of NinjaTrader 8.
 
 
 
Code Breaking Changes
Compile Errors
•The Stroke object .Dispose() method was removed due to technical redundancy.  To remove memory resources from any stroke objects, simply set the stroke to null.
•Removed property Bars.IsTimebased -> please use Bars.BarsType.IsTimeBased instead
•Account.Accounts was renamed to Account.All
 
Implementation changes
•The common signature ""isInclude60"" used in various SessionIterator methods was renamed to ""includesEndTimeStamp"" to be more specific
•Category display order values of standard NinjaTrader Property Grid Categories were updated to be more consistent application wide.  These changes could impact any customization you were doing using the CategoryOrderAttribute, however, the documentation was also updated to reflect the implementation more accurately and will allow you to use this attribute reliably.
•To assist with transitioning historical order objects to real-time order references, please use the new GetRealtimeOrder() method.
 
Notes
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Definition
Represents a change in fundamental data and is passed as a parameter in the OnFundamentalData() method.
 
Methods and Parameters
 
Examples
 
Tips
1.Not all connectivity providers support all FundamentalDataTypes.
2.EarningsPerShare on eSignal is a trailing twelve months value. On IQFeed it is the last quarter's value.
3.RevenuePerShare is a trailing twelve months value.
Definition
Represents a change in fundamental data and is passed as a parameter in the OnFundamentalData() method.
 
Methods and Parameters
 
Examples
 
Tips
1.Not all connectivity providers support all FundamentalDataTypes.
2.EarningsPerShare on eSignal is a trailing twelve months value. On IQFeed it is the last quarter's value.
3.RevenuePerShare is a trailing twelve months value.

"
Navigation.docx,"Definition
Informs the Strategy Analyzer how many iterations of optimizing it needs to do.
 
Property Value
An int value.
 
Syntax
NumberOfIterations
 
 
Examples
Definition
This method must be overridden in order to optimize a strategy. This method is called once per optimization run (not once per iteration).
 
Method Return Value
This method does not return a value.
 
Syntax
You must override the method in your Optimizer with the following syntax.
 
protected override void OnOptimize()
{
 
}
 
 
 
Examples
Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
Runs an iteration of backtesting for the optimizer
 
Method Return Value
This method does not return a value.
 
Syntax
RunIteration()
 
 
 
Examples
Definition
Informs the Strategy Analyzer if this Optimizer can do multi-objective optimizations.
 
Property Value
A bool value.
 
Syntax
SupportsMultiObjectiveOptimization
 
 
Examples
Definition
Informs the Strategy Analyzer if this Optimizer can do multi-objective optimizations.
 
Property Value
A bool value.
 
Syntax
SupportsMultiObjectiveOptimization
 
 
Examples
La optimización multi-objetivo lleva la optimización estándar un paso más allá al permitirle elegir múltiples objetivos para probar. Cuando se devuelven los resultados en lugar de una lista singular de los mejores resultados clasificados de mejor a menor, se le presentará un gráfico. Con objetivos múltiples, no hay un mejor resultado único, sino que depende del operador elegir cuál es la mejor compensación entre dos objetivos. Para ejecutar una optimización de objetivos múltiples, necesitará:
 
•Acceso a datos históricos.
•Costumbre NinjaScript * estrategia
•Una comprensión profunda de las capacidades de backtesting y optimización de Strategy Analyzer
 
 
 
        Cómo ejecutar una optimización de objetivos múltiples 
permalink
 
        Comprender las propiedades de varios objetivos
permalink
 
        Comprender los resultados de múltiples objetivos
permalink
 
Comprender los datos proporcionados por su proveedor de conectividad
NinjaTrader, LLC no es un proveedor de datos de mercado. Nuestros proveedores de conectividad proporcionan datos históricos que ofrecen datos históricos como parte de su servicio. La siguiente tabla muestra todos los proveedores de conectividad compatibles con NinjaTrader, así como los datos históricos y en tiempo real proporcionados por cada uno:
 
 
 
C = CFD
CC = CryptoCurrency
E = Acciones
F = Futuros
FX = Forex
I = Índices
O = Opciones
 
Convertir datos en tiempo real en datos históricos
NinjaTrader por defecto siempre cargará datos históricos de su proveedor (Recomendado). Sin embargo, si habilita la opción 'Grabar datos en vivo como históricos' en el Centro de control > Herramientas > Opciones > Categoría de datos de mercado, NinjaTrader almacenará los datos entrantes en tiempo real en su PC local si tiene un Gráfico o un Analizador de mercado (debe tener una ventana indicadora agregada) ventana abierta. Estos datos se pueden usar como datos históricos. Por ejemplo, si abre un gráfico y deja que se ejecute todo el día, los datos recopilados hoy estarán disponibles como datos históricos cuando abra el mismo gráfico mañana.
 
 
 
Conexión simultánea con su corredor y un proveedor de datos de mercado
Si la tecnología de su corredor no admite datos históricos, puede conectarse a un servicio como Kinetick al mismo tiempo que se conecta a su corredor para que pueda recibir datos históricos. Consulte el tema sobre Conexiones múltiples para obtener información adicional.
Definition
A custom TypeConverter class handling the designed behavior of a strategy's property descriptor collection.  Use this as a base class for any custom TypeConverter you are applying to a strategy class.
 
 
 
Relevant base methods
 
 
Syntax
public class StrategyBaseConverter : TypeConverter
 
 
 
 
 
Examples
Definition
The SystemPerformance object holds all trades and trade performance data generated by a strategy.
 
 
Methods and Properties
 
 
Examples
 
The methods and properties covered in this section are unique to custom strategy development.
 
In this section
Definition
Represents the real-world or simulation Account configured for the strategy.
 
Property Value
An Account object configured for the strategy
 
Syntax
Account
 
Examples
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
Definition
Adds an instance of custom Performance Metric to a strategy used in strategy calculations.
 
Method Return Value
This method does not return a value.
 
Syntax
AddPerformanceMetric(PerformanceMetricBase performanceMetric)
 
 
 
Parameters
 
 
 
Examples
 
Definition
The number of historical bars required before the strategy starts processing order methods called in the OnBarUpdate() method. This property is generally set via the UI when starting a strategy.
 
 
 
Property Value
An int value representing the number of historical bars.  Default value is set to 20.
 
 
 
Syntax
BarsRequiredToTrade
 
 
 
Examples
 
 
 
 
Definition
Cancels all working orders, closes any existing positions, and finally disables the strategy.  This behavior can also be overridden for a given strategy if desired.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
CloseStrategy(string signalName)
 
 
 
You may choose to override this method using the following syntax:
 
public override void CloseStrategy(string signalName)
{
 
}
 
 
Parameters
 
 
 
Examples
 
 
Definition
Determines if the strategy will save orders, trades, and execution history. When this property is set to false you will see significant memory savings at the expense of having access to the detailed trading information.
 
 
 
Property Value
This property returns true if the strategy will include trade history; otherwise, false. Default is set to true.  Always false during a strategy analyzer optimization on a 32-bit process.
 
 
 
Syntax
IncludeTradeHistoryInBacktest
 
Examples
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Definition
Represents a read only interface that exposes information regarding an order.
 
•An Order object returned from calling an order method is dynamic in that its properties will always reflect the current state of an order
•The property <Order>.OrderId is NOT a unique value, since it can change throughout an order's lifetime.  Please see the Advance Order Handling section on ""Transitioning order references from historical to live"" for details on how to handle.
•The property <Order>.Oco WILL be appended with a suffix when the strategy transitions from historical to real-time to ensure the OCO id is unique across multiple strategies for live orders
•To check for equality you can compare Order objects directly
 
Methods and Properties
 
 
OrderState Values
 
 
Examples
Definition
The SystemPerformance object holds all trades and trade performance data generated by a strategy.
 
 
Methods and Properties
 
 
Examples
 
Definition
A TradeCollection object of all trades generated by a strategy.
 
Syntax
SystemPerformance.AllTrades
 
Examples
Definition
LongTrades is a TradeCollection object of long trades generated by a strategy.
 
Syntax
SystemPerformance.LongTrades
 
Examples
Definition
RealTimeTrades is a TradeCollection object of real-time trades generated by a strategy.
 
Syntax
SystemPerformance.RealTimeTrades
 
 
Examples
Definition
ShortTrades is a TradeCollection object of short trades generated by a strategy.
 
Syntax
SystemPerformance.ShortTrades
 
 
Examples
 
Definition
A collection of Trade objects. You can access a trade object by providing an index value. Trades are indexed sequentially meaning the oldest trade taken in a strategy will be at an index value of zero. The most recent trade taken will be at an index value of the total trades in the collection minus 1.
 
Methods and Properties
 
 
Examples
 
 
 
Definition
A collection of Trade objects. You can access a trade object by providing an index value. Trades are indexed sequentially meaning the oldest trade taken in a strategy will be at an index value of zero. The most recent trade taken will be at an index value of the total trades in the collection minus 1.
 
Methods and Properties
 
 
Examples
 
 
 
Definition
A collection of Trade objects. You can access a trade object by providing an index value. Trades are indexed sequentially meaning the oldest trade taken in a strategy will be at an index value of zero. The most recent trade taken will be at an index value of the total trades in the collection minus 1.
 
Methods and Properties
 
 
Examples
 
 
 
Definition
A collection of Trade objects. You can access a trade object by providing an index value. Trades are indexed sequentially meaning the oldest trade taken in a strategy will be at an index value of zero. The most recent trade taken will be at an index value of the total trades in the collection minus 1.
 
Methods and Properties
 
 
Examples
 
 
 
Definition
A Trade is a completed buy/sell or sell/buy transaction. It consists of an entry and exit execution.
 
 
 
 
In the second example above, two trade objects are created to represent each individual trade. Each trade object will hold the same entry execution for two contracts since this single execution was the opening execution for both individual trades.
 
 
Methods and Properties
 
 
Examples




"
NinjaScript Indicator Base Class Reference.docx,"Definition
A custom TypeConverter class handling the designed behavior of an indicator's property descriptor collection.  Use this as a base class for any custom TypeConverter you are applying to an indicator class.
 
 
 
Relevant base methods
 
 
Syntax
public class IndicatorBaseConverter : TypeConverter
 
 
 
 
 
Examples
The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
permalink
        Signature Changes Overview
permalink
        Name Changes Overview
permalink
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
Understanding the SharpDX .NET Library
NinjaTrader Chart objects (such as Indicators, Strategies, DrawingTools, ChartStyles) implement an OnRender() method aimed to render custom lines, shapes, and text to the chart.  To achieve the level of performance required to keep up with market data events, NinjaTrader uses a 3rd-party open-source .NET library named SharpDX.  This 3rd party library provides a C# wrapper for the powerful Microsoft DirectX API used for graphics processing and known for its hardware-accelerated performance, including 2D vector and text layout graphics used for NinjaTrader Chart Rendering.  The SharpDX/DirectX library is extensive, although NinjaTrader only uses a handful of namespaces and classes, which are documented as a guide in this reference.  In addition to this educational resource, we have also compiled a more focused collection of SharpDX SDK Reference resources to help you learn the SharpDX concepts used in NinjaTrader Chart Rendering.
 
 
There are three main SharpDX namespaces you need to be familiar with:
 
 
The rest of this page will help you navigate the fundamental concepts needed to achieve custom rendering to your charts.
        SharpDX Vectors and Charting Coordinates
permalink
        SharpDX Brush Resources
permalink
        SharpDX RenderTarget
permalink
        SharpDX Lines and Shapes
permalink
        SharpDX Text Rendering
permalink
        SharpDX Stroke Style
permalink
         Best Practices for SharpDX Resources
permalink
Definition
A custom TypeConverter class handling the designed behavior of a strategy's property descriptor collection.  Use this as a base class for any custom TypeConverter you are applying to a strategy class.
 
 
 
Relevant base methods
 
 
Syntax
public class StrategyBaseConverter : TypeConverter
 
 
 
 
 
Examples
Definition
Binds an object or property to a specific TypeConverter implementation.  This is commonly used to customize property descriptors on the NinjaTrader property grid.
 
 
 
Syntax
TypeConverterAttribute(string)
TypeConverterAttribute(type)
 
Examples
The default behavior of the NinjaTrader 8 property grid is designed to handle the most basic display of your custom Indicator and Strategy properties. However, there are special cases where you may want to control how unique properties display to other users. Since using a TypeConverter is more of a general C# concept used to convert values between data types (a string to an enum for example), so the possibilities of what you can do are within the bounds of the .NET Framework. This NinjaScript sample was produced to help NinjaScript developers understand how to leverage the IndicatorBaseConverter and StrategyBaseConverter helper classes to customize property grid behavior without affecting general NinjaTrader 8 property behavior.
 
Note
•NinjaTrader 8 expects custom properties to be of value type or type which implements ICloneable interface
•This reference sample assumes you are familiar with basic C# TypeConverter practices and is intended as a starting point. There are extensive 3rd party guides available online which can help you implement a particular type converter goal not covered in this sample
 
Key concepts in this example
There are 5 use cases demonstrated in this sample which fall into two different categories:
 
1. Dynamically manipulate what is displayed on the UI Property Grid
a.Show / hide properties based on secondary input
b.Disable / enable properties based on secondary input
 
2. Customizing how a property is displayed
a.Display ""Friendly"" enum values
b.Re-implement a ""bool"" CheckBox as ""Friendly"" a ComboBox
c.Display a custom collection / list with user defined values at run time
 
Important related documentation
C#
•ICloneable Interface
•PropertyDescriptor Class
•RefreshPropertiesAttribute
•TypeConverter Class
•DisplayAttribute Class
NinjaTrader
•IndicatorBaseConverter Class
•StrategyBaseConverter Class
•TypeConverterAttribute
 
 
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
Additional resources
MSDN - How to: Implement a Type Converter
 
SampleIndicatorTypeConverter_NT8.zip
Multi-Series Scripting Overview
NinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.
 
 
It is also important that you understand the following method and properties:
 
•AddDataSeries()
•BarsArray
•BarsInProgress
•CurrentBars
 
        Working With Multi-Time Frame Objects
permalink
        Adding Additional Bars Objects to NinjaScript
permalink
        Creating Series<T> Objects
permalink
        How Bars Data is Referenced
permalink
        Using Bars Objects as Input to Indicator Methods
permalink
        True Event Driven OnBarUpdate() Method
permalink
        Accessing the Price Data in a Multi-Bars NinjaScript
permalink
        Entering, Exiting and Retrieving Position Information
permalink
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•""UI"" instances representing its default properties on various user interfaces
•The ""configured"" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select ""Indicator""
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses ""Apply"" or ""OK""
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of ""Available"" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of ""Available"" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the ""Properties"" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd ""configured"" instance you are concerned with developing, but you should also be aware of the ""UI"" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or ""Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
Description
The ZigZag indicator highlights trends based on user defined threshold values and helps filtering the noise in price charts, it's not a classical indicator but more a reactive filter showing extreme price points. In processing it's calculations it can update it's current direction and price extreme point based on newly incoming data, the current developing leg should be thought of temporary until a new leg in opposite direction has been set.
 
You can access methods within this indicator to determine the number of bars ago a zigzag high or low point occurred or the current zigzag value, it is only meaningful to work with in Calculate.OnBarClose mode for the Calculate property.
 
 
Syntax - Bars Ago
High Bar
ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow).HighBar(int barsAgo, int instance, int lookBackPeriod)
ZigZag(ISeries<double> input, DeviationType deviationType, double deviationValue, bool useHighLow).HighBar(int barsAgo, int instance, int lookBackPeriod)
 
Low Bar
ZigZag(DeviationType deviationType, double deviationValue, bool useHighLow).LowBar(int barsAgo, int instance, int lookBackPeriod)
ZigZag(ISeries<double> input, DeviationType deviationType, double deviationValue, bool useHighLow).LowBar(int barsAgo, int instance, int lookBackPeriod)
 
Return Value
An int value representing the number of bars ago. Returns a value of -1 if a swing point is not found within the look back period.
 
 
Syntax - Value
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
* A return value of 0 (zero) indicates that a zigzag high or low has not yet formed.
 
 
Parameters
 
 
Example
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
The OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method called for indicator calculation, and we will calculate the CCI value and set the conditions used to draw the CCI plot within this method.
 
The OnStateChange() method is called once before any bar data is loaded, and is used to configure the indicator (among other things).
 
Initializing the Indicator
The code below is automatically generated by the wizard and added to the OnStateChange() method, within State.SetDefaults. It configures the indicator for one plot and five lines, and sets the parameters entered in the wizard:
 
 
To change the visual properties of the Zero Line, replace the third line in the code above with the line below. This will change the color to black and the line style to ""dash:""
 
 
The code above uses an alternative method overload (an alternative set of arguments passed in to the AddLine() method), in order to pass in a Stroke object rather than a Brush. With a Stroke, not only can we still specify a Brush, but we have additional options to change the dash style (via DashStyleHelper) and the line width. After this change, your configured lines and plots should look like this:
 
 
Adding Core Indicator Logic
Since this tutorial is meant to cover custom drawing and manually changing properties within an indicator, we will not go too in-depth into the core calculation logic for this custom CCI. Instead, we will copy and paste the core calculation logic from the @CCI indicator already built-in to NinjaTrader.
 
The @CCI indicator uses an SMA object in its calculations. To add this, copy the line below from @CCI into your custom CCI, directly below the class declaration:
 
 
Next, copy the following initialization for the SMA object into the OnStateChange() method, within State.Configure:
 
 
Next, copy the core calculation logic from @CCI into the OnBarUpdate() method of your custom indicator:
 
 
The code for your MyCCI class should now look as follows (in addition to the using statements and class declaration) :
 
 
Custom Drawing
Add the following code into the OnBarUpdate() method, directly beneath the core calculation logic:
 
 
This will conditionally change the color of the CCI plot (referenced by Values[0]) based on its value. By using PlotBrushes[0][0], we are specifying that we wish to change the color of the first plot in the collection at a specific bar index (the current bar index each time the condition is triggered), and we wish for the plot the remain that color at that index, even if the plot value changes in the future. If instead we wished to change the entire plot color, we could use Plots[0].Brush.
 
PlotBrushes holds a collection of brushes used for the various plots in the indicator. In addition to this, there are several other collections that serve similar purposes, which can be used in the same way. Some examples of these collections are below:
 
 
Now that everything is in place, your class code should look as below. You are now ready to compile the indicator and configure it on a chart.
 
 
 
Definition
Represents an object that can receive drawing commands.
(See also unmanaged API documentation)
 
Syntax
class RenderTarget
 
 
 
Methods and Properties

"
NinjaScript Lifecycle.docx,"NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•""UI"" instances representing its default properties on various user interfaces
•The ""configured"" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select ""Indicator""
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses ""Apply"" or ""OK""
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of ""Available"" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of ""Available"" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the ""Properties"" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd ""configured"" instance you are concerned with developing, but you should also be aware of the ""UI"" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or ""Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
Determines how often OnBarUpdate() is called for each bar. OnBarClose means once at the close of the bar. OnEachTick means on every single tick. OnPriceChange means once for each price change. If there were two ticks in a row with the same price, the second tick would not trigger OnBarUpdate(). This can improve performance if calculations are only needed when new values are possible.
 
 
 
Property Value
An enum value determining the how frequently OnBarUpdate() will be called.  Default value is set to Calculate.OnBarClose
 
 
 
Syntax
Calculate.OnBarClose
Calculate.OnEachTick
Calculate.OnPriceChange
 
 
 
Examples
Definition
Represents the current progression of the object as it advances from setup, processing data, to termination.  These states can be used for setting up or declaring various resources and properties.
 
 
 
Property Value
An enum value representing the current state of the object.  Possible values are:
 
Syntax
State
 
 
 
Examples
 
 
 
¿Qué es la repetición de tick?
La repetición de marca es una propiedad que se puede habilitar opcionalmente en los indicadores y estrategias de NinjaScript que asegurarán que los datos del mercado (oferta / demanda / última) que se introdujeron en la construcción de una barra se carguen en la secuencia exacta de eventos de datos del mercado.  Esto garantiza que sus indicadores y estrategias se calculen históricamente tic por tic exactamente como lo hubieran sido si el indicador / estrategia se ejecutara en vivo durante un período. La repetición de marca puede habilitarse para los indicadores utilizados en Gráficos , Analizadores de mercado y Estrategias .
 
 
 
 
 
Los indicadores y las estrategias solo podrán aprovechar la repetición de ticks si se han programado explícitamente para calcular estos eventos de datos de mercado.  Si usted es un programador y le gustaría aprender cómo utilizar Tick Replay con las secuencias de comandos personalizados, consulte la repetición de garrapatas utilizando la sección de nuestra guía de ayuda NinjaScript.
 
Configuración de repetición de marca
Por defecto, la repetición de marca no estará habilitada.  Para exponer esta propiedad para sus indicadores y estrategias, primero deberá activar la opción de repetición de marca global:
 
•Vaya al menú Centro de control > Herramientas > Opciones y, en la categoría Datos de mercado , marque "" Mostrar reproducción de marca""
 

 
Una vez que se haya habilitado la opción "" Mostrar reproducción de tick "" en la categoría Datos de mercado del menú Opciones, encontrará una opción de "" Reproducción de tick "" que puede seleccionar al configurar sus indicadores o estrategias, o al ejecutar una estrategia en la Estrategia analizador .
 
 
 

Multi-Series Scripting Overview
NinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.
 
 
It is also important that you understand the following method and properties:
 
•AddDataSeries()
•BarsArray
•BarsInProgress
•CurrentBars
 
        Working With Multi-Time Frame Objects
        Adding Additional Bars Objects to NinjaScript
        Creating Series<T> Objects
        How Bars Data is Referenced
        Using Bars Objects as Input to Indicator Methods
        True Event Driven OnBarUpdate() Method
        Accessing the Price Data in a Multi-Bars NinjaScript
        Entering, Exiting and Retrieving Position Information
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Renko Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType)
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName)
AddRenko(string instrumentName, int brickSize, Data.MarketDataType marketDataType, string tradingHoursName, bool?isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Order Flow Volumetric Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, string tradingHoursName, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, int sizeFilter, string tradingHoursName, bool? isResetOnNewTradingDay) (R17 and higher only)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Line Break Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
Examples
Historical Bid/Ask Series Overview
NinjaTrader has the ability to use historical bid and ask price series in your NinjaScript instead of only being able to use a last price series. The following outlines the intricacies of this capability:
 
 
 
Accessing Bid/Ask Series
When calling AddDataSeries() to add an additional Bars object to your script, a constructor overload will be available which takes a MarketDataType enumeration as an argument. This will allow you to specify the price series which will be used in that particular object. If you were to pass in MarketDataType.Ask or MarketDataType.Bid, as in the example below, that particular data series will use that price type for all of its PriceSeries collections, such as Close, Open, High, and Low.
 
 
Example
Definition
Holds an array of int values representing the number of the current bar in a Bars object. An int value is added to this array when calling the AddDataSeries() method. Its purpose is to provide access to the CurrentBar of all Bars objects in a multi-instrument or multi-time frame script.
 
 
 
Property Value
An array of int values.
 
 
 
Syntax
CurrentBars[int barSeriesIndex]
 
Examples
 
 
Definition
The number of bars on a chart required before the script plots.
 
 
 
Property Value
An int value that represents the minimum number of bars required.
 
Syntax
BarsRequiredToPlot
 
Examples
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
The primary Bars object time frame (period type and interval).
 
 
 
Property Value
A Bars series object representing the time frame of the Bars.
 
Syntax
 
 
Examples
 
 
Definition
Determines how often OnBarUpdate() is called for each bar. OnBarClose means once at the close of the bar. OnEachTick means on every single tick. OnPriceChange means once for each price change. If there were two ticks in a row with the same price, the second tick would not trigger OnBarUpdate(). This can improve performance if calculations are only needed when new values are possible.
 
 
 
Property Value
An enum value determining the how frequently OnBarUpdate() will be called.  Default value is set to Calculate.OnBarClose
 
 
 
Syntax
Calculate.OnBarClose
Calculate.OnEachTick
Calculate.OnPriceChange
 
 
 
Examples
Definition
The total number of bars or data points.
 
Property Value
An int value representing the the total number of bars.
 
Syntax
Count
 
 
Examples
 
 
Definition
A number representing the current bar in a Bars object that the OnBarUpdate() method in an indicator or strategy is currently processing. For example, if a chart has 100 bars of data, the very first bar of the chart (left most bar) will be number 0 (zero) and each subsequent bar from left to right is incremented by 1.
 
 
 
Property Value
An int value that represents the current bar.
 
Syntax
CurrentBar
 
 
Examples
Definition
Indicates if the incoming tick is the first tick of a new bar. This property is only of value in scripts that run tick by tick which is when the Calculate property is set to Calculate.OnEachTick or Calculate.OnPriceChange.
 
 
 
 
 
Property Value
This property returns true if the incoming tick is the first tick of a new bar; otherwise, false.
 
Syntax
IsFirstTickOfBar
 
 
Examples
Definition
Determines if the specified bar series is using Break at EOD
 
 
Property Value
A bool[] when true, indicates the specified BarsArray is setup to run Break at EOD; otherwise false.  Default value is false
 
Syntax
IsResetOnNewTradingDays[int idx]
 
 
 
Examples
Definition
Indicates the specified bar series is using Tick Replay.   Please see the help guide topic on using Tick Replay for general information on this mode.
 
 
 
 
 
Property Value
A bool[] when true, indicates the specified BarsArray is setup to run Tick Replay; otherwise false.  Default value is false
 
Syntax
IsTickReplays[int idx]
 
 
Examples
Definition
Forces the OnBarUpdate() method to be called so that indicator values are updated to the current bar.  If the values are already up to date, the Update() method will not be run.
 
 
When indicators are embedded (called) within a NinjaScript strategy, they are optimized to calculate only when they are called upon in a historical backtest. Since the NinjaTrader indicator model is very flexible, it is possible to create public properties on a custom indicator that return values of internal user defined variables. If these properties require that the OnBarUpdate() method is called before returning a value, include a call to this Update() method in the property getter.
 
Syntax
Update()
 
Parameters
 
 
Examples
Definition
An index value of the current Bars object that has called the OnBarUpdate() method. In a multi-bars script, the OnBarUpdate() method is called for each Bars object of a script. This flexibility allows you to separate trading logic from different bar events.
 
 
 
Property Value
An int value represents the Bars object that is calling the OnBarUpdate() method.
 
Syntax
BarsInProgress
 
 
Examples
AddOn Development Basics
The NinjaScript AddOn framework provides functionality reaching across the NinjaTrader platform while granting access to certain core methods and properties not contained within the NinjaScript namespace. In addition to creating your own independent window or modifying the user interface and functionality of existing NinjaTrader windows (charts, etc.), AddOns can also subscribe to live market data, access account information, and more.
 
 
NinjaScript Editor Development Environment (NinjaScript Basic)
The NinjaScript Editor can be used to create and write custom AddOns in C#
 
Pros
•Use the familiar NinjaScript editor (if you are uncomfortable with Visual Studio)
•Changes to the AddOn are reflected immediately upon NS Editor Compile and does not require restart
 
Cons
•If you wish to design a custom NTWindow, XAML files cannot be edited in the NinjaScript editor.
•NinjaScript editor lacks support of common development and debugging tools available in an IDE's like Visual Studio
 
Below is a NinjaScript Editor compatible zip file (which also contains a XAML file)
•Download AddOn Framework NinjaScript Basic file to your desktop
•From the Control Center window select the menu Tools > Import > NinjaScript
•Select the downloaded file
 
Once imported, the AddOn can be launched via the New menu in the Control Center
 
AddOn Development Environment (Visual Studio Advanced)
Since AddOns can include multiple classes, unique user interfaces, and various file types (XAML, sounds, etc.), the recommended development environment for AddOns differs from other NinjaScript Types. Following the guidelines below to set up an AddOn development environment can help to streamline the process.
 
Pros
•Use Visual Studio or a comparable IDE to create a solution linking all project files together
•Use your IDE to build a DLL, rather than exporting through NinjaTrader
•This will allow you to bundle XAML and other files into the DLL
•Set a post-build event to place the DLL into the appropriate folder (NinjaTrader 8/bin/Custom)
•Set a Debug Start Action to launch NinjaTrader
 
Cons
•NinjaTrader needs to be restarted in order to re-load the compiled DLL after changes
 
If you use this setup and build a DLL with your IDE, the IDE will automatically place it where it needs to be and immediately launch the platform for testing any changes.
 
Below is a complete Visual Studio project with this setup in place. Simply unzip the contents of this archive to your desired location, then open the ""NinjaTraderAddOnProject.sln"" solution in Visual Studio.
 
Download Visual Studio Solution for AddOn Development
 
 
Creating Your Own AddOn Window
NinjaScript developers can utilize the AddOn framework to create free-standing, independent windows to provide custom functionality. Helper classes are available in the framework to instantiate windows styled the same as pre-built NinjaTrader windows, including familiar functionality such as window linking, the tabbed interface, and the ability to save the window and its state in workspaces. In addition, general WPF user interface elements and XAML can be used to style and modify windows using the .NET framework.
 
For a detailed walkthrough of creating your own window using NinjaScript helper classes, see the Creating Your Own AddOn Window page.
 

 
The image above shows a completely new window created by a custom AddOn.
 
Other Uses for an AddOn
An AddOn does not require its own window to function. It can instead be used to accomplish non-UI-driven functionality across the platform, such as monitoring market data or accessing account, position, and order information. AddOns can also be used to add functionality or interface elements to other NinjaTrader windows, such as charts.
 
For detailed information on other common uses of an AddOn, see the Other Uses for an AddOn page.
 

 
In the image above, the custom ""Sample button"" button has been drawn on a chart window using an AddOn.
Overview
The NinjaScript Editor is a powerful scripting editor that allows you to create custom indicators, strategies, and any other custom NinjaScript types used to enhance the NinjaTrader platform.  The NinjaScript Editor can be opened by selecting the New menu from the NinjaTrader Control Center. Then left mouse click on the menu item NinjaScript Editor
 
1. NinjaScript Explorer - Displays files, folders, and allows for additional file management
2. Tool bar - Moving your mouse over each icon will display the function of the icon button
3. Line numbers
4. Line modification marking - Yellow flags indicate unsaved line modifications where green flags indicate saved modifications
5. Tabs for creating new scripts via the NinjaScript wizard and working on multiple scripts.
 
    
 
Properties and Definitions
 

 
 
The NinjaScript Explorer provides a Folder view of all the supported NinjaScript categories that can be developed in NinjaTrader.  
        Understanding the NinjaScript Explorer display
permalink
        Managing scripts and folders
        Excluding a script from compilation
When compiling a custom indicator or strategy it is possible and likely that you will generate compile errors.
•NinjaTrader will compile ALL NinjaScript files NOT only the file you are working on
•A list of compile errors for all files will be displayed in the lower portion of the NinjaScript Editor
•Double click on an error to load the problem file and highlight the problem area
•Click on the error code to bring up Help Documentation on a specific error
•Right click on the error to exclude the problem file from compilation (see the section on Excluding a script from compilation for more information)
 
The image below illustrates a compile error
1. Section where compile errors are displayed. Errors in the current loaded file are color coded a light color while errors in other files have a darker color code.
2. The file that contains the error
3. A description of the error
4. A error code link that will open the Help Guide with any relevant error code information
5. Line number and column number of the error
6. Error is underlined with a red wavy line
 
The error highlighted by icon (6) below shows that the expression is not closed with a semicolon. The expression should be:
 
double myValue = SMA(20)[0];
 

You can debug your NinjaScript objects using Microsoft Visual Studio. NinjaScript objects are compiled into a single DLL, named ""NinjaTrader.Custom.dll."" When debugging, a special debug DLL is created for temporary use, with the same name as the release version.
 
 
Using Visual Studio Debugging
1. In the NinjaScript Editor, enable ""Debug Mode"" via the right-click menu, as seen in the image below. After this, compile your scripts to create the debug DLL.
 

 
2. From the NinjaScript Editor, click on the Visual Studio icon  from the tool bar, which will automatically load the NinjaTrader.Custom project with your installed version of Visual Studio.
 
3. In Visual Studio, select Debug, then select Attach to Process
 

 
4. Select NinjaTrader from the list of processes, then select Attach. Be sure the ""Attach to"" field is set to ""Automatic: Managed code"" or ""Managed code"".
 

 
4. Open the NinjaScript source file within Microsoft Visual Studio and set your break point(s)
 

 
5. Run your NinjaScript object in NinjaTrader and it should stop at your break points and all the debugging tools and information should be available to inspect the current state of the code.
 
The following CS0234 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when an imported DLL (could be a 3rd party indicator) you are referencing no longer exists / has been removed.
 
To resolve this the DLL must be re-imported.
 
To re-import a 3rd party dll:
1.Open the NinjaScript Editor via New > NinjaScript editor.
2.Right mouse click in the NinjaScript Editor main window and select the menu name ""References""
3.In the ""References"" dialog window press the button ""Add""
4.Select the 3rd party DLL
 
 
Error Descriptions
The type or namespace name '<name>' could not be found (are you missing a using directive or an assembly reference?)
The type or namespace name '<name>' does not exist in the namespace 'NinjaTrader.Indicator' (are you missing an assembly reference?)
The following CS0019 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
Strings cannot be compared with relational operators (<, >, <=, >=, ==, !=) to other object types. Strings can only be compared to other strings and only through the use of equality operators (==, !=).
 
Error Description #1
Operator '==' cannot be applied to operands of type 'string' and 'int'
 
// Erroneous Sample Code – Cannot compare a string to an integer
if (""string"" == 5)
 
// Resolution Sample Code – Compare a string with another string
if (""string"" == intValue.ToString());
 
Error Description #2
Operator ‘<’ cannot be applied to operands of type ‘string’ and ‘double’
 
// Erroneous Sample Code - Cannot compare a string to a double
if (""string"" >= 1.2)
 
// Resolution Sample Code - Testing to see if the strings are not the same
if (""string"" != ""string2"")
 
Error Description #3
Operator ‘>’ cannot be applied to operands of type ‘string’ and ‘string’
 
// Erroneous Sample Code - Cannot quantitatively compare a string to another string
if (""string"" > ""string2"")
 
// Resolution Sample Code - Testing to see if both strings are the same
if (""string"" == ""string2"")
 
Additional Error Descriptions
Operator ‘<’ cannot be applied to operands of type ‘string’ and ‘string’
Operator ‘<=’ cannot be applied to operands of type ‘string’ and ‘string’
Operator ‘>=’ cannot be applied to operands of type ‘string’ and ‘string’
The following CS0021 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect.  In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This is a common error when calling indicators methods. It occurs when an indicator is called without its required parameter arguments before accessing an indexed value.
 
To fix this error you will need to first pass to the indicator method all the necessary parameter arguments. You can do this with '()' after the indicator name. Please note that you will still need to pass an empty parameter argument list even if your indicator requires no arguments.
 
Error Description #1
Cannot apply indexing with [] to an expression of type 'method group'
 
Example #1
// Erroneous Sample Code - SMA is an indicator and requires parameter arguments
double value = SMA[0];
 
// Resolution Sample Code - SMA() properly called
double value = SMA(14)[0];
 
Example #2
// Erroneous Sample Code - EMA is an indicator and requires parameter arguments
double maDelta = EMA[0] - EMA[1];
 
// Resolution Sample Code - SMA() properly called with an overload method (one of several variations)
double maDelta = EMA(High, 14)[0] - EMA(High, 14)[1];
The following CS0103 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
When a variable is used before declaration, the compiler will not know what it is. This error is also commonly invoked by typos.
 
Please ensure that you have declared your variables prior to using them. If variables are declared or properties already exist, please check for typos.
 
Error Description #1
The name 'identifier' does not exist in the current context
 
Example #1
// Erroneous Sample Code - 'CurentBar' does not exist since it has been spelled incorrectly (missing an 'r')
if (CurentBar < 10)
 
// Resolution Sample Code - 'CurrentBar' exists since it is spelled correctly
if (CurrentBar < 10)
 
Example #2
// Erroneous Sample Code - 'newVariable' is not declared
newVariable = 10;
 
// Resolution Sample Code - 'newVariable' is now declared as an integer
int newVariable = 10;
The following CS0200 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error is most common when you try to assign values to a particular Series<T> index that is read-only. Instead try making your own Series<T> and assign the value there.
 
Error Description
Property or indexer 'NinjaTrader.NinjaScript.ISeries<double>.this[int]' cannot be assigned to -- it is read only
 
Example #1
// Erroneous Sample Code - Cannot assign values to something that is read-only
Close[0] = 25;
 
// Resolution Sample Code - Assigns value to a custom Series<double>
myCustomClose[0] = 25;
 
Example #2
// Erroneous Sample Code - Cannot reassign values to Series<double> indexed value and cannot have an if statement based // on an assignment operator
if (Close[0] = Open[0])
 
// Resolution Sample Code - Properly compares two Series<double> values
if (Close[0] == Open[0])
The following CS0234 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when an imported DLL (could be a 3rd party indicator) you are referencing no longer exists / has been removed.
 
To resolve this the DLL must be re-imported.
 
To re-import a 3rd party dll:
1.Open the NinjaScript Editor via New > NinjaScript editor.
2.Right mouse click in the NinjaScript Editor main window and select the menu name ""References""
3.In the ""References"" dialog window press the button ""Add""
4.Select the 3rd party DLL
 
 
Error Descriptions
The type or namespace name '<name>' could not be found (are you missing a using directive or an assembly reference?)
The type or namespace name '<name>' does not exist in the namespace 'NinjaTrader.Indicator' (are you missing an assembly reference?)
The following CS0234 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when an imported DLL (could be a 3rd party indicator) you are referencing no longer exists / has been removed.
 
To resolve this the DLL must be re-imported.
 
To re-import a 3rd party dll:
1.Open the NinjaScript Editor via New > NinjaScript editor.
2.Right mouse click in the NinjaScript Editor main window and select the menu name ""References""
3.In the ""References"" dialog window press the button ""Add""
4.Select the 3rd party DLL
 
 
Error Descriptions
The type or namespace name '<name>' could not be found (are you missing a using directive or an assembly reference?)
The type or namespace name '<name>' does not exist in the namespace 'NinjaTrader.Indicator' (are you missing an assembly reference?)
The following CS0428 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you miscall a method such as indicator methods.
 
If you are calling an indicator please ensure that you have both the parameters '()' and the indexing value '[]' set. For other methods please ensure you pass all required parameters through the parameters set '()'.
 
Error Description #1
Cannot convert method group 'SMA' to non-delegate type 'double'. Did you intend to invoke the method?
 
Example #1
// Erroneous Sample Code - SMA() indicator method is improperly called
double myValue = SMA;
 
// Resolution Sample Code - SMA() indicator method is properly called
double myValue = SMA(5)[0];
 
Example #2
// Erroneous Sample Code - ToString is a method and requires round brackets () to be properly called
string str = Close[5].ToString;
 
// Resolution Sample Code - ToString() is properly called
string str = Close[5].ToString();
The following CS0443 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error is most commonly invoked when no index value is used inside the indexing brackets.
 
Please ensure you place a value inside the '[]'.
 
Error Description #1
Syntax error, value expected
 
// Erroneous Sample Code - Missing index value
double myValue = SMA(20)[];
 
// Resolution Sample Code - 'myValue' takes on the current bar's SMA(20) value
double myValue = SMA(20)[0];
The following CS1002 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can be invoked when statements are not ended properly.
 
All statement lines must be closed with a semicolon.
 
Error Description #1
; expected
 
// Erroneous Sample Code - Statement is not closed
double myValue = SMA(20)[0]
 
// Resolution Sample Code - Statement is closed
double myValue = SMA(20)[0];
The following CS1061 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error's code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you try to use a method or access an exposed property that does not exist for your particular object.
 
Please check the methods and exposed property available for your particular object.
 
Error Description #1
'NinjaTrader.Indicator.CurrentDayOHL' does not contain a definition for 'CurentOpen'
// Erroneous Sample Code - CurrentDayOHL()’s property is 'CurrentOpen' not 'CurentOpen' (typo)
double value = CurrentDayOHL().CurentOpen[0];
 
// Resolution Sample Code - 'CurrentOpen' property available
double value = CurrentDayOHL().CurrentOpen[0];
 
The following CS1501 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you use use an overload (method parameter signature) that does not exist. This could be because you are passing in 3 arguments when the method only requires 2.
 
You can cycle through the available overloads with the use of the up and down arrows on the Intelliprompt when you call an indicator method or any other method.
 
Error Description #1
No overload for method 'SMA' takes '0' arguments
 
Example #1
// Erroneous Sample Code - SMA() does not contain an overload that has 3 arguments
double myValue = SMA(Close, 5, 2)[0];
 
// Resolution Sample Code - SMA() has an overload consisting of 2 arguments
double myValue = SMA(Close, 5)[0];
 
Example #2
// Erroneous Sample Code - EMA() does not contain an overload that has 0 arguments
double myValue = EMA()[0];
 
// Resolution Sample Code - EMA() has an overload consisting of 1 argument
double myValue = EMA(5)[0];
 
The following CS1502 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you pass in incorrect parameter object types into a method such as an indicator.
 
Please check the overload methods for the proper parameter object types and pass in the proper object. You can check the overload methods with NinjaScript editor’s Intelliprompt when you call a method.
 
Error Description #1
The best overloaded method match for 'NinjaTrader.NinjaScript.StrategyBase.SetStopLoss(CalculationMode, double)' has some invalid arguments
 
// Erroneous Sample Code - Close is a Series<double> object type and is not a valid value to the SetStopLoss() method
SetStopLoss(CalculationMode.Price, Close);
 
// Resolution Sample Code - The SetStopLoss() method takes a double value so pass in Close[0]
SetStopLoss(CalculationMode.Price, Close[0]);
 
Error Description #2
The best overloaded method match for 'NinjaTrader.Indicator.Indicator.SMA(NinjaTrader.NinjaScript.ISeries<double>, int)' has some invalid arguments
 
// Erroneous Sample Code - Using an integer when the first parameter should be a Series<double>
double myValue = SMA(5, 5);
 
// Resolution Sample Code - 'myValue' will take the value of the current bar's SMA
double myValue = SMA(Close, 5)[0];
The following CS1503 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
This error can occur when you try to assign a value to a Series<T> that is not of the correct value type.
 
Series<double> objects can only contain double values. Series<bool> objects can only contain bool values. Etc.
 
Error Description #1
Cannot implicity convert type from 'string' to 'double'
 
// Erroneous Sample Code - Cannot pass in a string to a Series<double>
Value[0] = ""Close[0]"";
 
// Resolution Sample Code - Sets Series<double> to the current bar's Close value
Value[0] = Close[0];
 
Error Description #2
Cannot implicitly convert type 'NinjaTrader.NinjaScript.Indicators.SMA' to 'double'
 
// Erroneous Sample Code - Cannot pass in a Series<double> object to a Series<double> Set() method
Values[0] = SMA(20);
 
// Resolution Sample Code - Sets Series<double> to the current bar's SMA(20) value
Values[0] = SMA(20)[0];
The following CS1525 error code information is provided within the context of NinjaScript. The examples provided are only a subset of potential problems that this error code may reflect. In any case, the examples below provide a reference of coding flaw possibilities.
 
Error Code Explanation
The compiler detected an invalid character in an expression.
 
Error Description #1
{ expected
 
// Erroneous Sample Code - If statement is not opened
protected override void OnBarUpdate()
{
  if(IsFirstTickOfBar)      
}
 
// Resolution Sample Code - If statement is open and closed
protected override void OnBarUpdate()
{
  if (IsFirstTickOfBar)
  {
    // do something
  }
}
 
Unfortunately we do not have NinjaScript context based Help information on this specific error code. You can check the Microsoft MSDN site section on error codes for futher information.
Using Compiled Assemblies
Compiled assemblies (DLL's) allow you to bundle your scripts into a format that hides your proprietary code along with any supporting resources. Compiled assemblies provide distinct benefits, especially for commercially distributed code, but there are a few considerations to keep in mind. Typecasting and building resource files (sounds, images, etc.) into your assemblies must be approached differently to ensure cleanly packaged, error-free DLL's.
 
Casting Types in a DLL (Using dynamic Types)
Sometimes, you may need to cast your objects to NinjaScript types, such as when iterating through the DrawObjects collection to obtain a reference to a particular Drawing Object on a chart. When running C# code which has not been compiled into an assembly, typecasting can be done normally, as in the example below:
 
 
An obstacle arises with traditional typecasting in a compiled assembly, since the NinjaScript Type you attempt to cast will be present in both your DLL and NinjaTrader's Custom.dll assembly. If you plan to compile your code into a DLL, you will need to use the dynamic Type to avoid this conflict by dynamically assigning the Type at runtime, using the guidelines below:
 
1.Define a variable of Type 'dynamic'
2.Assign a reference to the needed object to the dynamic variable
3.Access the dynamic variable as if it were of the expected Type
 
 
The above dynamic approach will work for primitive types. For instantiating more complex types / classes though, such as adding a new PriceLevel programmatically to an existing drawing tool, Reflection would need to used.
 
 
Working With the dynamic Type
Using dynamic variables in the technique above requires careful attention to accessing members appropriately, and thus should be avoided if you do not intend to use or distribute compiled assemblies.
 
•No Intelliprompt: Since the compiler cannot know which Type you assume a dynamic variable to be, no intelliprompt will be displayed to help search through Type members. The same applies to Visual Studio's Intellisense or similar utilities
 
•No Compile Errors: For the same reason, the compiler cannot know if you are using the variable in a way not supported by its expected Type, trying to access members not present in that Type, or other related errors. Thus, any such errors which would be caught by the compiler when typecasting will be missed, and will result in runtime errors instead. If a runtime error were to be triggered, the error may be more difficult to interpret.
oExample: If you tried to access ""line.tag"" (improper capitalization) in the examples above, you would receive the following errors:
▪Typecasting / Compile Error: ""'NinjaTrader.NinjaScript.DrawingTools.HorizontalLine' does not contain a definition for 'tag' and no extension method accepting a first argument of type 'NinjaTrader.NinjaScript.DrawingTools.HorizontalLine' can be found (are you missing a using directive or an assembly reference?)""
▪dynamic / Runtime Error: ""Error on calling 'OnBarUpdate' method on bar 0: 'NinjaTrader.NinjaScript.DrawingTools.DrawingTool.tag' is inaccessible due to its protection level""
 
 
Adding XAML and Other Files Into a DLL
When exporting a compiled assembly through NinjaTrader, no additional resource files can be added. There are two ways around this. The first is to export the DLL from NinjaTrader, then open the exported .zip file, add any additional files, and re-zip the archive, but this will result in your resource files being fully accessible to end users. The second and recommended approach is to use a fully featured IDE such as Visual Studio to build your DLL's.
 
For more information on how to accomplish this with Visual Studio, see the ""AddOn Development Environment"" section of the AddOn Development Overview page. Although the page focuses on AddOn development, the sample project it provides can be used to develop other NinjaScript Types, as well.
 
Exporting custom drawing tools as assembly / DLL
When planning to distribute your custom drawing tools via assemblies, please understand it's paramount that you implement your own Draw. method to allow the drawing tool getting called programmatically by other NinjaScript objects.
 
The NinjaTrader default drawing tools would implement this via a partial class, for example you would see -
 
 
However since partial classes could not span across two assemblies, therefore a custom non partial Draw. method for your NinjaScript drawing tool would be needed.
 
 
Exports might not be backwards compatible
NinjaScript exports might not be backwards compatible with previous versions of NinjaTrader.
 
This is known to happen every time a new type (e.g. Enum) was introduced, since the newly introduced types are not known to prior releases of NinjaTrader
 
Typically an error message like the following would be seen:
 
""Error on calling 'SetState' method: Could not load type 'NinjaTrader.NinjaScript.Indicators.CumulativeDeltaType' from assembly 'NinjaTrader.Vendor, Version=8.0.12.0, Culture=neutral, PublicKeyToken=null'.""
Tick Replay is used to playback 1 tick historical data to build the bars as if they had been build live, this means that tick data will be thrown as Market Data events in historical and subsequently OnMarketData and OnBarUpdate events will be called as if it was live. This provides more granular tick related information and can be helpful if you need to know the most recent last price, last volume, best ask price, or best bid price that occurred on historical data during the bar. An indicator or strategy running Tick Replay needs to have been specifically designed to take advantage of Tick Replay.  In general, this means adding additional logic to the OnMarketData() event handler, however, Tick Replay can also be used to call OnBarUpdate() ""OnEachTick"" or ""OnPriceChange"" during historical calculations.
 
How to Enable Tick Replay
To enable tick replay it must be manually enabled on the primary Data Series and the option to allow this mode is hidden by default. The option to allow for Tick Replay is located in Tools > Options > Market Data > ""Show Tick Replay"". The reason why it is hidden by default is that the tick replay engine utilizes 1 tick data to build historical bars. TickReplay can generate thousands of events per bar and may take an excessive amount of time to load.  It is recommended to optimize your indicators that you plan to calculate on such data by only running them in Calculate On Bar Close mode or reducing the amount of data to load to the minimum amount of data required. Since bars are built with tick data you will only be able to build bars back as far as your historical data provider allows download of tick data.
 
How the Tick Replay Engine Works
Tick Replay guarantees an exact sequence of stored events are played back for both the OnBarUpdate and OnMarketData events.  This mode also ensures the OnMarketData event is called after every OnBarUpdate event used to build the current bar.  Consider the following examples with Tick Replay enabled on a 5-tick input series, each box is when each event occurs during Tick Replay simulation.
 

 
As you can see from the table above, the Calculate setting will have a varying degree of impact on how your indicator or strategies OnBarUpdate event is raised. This process repeats for every historical bar on the chart and would continue as the indicator or strategy transitions to real-time data.
 
Accessing the current best bid and ask at the time of a trade
NinjaTrader stores the best bid price and best ask price as the last trade occurs during the MarketDataType.Last event and provides it per the table below:
 
 
An example below shows how to access historical Bid and Ask prices with Tick Replay
 
Calling a Tick Replay indicator from another Indicator or Strategy
A hosting indicator or strategy must be aware of the requirement to run through another indicator's historical Tick Replay data before it reaches State.Historical. To achieve desired results, you either need to store the reference in State.DataLoaded or (for a strategy) you can call AddChartIndicator().  Either approach ensures that the hosting indicator or strategy is aware of the requirements to process Tick Replay during its State.Historical mode and helps to ensure that the hosted indicator calculates as designed up to its current bar using Tick Replay.  Please see the example below.
 
 
Multi-Threading Overview
With the introduction of multi-threading in NinjaTrader special considerations should be made when programming your NinjaScript objects. Multi-threading basically allows NinjaTrader to take advantage of multi-core CPUs commonplace in modern computing to do multiple tasks at the same time.  While this has many advantages for multi-tasking, it can cause new types of issues you may have not needed to consider before.  This page was designed to serve as a high-level overview of some of the most common scenarios that can arise due to multi-threading, but should not be considered an exhaustive list.  
 
Using A Dispatcher
Depending on your CPU configuration, the NinjaTrader application will usually consist of multiple main UI threads, where various features like Charts or NinjaScript objects run, along with a number of background worker threads where events such as market data updates will be distributed throughout the product.  In principle, an object can only access information related to objects that exist on the same thread.  It is possible (and quite likely), that the thread which a NinjaScript object is running will not be the same thread as the event which is calling the object.  In cases where you need to access objects on the UI from a NinjaScript objects calling event thread, a dispatcher can be used.
 
 
 
 
Thread Access
Since market data is distributed across the entire application by a randomly assigned UI thread, there is no guarantee that your object will be running on the same event thread that is calling the object. Therefore it is recommend that you call Dispatcher.CheckAccess() in order to test if you truly need to dispatch the requested action.
 
 
 
Cross Thread Exceptions
When accessing objects included on the UI, you may receive the following error if you attempt to access a certain property/method from the wrong thread:
 
""Error on calling 'OnBarUpdate' method on bar 0: You are accessing an object which resides on another thread. I.E. creating your own Brush without calling .Freeze(), or trying to access a UI control from the wrong thread without using a Dispatcher""
 
This error can be avoided by invoking the Dispatcher used on the appropriate UI thread.
 
Access Violation Exception
Should you be using custom resources like text files, static members, etc. it is important to protect your resources from concurrent access. If NinjaTrader tried to use the resource at the same time you would run into errors similar to this one:
 
8/20/2010 12:14:29 PM|3|128|Error on calling 'OnBarUpdate' method for strategy 'SampleStrategy/1740b50bfe5d4bd896b0533725622400': The process cannot access the file 'c:\sample.txt' because it is being used by another process.
 
 
Multi-threaded consideration for Order, Execution and Position objects
 
These considerations apply to the OnOrderUpdate(), OnExecutionUpdate() and OnPositionUpdate() handlers, where both the actual 'core' objects are passed by reference and updating method value parameters are provided. Examplary the OnOrderUpdate() is discussed in below.
 
•OnOrderUpdate() method guarantees that you will see each order state change in sequence
•The ""order"" method parameter represents the core order object updated by NinjaTrader
•The supplementary method parameters provide an updating value representing each order change in sequence.  Think of this as the relevant information on the order at the time the state changed.
•Since the ""order""  method parameter represents the current order object state, it is possible for the updating values of that object to be out of sync with the correspond method parameters during a particular order update event.
 
As an example, the NinjaTrader core may have received ""Working"" and then ""PartFilled"" order state change events back from the broker API on thread ""B"". At some point in time (milliseconds later) the NinjaTrader core will take these events and trigger the OnOrderUpdate() method in the strategy on thread ""A"". Thus, when the strategy receives the first ""Working"" state for an order, the orderState method parameter will reflect the ""Working"" state although the actual order.OrderState is really in a state of ""Part Filled"".  You would see that current value truly reflected in the core Order object method parameter or any order objects returned in any of the order methods such as EnterLong(). Of course, the OnOrderUpdate() method parameters will eventually receive the event for ""PartFilled"" state in the sequence the events were received.
 
Considering the concept above, if you are unsure if you should be using the core order object value vs the updating method parameter value value, ask your self if you are truly looking for the most current order state, or the sequence of order states:
 
•For the most current order state, use the core ""order"" object property (e.g., order.OrderState, order.LimitPrice, order.StopPrice, etc)
•For the sequence of order states, use the updating method parameter value (e.g., orderState, limitPrice, stopPrice, etc)
Multi-Threading Overview
With the introduction of multi-threading in NinjaTrader special considerations should be made when programming your NinjaScript objects. Multi-threading basically allows NinjaTrader to take advantage of multi-core CPUs commonplace in modern computing to do multiple tasks at the same time.  While this has many advantages for multi-tasking, it can cause new types of issues you may have not needed to consider before.  This page was designed to serve as a high-level overview of some of the most common scenarios that can arise due to multi-threading, but should not be considered an exhaustive list.  
 
Using A Dispatcher
Depending on your CPU configuration, the NinjaTrader application will usually consist of multiple main UI threads, where various features like Charts or NinjaScript objects run, along with a number of background worker threads where events such as market data updates will be distributed throughout the product.  In principle, an object can only access information related to objects that exist on the same thread.  It is possible (and quite likely), that the thread which a NinjaScript object is running will not be the same thread as the event which is calling the object.  In cases where you need to access objects on the UI from a NinjaScript objects calling event thread, a dispatcher can be used.
 
 
 
 
Thread Access
Since market data is distributed across the entire application by a randomly assigned UI thread, there is no guarantee that your object will be running on the same event thread that is calling the object. Therefore it is recommend that you call Dispatcher.CheckAccess() in order to test if you truly need to dispatch the requested action.
 
 
 
Cross Thread Exceptions
When accessing objects included on the UI, you may receive the following error if you attempt to access a certain property/method from the wrong thread:
 
""Error on calling 'OnBarUpdate' method on bar 0: You are accessing an object which resides on another thread. I.E. creating your own Brush without calling .Freeze(), or trying to access a UI control from the wrong thread without using a Dispatcher""
 
This error can be avoided by invoking the Dispatcher used on the appropriate UI thread.
 
Access Violation Exception
Should you be using custom resources like text files, static members, etc. it is important to protect your resources from concurrent access. If NinjaTrader tried to use the resource at the same time you would run into errors similar to this one:
 
8/20/2010 12:14:29 PM|3|128|Error on calling 'OnBarUpdate' method for strategy 'SampleStrategy/1740b50bfe5d4bd896b0533725622400': The process cannot access the file 'c:\sample.txt' because it is being used by another process.
 
 
Multi-threaded consideration for Order, Execution and Position objects
 
These considerations apply to the OnOrderUpdate(), OnExecutionUpdate() and OnPositionUpdate() handlers, where both the actual 'core' objects are passed by reference and updating method value parameters are provided. Examplary the OnOrderUpdate() is discussed in below.
 
•OnOrderUpdate() method guarantees that you will see each order state change in sequence
•The ""order"" method parameter represents the core order object updated by NinjaTrader
•The supplementary method parameters provide an updating value representing each order change in sequence.  Think of this as the relevant information on the order at the time the state changed.
•Since the ""order""  method parameter represents the current order object state, it is possible for the updating values of that object to be out of sync with the correspond method parameters during a particular order update event.
 
As an example, the NinjaTrader core may have received ""Working"" and then ""PartFilled"" order state change events back from the broker API on thread ""B"". At some point in time (milliseconds later) the NinjaTrader core will take these events and trigger the OnOrderUpdate() method in the strategy on thread ""A"". Thus, when the strategy receives the first ""Working"" state for an order, the orderState method parameter will reflect the ""Working"" state although the actual order.OrderState is really in a state of ""Part Filled"".  You would see that current value truly reflected in the core Order object method parameter or any order objects returned in any of the order methods such as EnterLong(). Of course, the OnOrderUpdate() method parameters will eventually receive the event for ""PartFilled"" state in the sequence the events were received.
 
Considering the concept above, if you are unsure if you should be using the core order object value vs the updating method parameter value value, ask your self if you are truly looking for the most current order state, or the sequence of order states:
 
•For the most current order state, use the core ""order"" object property (e.g., order.OrderState, order.LimitPrice, order.StopPrice, etc)
•For the sequence of order states, use the updating method parameter value (e.g., orderState, limitPrice, stopPrice, etc)
Multi-Series Scripting Overview
NinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.
 
 
It is also important that you understand the following method and properties:
 
•AddDataSeries()
•BarsArray
•BarsInProgress
•CurrentBars
 
        Working With Multi-Time Frame Objects
        Adding Additional Bars Objects to NinjaScript
        Creating Series<T> Objects
        How Bars Data is Referenced
        Using Bars Objects as Input to Indicator Methods
        True Event Driven OnBarUpdate() Method
        Accessing the Price Data in a Multi-Bars NinjaScript
        Entering, Exiting and Retrieving Position Information
NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•""UI"" instances representing its default properties on various user interfaces
•The ""configured"" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select ""Indicator""
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses ""Apply"" or ""OK""
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of ""Available"" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of ""Available"" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the ""Properties"" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd ""configured"" instance you are concerned with developing, but you should also be aware of the ""UI"" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or ""Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
3rd Party Indicators Overview
You can use 3rd party indicators within your strategies or custom indicators. A 3rd party indicator is an indicator that was not developed by NinjaTrader.
 
 
3rd party indicators can be provided to you in one of the following ways:
 
•NinjaScript archive file that can be directly imported into NinjaTrader  
•A custom installer
•A set of files and instructions for saving them in the correct folders
 
If you were provided with a NinjaScript archive file that you have successfully imported via the Control Center window ""File > Utilities > Import NinjaScript"" menu, you can skip over the information below since NinjaTrader automatically configures the indicators ready for use.
 
If you were provided with a custom installer or a compiled assembly (.DLL) file that you had to manually save in the folder My Documents\NinjaTrader Folder>\bin\Custom then you must follow the instructions below.
 
Vendor File
The 3rd party developer should have either installed a ""Vendor"" file or provided you with one. Its likely in the format ""NinjaTrader.VendorName.cs"" where VendorName is the name of the 3rd party vendor. This file allows you to conveniently access their indicators.
 
•If you were provided an installer, you can check with the vendor if this file was included or;
•If they provided you this file, save it to ""My Documents\<NinjaTrader Folder>\bin\Custom"" and restart NinjaTrader
 
Adding a Reference
1. From within the NinjaScript Editor, right click on your mouse to bring up the context menu and select the sub-menu References... as per the image to the right.

 
2. A References window will appear
 
3. Press the ""add"" and select the 3rd party vendor DLL file
 
 
4. You will see a reference to the 3rd party vendor DLL in the References window
 
5. Press the OK button
 
You will now be able to access the indicator methods provided by the 3rd party vendor
 

You can create an automated strategy that generates a trade signal that executes a NinjaTrader ATM Strategy.
 
•ATM Strategies operate in real-time only and will not execute on historical data thus they can't be backtested
•Executions resulting from an ATM Strategy that is created from within a NinjaScript automated strategy will not plot on a chart during real-time operation
•Strategy set up parameters such as EntriesPerDirection, EntryHandling, IsExitOnSessionCloseStrategy do not apply when calling the AtmStrategyCreate() method
•Executions from ATM Strategies will not have an impact on the hosting NinjaScript strategy position and PnL - the NinjaScript strategy hands off the execution aspects to the ATM, thus no monitoring via the regular NinjaScript strategy methods will take place (also applies to strategy performance tracking)
•ATM Strategy stop orders can either be StopMarket or StopLimit orders, depending on which type is defined in the ATM Strategy Template (Advanced Options) you call in the AtmStrategyCreate() method in your NinjaScript strategy. To make the distinction clear which is used, following a naming convention for the template name is highly suggested (i.e. AtmStrategyTemplate_STPLMT)
•A general sample for calling ATM's is preinstalled with NinjaTrader under the 'SampleATMStrategy' script - for a script showing how to implement reversal type setups, please see this link to our online resources.
 
There is a Clear Line...
There is a clear line between a NinjaScript Strategy and an ATM Strategy. The use model for creating an ATM Strategy within a NinjaScript Strategy is when you want to programmatically monitor and generate an entry signal and then manualy manage the resulting open position via an ATM Strategy in one of NinjaTrader's order entry windows.
 
!!! IMPORTANT: Manually Closing an ATM Strategy from an Order Entry Window such as the SuperDOM
It is crucial that when running ATM Strategies created by a NinjaScript strategy that you understand how to properly manually close the ATM Strategy from any of the order entry windows.
 
•If the order entry window ATM Strategy Selection Mode is NOT in ""DisplaySelectedATMStrategyOnly"" click on the ""CLOSE"" button via your middle mouse button (scroll wheel)
•If the order entry window ATM Strategy Selection Mode is in ""DisplaySelectedATMStrategyOnly"" you can click on the ""CLOSE"" button with your left mouse button to close the selected active ATM strategy
 
Following the approaches above will internally close the ATM Strategy. Not following the approach will close the account/instrument position, terminate all strategies and cancel all orders. The result is that your NinjaScript strategy will be terminated.
Images as Buttons Overview
BitmapImage objects can be used to apply an image as a background to a Button object added to a NinjaTrader window.
 
 
Using an image as the background for a button can be achieved through a fairly straightforward process using some of the .NET framework's Controls and Imaging methods
 
There are a few best practices to keep in mind when working with Buttons:
•Dispose of any leftover objects in State.Terminated for efficient memory use
•Use your object's main Dispatcher when adding or removing Buttons to or from your chart, to ensure that the correct thread is used
•Be aware of the proper States in which to initialize objects related to the Button (State.Configure), apply the Button (State.Historical), and dispose of unneeded objects (State.Terminated)
 
Adding a Button to a Chart Toolbar Using an Image as the Background
The example below walks through the process of adding a Button to a chart toolbar specifically, and applying a .jpg image as the Button's background. This example also displays several best practices when working with Buttons, such as proper object disposal and ensuring that the Button is not populated when the indicator is applied in an inactive chart tab.
 
Images as Buttons Overview
BitmapImage objects can be used to apply an image as a background to a Button object added to a NinjaTrader window.
 
 
Using an image as the background for a button can be achieved through a fairly straightforward process using some of the .NET framework's Controls and Imaging methods
 
There are a few best practices to keep in mind when working with Buttons:
•Dispose of any leftover objects in State.Terminated for efficient memory use
•Use your object's main Dispatcher when adding or removing Buttons to or from your chart, to ensure that the correct thread is used
•Be aware of the proper States in which to initialize objects related to the Button (State.Configure), apply the Button (State.Historical), and dispose of unneeded objects (State.Terminated)
 
Adding a Button to a Chart Toolbar Using an Image as the Background
The example below walks through the process of adding a Button to a chart toolbar specifically, and applying a .jpg image as the Button's background. This example also displays several best practices when working with Buttons, such as proper object disposal and ensuring that the Button is not populated when the indicator is applied in an inactive chart tab.
 
Custom Icon Overview
When overriding the Icon method in a Bars Type, Share Service, Drawing Object, or Chart Style, you can use a variety of inputs to specify what will be displayed on the icon, including UniCode characters (if they exist in the icon pack for the font family used in NinjaTrader), custom Geometry Paths from the System.Windows.Shapes namespace, or image files. Using an image file for a custom icon can allow the flexibility of creating your icon's visuals outside of your code via image editing software. For more information about adding custom Icons, see the ""Icon"" page under the topics for each of the NinjaScript object types listed above.
 
        Using an Image as an Icon
permalink
        Using Geometry on an Icon
 
Historical Bid/Ask Series Overview
NinjaTrader has the ability to use historical bid and ask price series in your NinjaScript instead of only being able to use a last price series. The following outlines the intricacies of this capability:
 
 
 
Accessing Bid/Ask Series
When calling AddDataSeries() to add an additional Bars object to your script, a constructor overload will be available which takes a MarketDataType enumeration as an argument. This will allow you to specify the price series which will be used in that particular object. If you were to pass in MarketDataType.Ask or MarketDataType.Bid, as in the example below, that particular data series will use that price type for all of its PriceSeries collections, such as Close, Open, High, and Low.
 
 
Example
Custom Icon Overview
When overriding the Icon method in a Bars Type, Share Service, Drawing Object, or Chart Style, you can use a variety of inputs to specify what will be displayed on the icon, including UniCode characters (if they exist in the icon pack for the font family used in NinjaTrader), custom Geometry Paths from the System.Windows.Shapes namespace, or image files. Using an image file for a custom icon can allow the flexibility of creating your icon's visuals outside of your code via image editing software. For more information about adding custom Icons, see the ""Icon"" page under the topics for each of the NinjaScript object types listed above.
 
        Using an Image as an Icon
        Using Geometry on an Icon
permalink
 
In order to achieve custom rendering for various chart related objects, a Brush is used to ""paint"" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
permalink
        Understanding custom brushes
        Using brushes defined on the user interface
        Using advanced brush types (SharpDX)
In order to achieve custom rendering for various chart related objects, a Brush is used to ""paint"" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
        Understanding custom brushes
permalink
        Using brushes defined on the user interface
        Using advanced brush types (SharpDX)
In order to achieve custom rendering for various chart related objects, a Brush is used to ""paint"" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
        Understanding custom brushes
        Using brushes defined on the user interface
permalink
        Using advanced brush types (SharpDX)
In order to achieve custom rendering for various chart related objects, a Brush is used to ""paint"" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
        Understanding custom brushes
        Using brushes defined on the user interface
        Using advanced brush types (SharpDX)
permalink
Price Data Overview
The core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.
 
Definitions
 
 
Referencing Series
 
You will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:
 
 High[1] < High[0];
 
You could write a statement to calculate the average closing price of the last three bars like this:
 
 ( Close[2] + Close[1] + Close[0] ) / 3;
 
As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.
 
 
 
Referencing Indicator Data
NinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.
 
All indicator values can be accessed in the following way:
 
 indicator(parameters)[int barsAgo]
 
where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.
 
As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:
 
 Close[0] > SMA(20)[0];
 
If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:
 
 Close[0] > SMA(High, 20)[0];
 
You could write a statement to see if a 14 period CCI indicator is rising like this:
 
 CCI(14)[0] > CCI(14)[1];
 
Value of a 10 period CCI 1 bar ago = CCI(10)[1]
 
Please review the Indicator Methods section for proper syntax for accessing different indicator values.
Native Methods
The Microsoft .NET environment has a rich class library that you can access when developing custom indicators and strategies. There is a plethora of information available online and in print that details class libraries in great depth. Below are quick links to the Microsoft Developers Network for some of the basic classes whose functionality you may harness when developing in NinjaScript.
 
Complete list of classes in the Microsoft .NET environment.
 
MSDN (Microsoft Developers Network) C# Language Reference
Keywords
Operators
Arrays
 
System.Math
Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.
Full list of member of the System.Math class.
 
 
System.DateTime
Represents an instant in time, typically expressed as a data and time of day.
Full list of members of the Sytem.DateTime structure.
 
 
System.String
Represents text; that is, a series of unicode characters.
Full list of members of the System.String class.
 
Pular para o conteúdo principal
Aprender
Descobrir
Documentação do produto
Linguagens de desenvolvimento
Tópicos
Entrar
 Não estamos mais atualizando este conteúdo regularmente. Verifique o Microsoft Product Lifecycle para obter informações sobre como este produto, serviço, tecnologia ou API é suportado.
Retornar ao site principal
Dispensar alerta
Principio del formulario
Procurar
Final del formulario
Referência da biblioteca de classes do .NET Framework
Aprender 
 
Versões anteriores 
C#
Salvar



Referência da biblioteca de classes do .NET Framework
Artigo
15/09/2008
Neste artigo
Espaços de nomes
Veja também
A biblioteca de classes do .NET Framework é uma biblioteca de classes, interfaces e tipos de valor que estão incluídos no Microsoft .NET Framework. Esta biblioteca fornece acesso à funcionalidade do sistema e é projetada para ser a base sobre a qual os aplicativos, componentes e controles do .NET Framework são criados.
Espaços de nomes
A biblioteca de classes do .NET Framework fornece os seguintes namespaces:
Microsoft.Aspnet.Snapin
Contém classes necessárias para que o aplicativo de console de gerenciamento ASP.NET interaja com o Microsoft Management Console (MMC).
Microsoft.Build.BuildEngine
Contém as classes que representam o mecanismo MSBuild.
Microsoft.Build.Framework
Contém classes que compõem as tarefas, registradores e eventos do MSBuild.
Microsoft.Build.Tasks
Contém a implementação de todas as tarefas enviadas com o MSBuild.
Microsoft.Build.Tasks.Deployment.Bootstrapper
Contém classes usadas internamente pelo MSBuild.
Microsoft.Build.Tasks.Deployment.ManifestUtilities
Contém classes usadas internamente pelo MSBuild.
Microsoft.Build.Utilities
Fornece classes auxiliares que você pode usar para criar seus próprios registradores e tarefas do MSBuild.
Microsoft.Csharp
Contém classes que oferecem suporte à compilação e geração de código usando a linguagem C#.
Microsoft.JScript
Contém classes que oferecem suporte à compilação e geração de código usando a linguagem JScript.
Microsoft.SqlServer.Server
Contém classes específicas para a integração do componente CLR (Common Language Runtime) do Microsoft .NET Framework no Microsoft SQL Server e no ambiente de execução do processo do mecanismo de banco de dados do SQL Server.
Microsoft.VisualBasic
Contém classes que oferecem suporte à compilação e geração de código usando a linguagem Visual Basic.
Microsoft.VisualBasic.ApplicationServices
Contém tipos que suportam o Modelo de Aplicativo do Visual Basic e fornecem acesso às informações do aplicativo.
Microsoft.VisualBasic.CompilerServices
Contém tipos somente de uso interno que suportam o compilador Visual Basic.
Microsoft.VisualBasic.Devices
Contém tipos que suportam os objetos My relacionados a dispositivos no Visual Basic.
Microsoft.VisualBasic.FileIO
Contém tipos que suportam o objeto Meu sistema de arquivos no Visual Basic.
Microsoft.VisualBasic.Logging
Contains types that support the My logging objects in Visual Basic and provides a simple log listener that directs logging output to file.
Microsoft.VisualBasic.MyServices
Contains types that support My in Visual Basic.
Microsoft.VisualBasic.MyServices.Internal
Contains internal-use only types that support My in Visual Basic.
Microsoft.VisualBasic.Vsa
Microsoft.VisualC
Microsoft.Vsa
Contains interfaces that allow you to integrate script for the .NET Framework script engines into applications, and to compile and execute code at run time.
Microsoft.Vsa.Vb.CodeDOM
Microsoft.Win32
Provides two types of classes: those that handle events raised by the operating system and those that manipulate the system registry.
Microsoft.Win32.SafeHandles
Contains classes that are abstract derivations of safe handle classes that provide common functionality supporting file and operating system handles.
Microsoft.WindowsCE.Forms
Contains classes for developing Pocket PC and Smartphone Windows Forms applications using the .NET Compact Framework.
Microsoft.WindowsMobile.DirectX
Contains classes for developing DirectX applications on devices with the .NET Compact Framework. Requires a future release of Windows Mobile to run the applications.
Microsoft.WindowsMobile.DirectX.Direct3D
Contains classes for developing Direct3D applications on devices with the .NET Compact Framework. Requires a future release of Windows Mobile to run the applications.
Microsoft_VsaVb
System
Contains fundamental classes and base classes that define commonly used value and reference data types, events and event handlers, interfaces, attributes, and processing exceptions. Other classes provide services supporting data type conversion, method parameter manipulation, mathematics, remote and local program invocation, application environment management, and supervision of managed and unmanaged applications.
System.CodeDom
Contains classes that can be used to represent the elements and structure of a source code document. These elements can be used to model the structure of a source code document that can be output as source code in a supported language using the functionality provided by the System.CodeDom.Compiler namespace.
System.CodeDom.Compiler
Contains types for managing the generation and compilation of source code in supported programming languages. Code generators can each produce source code in a particular programming language based on the structure of Code Document Object Model (CodeDOM) source code models consisting of elements provided by the System.CodeDom namespace.
System.Collections
Contains interfaces and classes that define various collections of objects, such as lists, queues, bit arrays, hashtables and dictionaries.
System.Collections.Generic
Contains interfaces and classes that define generic collections, which allow users to create strongly typed collections that provide better type safety and performance than non-generic strongly typed collections.
System.Collections.ObjectModel
Contains classes that can be used as collections in the object model of a reusable library. Use these classes when properties or methods return collections.
System.Collections.Specialized
Contains specialized and strongly typed collections; for example, a linked list dictionary, a bit vector, and collections that contain only strings.
System.ComponentModel
Provides classes that are used to implement the run-time and design-time behavior of components and controls. This namespace includes the base classes and interfaces for implementing attributes and type converters, binding to data sources, and licensing components.
System.ComponentModel.Design
Contains classes that developers can use to build custom design-time behavior for components and user interfaces for configuring components at design time. The design time environment provides systems that enable developers to arrange components and configure their properties.
System.ComponentModel.Design.Data
Contains classes for implementing design-time behavior of data-related components.
System.ComponentModel.Design.Serialization
Provides types that support customization and control of serialization at design time.
System.Configuration
Contains the types that provide the programming model for handling configuration data.
System.Configuration.Assemblies
Contains classes that are used to configure an assembly.
System.Configuration.Install
Provides classes that allow you to write custom installers for your own components. The Installer class is the base class for all custom installers in the .NET Framework.
System.Configuration.Provider
Contains the base classes shared by both server and client applications to support a pluggable model to easily add or remove functionality.
System.Data
Contains classes that constitute most of the ADO.NET architecture. The ADO.NET architecture enables you to build components that efficiently manage data from multiple data sources. In a disconnected scenario (such as the Internet), ADO.NET provides the tools to request, update, and reconcile data in multiple tier systems. The ADO.NET architecture is also implemented in client applications, such as Windows Forms, or HTML pages created by ASP.NET.
System.Data.Common
Contains classes shared by the .NET Framework data providers. A .NET Framework data provider describes a collection of classes used to access a data source, such as a database, in the managed space.
System.Data.Design
Contains classes that can be used to generate a custom typed-dataset.
System.Data.Linq
Contains classes to access relational data as objects. DataContext and related classes can be used for Reading, Creating, Updating and Deleting objects mapped to a database using mapping specified as attributes in your object model or in a separate external XML file.
System.Data.Linq.Mapping
Provides programmatic access to mapping information used by LINQ to SQL.
System.Data.Odbc
Contains classes that encapsulate the .NET Framework Data Provider for ODBC. The .NET Framework Data Provider for ODBC describes a collection of classes used to access an ODBC data source in the managed space.
System.Data.OleDb
Contains classes that encapsulate the .NET Framework Data Provider for OLE DB. The .NET Framework Data Provider for OLE DB describes a collection of classes used to access an OLE DB data source in the managed space.
System.Data.OracleClient
Contains classes that encapsulate the .NET Framework Data Provider for Oracle. The .NET Framework Data Provider for Oracle describes a collection of classes used to access an Oracle data source in the managed space.
System.Data.Sql
Contains classes that support SQL Server-specific functionality. The API extensions in this class add to the .NET Framework Data Provider for SQL Server (System.Data.SqlClient).
System.Data.SqlClient
Contains classes that encapsulate the .NET Framework Data Provider for SQL Server. The .NET Framework Data Provider for SQL Server describes a collection of classes used to access a SQL Server database in the managed space.
System.Data.SqlServerCE
Describes a collection of classes that can be used to access a database in SQL Server CE from Windows CE-based devices in the managed environment. With this namespace you can create SQL Server CE databases on a device and also establish connections to SQL Server databases that are on a device or on a remote server.
System.Data.SqlTypes
Contains classes for native data types within SQL Server. These classes provide a faster alternative to other data types. Using the classes in this namespace helps prevent type conversion errors caused in situations where loss of precision could occur. Because other data types are converted to and from SqlTypes behind the scenes, explicitly creating and using objects within this namespace results in faster code as well.
System.Diagnostics
Provides classes that allow you to interact with system processes, event logs, and performance counters. This namespace also provides classes that allow you to debug your application and to trace the execution of your code. For more information, see the Trace and Debug classes.
System.Diagnostics.CodeAnalysis
Contains classes for interaction with code analysis tools. Code analysis tools are used to analyze code for conformance to coding conventions such as naming or security rules.
System.Diagnostics.Design
Contains classes that can be used to extend design-time support for application monitoring and instrumentation.
System.Diagnostics.SymbolStore
Provides classes that allow you to read and write debug symbol information, such as source line to Microsoft intermediate language (MSIL) maps. Compilers targeting the .NET Framework can store the debug symbol information into programmer's database (PDB) files. Debuggers and code profiler tools can read the debug symbol information at run time.
System.DirectoryServices
Provides easy access to Active Directory from managed code. The namespace contains two component classes, DirectoryEntry and DirectorySearcher, which use the Active Directory Services Interfaces (ADSI) technology. ADSI is the set of interfaces that Microsoft provides as a flexible tool for working with a variety of network providers. ADSI gives the administrator the ability to locate and manage resources on a network with relative ease, regardless of the network's size.
System.DirectoryServices.ActiveDirectory
Provides a high level abstraction object model that builds around Microsoft® Active Directory® directory service tasks. The Active Directory® directory service concepts such as forest, domain, site, subnet, partition and schema are part of the object model.
System.DirectoryServices.Protocols
Provides the methods defined in the Lightweight Directory Access Protocol (LDAP) version 3 (V3) and Directory Services Markup Language (DSML) version 2 (V2) standards.
System.Drawing
Provides access to GDI+ basic graphics functionality. More advanced functionality is provided in the System.Drawing.Drawing2D, System.Drawing.Imaging, and System.Drawing.Text namespaces.
System.Drawing.Design
Contains classes that extend design-time user interface (UI) logic and drawing. You can further extend this design-time functionality to create custom toolbox items, type-specific value editors that can edit and graphically represent values of their supported types, or type converters that can convert values between certain types. This namespace provides the basic frameworks for developing extensions to the design-time UI.
System.Drawing.Drawing2D
Provides advanced 2-dimensional and vector graphics functionality. This namespace includes the gradient brushes, the Matrix class (used to define geometric transforms), and the GraphicsPath class.
System.Drawing.Imaging
Provides advanced GDI+ imaging functionality. Basic graphics functionality is provided by the System.Drawing namespace.
System.Drawing.Printing
Provides print-related services. Typically, you create a new instance of the PrintDocument class, set the properties that describe what to print, and call the Print method to actually print the document.
System.Drawing.Text
Provides advanced GDI+ typography functionality. Basic graphics functionality is provided by the System.Drawing namespace. The classes in this namespace allow users to create and use collections of fonts.
System.EnterpriseServices
Provides an important infrastructure for enterprise applications. COM+ provides a services architecture for component programming models deployed in an enterprise environment. This namespace provides .NET Framework objects with access to COM+ services, making the .NET Framework objects more practical for enterprise applications.
System.EnterpriseServices.CompensatingResourceManager
Provides classes that allow you to use a Compensating Resource Manager (CRM) in managed code. A CRM is a service provided by COM+ that enables you to include non-transactional objects in Microsoft Distributed Transaction Coordinator (DTC) transactions. Although CRMs do not provide the capabilities of a full resource manager, they do provide transactional atomicity (all-or-nothing behavior) and durability through the recovery log.
System.EnterpriseServices.Internal
Provides infrastructure support for COM+ services. The classes and interfaces in this namespace are specifically intended to support calls into System.EnterpriseServices from the unmanaged COM+ classes.
System.Globalization
Contains classes that define culture-related information, including the language, the country/region, the calendars in use, the format patterns for dates, currency, and numbers, and the sort order for strings. These classes are useful for writing globalized (internationalized) applications.
System.IO
Contains types that allow synchronous and asynchronous reading and writing on data streams and files.
System.IO.Compression
Contains classes that provide basic compression and decompression for streams.
System.IO.IsolatedStorage
Contains types that allow the creation and use of isolated stores. With these stores, you can read and write data that less trusted code cannot access and help prevent the exposure of sensitive information that can be saved elsewhere on the file system. Data is stored in compartments that are isolated by the current user and by the assembly in which the code exists.
System.IO.Ports
Contains classes that control serial ports, providing a framework for synchronous and event-driven I/O, access to pin and break states, access to serial driver properties, and enumerations for specifying port characteristics.
System.Linq
Provides classes and interfaces that support queries that use Language-Integrated Query (LINQ).
System.Linq.Expressions
Contains classes, interfaces and enumerations that enable language-level code expressions to be represented as objects in the form of expression trees.
System.Management
Provides access to a rich set of management information and management events about the system, devices, and applications instrumented to the Windows Management Instrumentation (WMI) infrastructure.
System.Management.Instrumentation
Provides the classes necessary for instrumenting applications for management and exposing their management information and events through WMI to potential consumers. Consumers such as Microsoft Application Center or Microsoft Operations Manager can then manage your application easily, and monitoring and configuring of your application is available for administrator scripts or other applications, both managed as well as unmanaged.
System.Messaging
Provides classes that allow you to connect to, monitor, and administer message queues on the network and send, receive, or peek messages.
System.Messaging.Design
Contains classes that can be used to extend design-time support for System.Messaging classes.
System.Net
Provides a simple programming interface for many of the protocols used on networks today. The WebRequest and WebResponse classes form the basis of what are called pluggable protocols, an implementation of network services that enables you to develop applications that use Internet resources without worrying about the specific details of the individual protocols.
System.Net.Cache
Defines the types and enumerations used to define cache policies for resources obtained using the WebRequest and HttpWebRequest classes.
System.Net.Configuration
Contains classes that applications use to programmatically access and update configuration settings for the System.Net namespaces.
System.Net.Mail
Contains classes used to send electronic mail to a Simple Mail Transfer Protocol (SMTP) server for delivery.
System.Net.Mime
Holds types that are used to represent Multipurpose Internet Mail Exchange (MIME) headers. These types are used with the types in the System.Net.Mail namespace to specify Content-Type, Content-Disposition and Content-transfer-Encoding headers when sending email using the SmtpClient class.
System.Net.NetworkInformation
Provides access to network traffic data, network address information, and notification of address changes for the local computer. The namespace also contains classes that implement the Ping utility. You can use Ping and related classes to check whether a computer is reachable across the network.
System.Net.Sockets
Provides a managed implementation of the Windows Sockets (Winsock) interface for developers who need to help control access to the network.
System.Reflection
Contains classes and interfaces that provide a managed view of loaded types, methods, and fields, with the ability to dynamically create and invoke types.
System.Reflection.Emit
Contains classes that allow a compiler or tool to emit metadata and Microsoft intermediate language (MSIL) and optionally generate a PE file on disk. The primary clients of these classes are script engines and compilers.
System.Resources
Provides classes and interfaces that allow developers to create, store, and manage various culture-specific resources used in an application.
System.Resources.Tools
Contains the StronglyTypedResourceBuilder class, which provides support for strongly-typed resources. Beginning with the .NET Framework version 2.0, this compile-time feature encapsulates access to resources by creating classes that contain a set of static read-only (get) properties, thus making it easier to consume resources.
System.Runtime
Contains advanced types that support diverse namespaces such as System, the Runtime namespaces, and the Security namespaces.
System.Runtime.ConstrainedExecution
Defines a set of types that enumerate and define a contract for reliability between the author of some code, and the developers who take a dependency on that code.
System.Runtime.Hosting
Contains advanced types that are used in application activation within application domains.
System.Runtime.CompilerServices
Provides functionality for compiler writers using managed code to specify attributes in metadata that affect the run-time behavior of the common language runtime. The classes in this namespace are for compiler writers use only.
System.Runtime.InteropServices
Provides a wide variety of members that support COM interop and platform invoke services. If you are unfamiliar with these services, see Interoperating with Unmanaged Code.
System.Runtime.InteropServices.ComTypes
Contains methods that are definitions of COM functions for managed code. These functions replace the now-obsolete UCOM* methods in the System.Runtime.InteropServices namespace.
System.Runtime.InteropServices.CustomMarshalers
Supports the .NET infrastructure and is not intended to be used directly from your code.
System.Runtime.InteropServices.Expando
Contains the IExpando interface which allows modification of an object by adding or removing its members.
System.Runtime.Remoting
Provides classes and interfaces that allow developers to create and configure distributed applications.
System.Runtime.Remoting.Activation
Provides classes and objects that support server and client activation of remote objects.
System.Runtime.Remoting.Channels
Contains classes that support and handle channels and channel sinks, which are used as the transport medium when a client calls a method on a remote object.
System.Runtime.Remoting.Channels.Http
Contains channels that use the HTTP protocol to transport messages and objects to and from remote locations. By default, the HTTP channels encode objects and method calls in SOAP format for transmission, but other encoding and decoding formatter sinks can be specified in the configuration properties of a channel.
System.Runtime.Remoting.Channels.Ipc
Defines a communication channel for remoting that uses the Interprocess Communication (IPC) system of the Windows operating system. Because it does not use network communication, the IPC channel is much faster than the HTTP and TCP channels, but it can only be used for communication between application domains on the same physical computer.
System.Runtime.Remoting.Channels.Tcp
Contains channels that use the TCP protocol to transport messages and objects to and from remote locations. By default, the TCP channels encode objects and method calls in binary format for transmission, but other encoding and decoding formatter sinks can be specified in the configuration properties of a channel.
System.Runtime.Remoting.Contexts
Contains objects that define the contexts all objects reside within. A context is an ordered sequence of properties that defines an environment for the objects within it. Contexts are created during the activation process for objects that are configured to require certain automatic services such synchronization, transactions, just-in-time (JIT) activation, security, and so on. Multiple objects can live inside a context.
System.Runtime.Remoting.Lifetime
Contains classes that manage the lifetime of remote objects. Traditionally, distributed garbage collection uses reference counts and pinging for control over the lifetime of objects. This works well when there are a few clients per service, but doesn't scale well when there are thousands of clients per service. The remoting lifetime service associates a lease with each service, and deletes a service when its lease time expires. The lifetime service can take on the function of a traditional distributed garbage collector, and it also adjusts well when the numbers of clients per server increases.
System.Runtime.Remoting.Messaging
Contains classes used to create and remote messages. The remoting infrastructure uses messages to communicate with remote objects. Messages are used to transmit remote method calls, to activate remote objects, and to communicate information. A message object carries a set of named properties, including action identifiers, envoy information, and parameters.
System.Runtime.Remoting.Metadata
Contains classes and attributes that can be used to customize generation and processing of SOAP for objects and fields. The classes of this namespace can be used to indicate the SOAPAction, type output, XML element name, and the method XML namespace URI.
System.Runtime.Remoting.Metadata.W3cXsd2001
Contains the XML Schema Definition (XSD) defined by the World Wide Web Consortium (W3C) in 2001. The XML Schema Part2: Data types specification from W3C identifies format and behavior of various data types. This namespace contains wrapper classes for the data types that conform to the W3C specification. All date and time types conform to the ISO standards specification.
System.Runtime.Remoting.MetadataServices
Contains the classes used by the Soapsuds.exe command line tool and the user code to convert metadata to and from XML schema for the remoting infrastructure.
System.Runtime.Remoting.Proxies
Contains classes that control and provide functionality for proxies. A proxy is a local object that is an image of a remote object. Proxies enable clients to access objects across remoting boundaries.
System.Runtime.Remoting.Services
Contains service classes that provide functionality to the .NET Framework.
System.Runtime.Serialization
Contains classes that can be used for serializing and deserializing objects. Serialization is the process of converting an object or a graph of objects into a linear sequence of bytes for either storage or transmission to another location. Deserialization is the process of taking in stored information and recreating objects from it.
System.Runtime.Serialization.Formatters
Provides common enumerations, interfaces, and classes that are used by serialization formatters.
System.Runtime.Serialization.Formatters.Binary
Contains the BinaryFormatter class, which can be used to serialize and deserialize objects in binary format.
System.Runtime.Serialization.Formatters.Soap
Contains the SoapFormatter class, which can be used to serialize and deserialize objects in the SOAP format.
System.Security
Provides the underlying structure of the .NET Framework security system, including base classes for permissions.
System.Security.AccessControl
 
System.Security.Cryptography
Provides cryptographic services, including secure encoding and decoding of data, as well as many other operations, such as hashing, random number generation, and message authentication.
System.Security.Cryptography.Pkcs
Provides programming elements for Public Key Cryptography Standards (PKCS), including methods for signing data, exchanging keys, requesting certificates, public key encryption and decryption, and other security functions.
System.Security.Cryptography.X509Certificates
Contains the common language runtime implementation of the Authenticode X.509 v.3 certificate. This certificate is signed with a private key that uniquely and positively identifies the holder of the certificate.
System.Security.Cryptography.Xml
Contains classes to support the creation and validation of XML digital signatures. The classes in this namespace implement the World Wide Web Consortium Recommendation, ""XML-Signature Syntax and Processing"", described at https://www.w3.org/TR/xmldsig-core/.
System.Security.Permissions
Defines classes that control access to operations and resources based on policy.
System.Security.Policy
Contains code groups, membership conditions, and evidence. These three types of classes are used to create the rules applied by the .NET Framework security policy system. Evidence classes are the input to security policy and membership conditions are the switches; together these create policy statements and determine the granted permission set. Policy levels and code groups are the structure of the policy hierarchy. Code groups are the encapsulation of a rule and are arranged hierarchically in a policy level.
System.Security.Principal
Defines a principal object that represents the security context under which code is running.
System.ServiceProcess
Provides classes that allow you to implement, install, and control Windows service applications. Services are long-running executables that run without a user interface. Implementing a service involves inheriting from the ServiceBase class and defining specific behavior to process when start, stop, pause, and continue commands are passed in, as well as custom behavior and actions to take when the system shuts down.
System.Text
Contains classes representing ASCII, Unicode, UTF-7, and UTF-8 character encodings; abstract base classes for converting blocks of characters to and from blocks of bytes; and a helper class that manipulates and formats String objects without creating intermediate instances of String.
System.Text.RegularExpressions
Contains classes that provide access to the .NET Framework regular expression engine. The namespace provides regular expression functionality that can be used from any platform or language that runs within the Microsoft .NET Framework.
System.Threading
Provides classes and interfaces that enable multithreaded programming. In addition to classes for synchronizing thread activities and access to data (Mutex, Monitor, Interlocked, AutoResetEvent, and so on), this namespace includes a ThreadPool class that allows you to use a pool of system-supplied threads, and a Timer class that executes callback methods on thread pool threads.
System.Timers
Provides the Timer component, which allows you to raise an event on a specified interval.
System.Transactions
Contains classes that allow your code to participate in transactions. The classes support transactions with multiple, distributed participants, multiple phase notifications, and durable enlistments..
System.Transactions.Configuration
Contains classes that describe configuration options used by System.Transactions classes
System.Web
Supplies classes and interfaces that enable browser-server communication. This namespace includes the HttpRequest class, which provides extensive information about the current HTTP request, the HttpResponse class, which manages HTTP output to the client, and the HttpServerUtility class, which provides access to server-side utilities and processes. System.Web also includes classes for cookie manipulation, file transfer, exception information, and output cache control.
System.Web.Caching
Provides classes for caching frequently used data on the server. This includes the Cache class, a dictionary that allows you to store arbitrary data objects, such as hash tables and data sets. It also provides expiration functionality for those objects, and methods that allow you to add and remove the objects. You can also add the objects with a dependency upon other files or cache entries, and perform a callback to notify your application when an object is removed from the cache.
System.Web.Compilation
Contains classes for generating and compiling custom file types within the ASP.NET build environment.
System.Web.Configuration
Contains classes that are used to set up ASP.NET configuration.
System.Web.Handlers
Contains HTTP handler classes that process HTTP requests to a Web server.
System.Web.Hosting
Provides the functionality for hosting ASP.NET applications from managed applications outside of Microsoft Internet Information Services (IIS).
System.Web.Mail
The classes in this namespace are obsolete; use the classes in the System.Net.Mail namespace. Contains classes that enable you to construct and send messages using the CDOSYS message component. The mail message is delivered through either the SMTP mail service built into Microsoft Windows 2000 or through an arbitrary SMTP server. The classes in this namespace can be used either from ASP.NET or from any managed application.
System.Web.Management
Contains classes and interfaces for managing and monitoring the health of Web applications.
System.Web.Mobile
Contains the core capabilities, including authentication and error-handling, required for building ASP.NET mobile Web applications.
System.Web.Profile
Contains classes that are used to implement the ASP.NET user profile in Web server applications.
System.Web.RegularExpressions
Provides regular expressions used to parse ASP.NET files. All members of the System.Web.RegularExpressions namespace are descendants of the Regex class.
System.Web.Security
Contains classes that are used to implement ASP.NET security in Web server applications.
System.Web.Services
Consists of the classes that enable you to create XML Web services using ASP.NET and XML Web service clients. XML Web services are applications that provide the ability to exchange messages in a loosely coupled environment using standard protocols such as HTTP, XML, XSD, SOAP, and WSDL. XML Web services enable the building of modular applications within and across companies in heterogeneous environments making them interoperable with a broad variety of implementations, platforms and devices. The SOAP-based XML messages of these applications can have well-defined (structured and typed), or loosely defined parts (using arbitrary XML). The ability of the messages to evolve over time without breaking the protocol is fundamental to the flexibility and robustness of XML Web services as a building block for the future of the Web.
System.Web.Services.Configuration
Consists of the classes that configure how XML Web services created using ASP.NET run.
System.Web.Services.Description
Consists of the classes that enable you to publicly describe an XML Web service by using the Web Services Description Language (WSDL). Each class in this namespace corresponds to a specific element in the WSDL specification, and the class hierarchy corresponds to the XML structure of a valid WSDL document.
System.Web.Services.Discovery
Consists of the classes that allow XML Web service clients to locate the available XML Web services on a Web server through a process called XML Web services Discovery.
System.Web.Services.Protocols
Consists of the classes that define the protocols used to transmit data across the wire during the communication between XML Web service clients and XML Web services created using ASP.NET.
System.Web.SessionState
Supplies classes and interfaces that enable storage of data specific to a single client within a Web application on the server. The session state data is used to give the client the appearance of a persistent connection with the application. State information can be stored within local process memory or, for Web farm configurations, out-of-process using either the ASP.NET State Service or a SQL Server database.
System.Web.UI
Provides classes and interfaces that allow you to create controls and pages that will appear in your Web applications as user interface on a Web page. This namespace includes the Control class, which provides all controls, whether HTML, Web, or User controls, with a common set of functionality. It also includes the Page control, which is generated automatically whenever a request is made for a page in your Web application. Also provided are classes which provide the Web Forms Server Controls data binding functionality, the ability to save the view state of a given control or page, as well as parsing functionality for both programmable and literal controls.
System.Web.UI.Adapters
Contains the base classes for control adapters and page adapters, which you can use to override lifecycle states of pages and controls to modify their default markup or behavior for new markup standards or for specific browsers.
System.Web.UI.Design
Contains classes that can be used to extend design-time support for Web Forms and Web server controls.
System.Web.UI.Design.MobileControls
Obsolete. Contains classes that provide design-time support for the classes in the System.Web.UI.MobileControls namespace. The classes in this namespace are obsolete; use the classes in System.Web.UI.Design.WebControls instead.
System.Web.UI.Design.MobileControls.Converters
Contains classes that provide design-time support for data type converters in mobile controls.
System.Web.UI.Design.WebControls
Contains classes that can be used to extend design-time support for Web server controls.
System.Web.UI.Design.WebControls.WebParts
Contains classes that provide design-time support for controls derived from classes in the System.Web.UI.WebControls.WebParts namespace.
System.Web.UI.HtmlControls
Consists of a collection of classes that allow you to create HTML server controls on a Web Forms page. HTML server controls run on the server and map directly to standard HTML tags supported by most browsers. This allows you to programmatically control the HTML elements on a Web Forms page.
System.Web.UI.MobileControls
Obsolete. Contains a set of ASP.NET server controls that can intelligently render your application for different mobile devices. The classes in this namespace are obsolete; use the controls in System.Web.UI.WebControls instead.
System.Web.UI.MobileControls.Adapters
Contains classes you can use to override lifecycle stages of a mobile control to modify its default HTML, CHTML, or WML markup or behavior for new markup standards or for specific browsers and mobile devices.
System.Web.UI.MobileControls.Adapters.XhtmlAdapters
Contains classes you can use to override lifecycle stages of a mobile control to modify its default XHTML markup or behavior for new markup standards or for specific browsers and mobile devices.
System.Web.UI.WebControls
Contains classes that allow you to create Web server controls on a Web page. Web server controls run on the server and include form controls such as buttons and text boxes. They also include special purpose controls such as a calendar. Because Web server controls run on the server, you can programmatically control these elements. Web server controls are more abstract than HTML server controls. Their object model does not necessarily reflect HTML syntax.
System.Web.UI.WebControls.Adapters
Contains classes you can use to override lifecycle stages of a Web control to modify a control's default markup or behavior for new markup standards or for specific browsers.
System.Web.UI.WebControls.WebParts
Contains an integrated set of classes and interfaces for creating Web pages whose appearance and behavior can be modified (personalized) by end users. The user-defined settings for each page are saved for future browser sessions.
System.Web.Util
Contains classes that enable callback methods to be run under the scope of a transaction and that enable work to be posted to separate threads.
System.Windows.Forms
Contains classes for creating Windows-based applications that take full advantage of the rich user interface features available in the Microsoft Windows operating system.
System.Windows.Forms.ComponentModel.Com2Interop
Contains helper classes that Visual Studio uses to display property pages while in design mode.
System.Windows.Forms.Design
Contains classes that support design-time configuration and behavior for Windows Forms components. These classes consist of: Designer classes that provide support for Windows Forms components, a set of design time services, UITypeEditor classes for configuring certain types of properties, and classes for importing ActiveX controls.
System.Windows.Forms.Design.Behavior
Contains classes for creating custom user interface behavior for components at design time.
System.Windows.Forms.Layout
Contains classes that support design-time and run-time layout behaviors.
System.Windows.Forms.PropertyGridInternal
Provides internal support for the PropertyGrid control. The classes in this namespace support the .NET Framework infrastructure and are not intended to be used directly from your code
System.Xml
Provides standards-based support for processing XML.
System.Xml.Schema
Contém as classes XML que fornecem suporte baseado em padrões para esquemas de linguagem de definição de esquemas XML (XSD).
System.Xml.Serialization
Contém classes que são usadas para serializar objetos em documentos ou fluxos no formato XML.
System.Xml.XPath
Contém o analisador XPath e o mecanismo de avaliação. Ele suporta a Recomendação W3C XML Path Language (XPath) Versão 1.0 ( www.w3.org/TR/xpath ).
System.Xml.Xsl
Fornece suporte para transformações Extensible Stylesheet Transformation (XSLT). Ele suporta a Recomendação W3C XSL Transformations (XSLT) Versão 1.0 ( www.w3.org/TR/xslt ).
System.Xml.Xsl.Runtime
Fornece suporte interno para as classes no namespace System.Xml.Xsl . As classes neste namespace suportam a infraestrutura do .NET Framework e não devem ser usadas diretamente do seu código.
Veja também
Conceitos
Referência geral do .NET Framework
Visão geral da biblioteca de classes do .NET Framework
Inglês (Estados Unidos)
Suas escolhas de privacidade
Tema
Versões anteriores
Blogue
Contribuir
Privacidade
Termos de Uso
Marcas registradas
© Microsoft 2025

"
Optimization Parameters 2.docx,"Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Custom Optimizers can be used to optimize your Strategy through different algorithms. These may allow you to make trade offs like being able to find adequate results quickly as opposed to trying to find the absolute best result but through a time consuming process. The methods and properties covered in this section are unique to custom Optimizer development.
 
In this section
Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
Informs the Strategy Analyzer if this Optimizer can do multi-objective optimizations.
 
Property Value
A bool value.
 
Syntax
SupportsMultiObjectiveOptimization
 
 
Examples
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Multi-Objective optimization takes standard optimization a step further by allowing you to choose multiple objectives to test for. When results are returned instead of a singlular list of best results ranked from best to least best instead you will be presented a graph. With multiple objective there is no single best result, instead its up to the trader to choose what is the best tradeoff between two objectives. To run a Multi-objective optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
 
        How to run a Multi-Objective Optimization 
permalink
        Understanding Multi-Objective  properties
permalink
        Understanding Multi-Objective results
permalink
Multi-Objective optimization takes standard optimization a step further by allowing you to choose multiple objectives to test for. When results are returned instead of a singlular list of best results ranked from best to least best instead you will be presented a graph. With multiple objective there is no single best result, instead its up to the trader to choose what is the best tradeoff between two objectives. To run a Multi-objective optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
 
        How to run a Multi-Objective Optimization 
permalink
        Understanding Multi-Objective  properties
permalink
        Understanding Multi-Objective results
permalink
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
You can fine tune the input parameters of a strategy through optimization. Optimization is the process of testing a range of values through iterative backtests to determine the optimal input values over the historical test period based on your optimization fitness. To run an optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting capabilities
 
 
        How to run an Optimization
permalink
        Understanding optimization properties
permalink
        Understanding optimization results
permalink
        Running a basket test
permalink
        Understanding factors that affect optimization performance
permalink
The Optimization Graph can only be selected in the Display selector only after an optimization has been run. The optimization graph can be displayed in a 2D or 3D graph. A 2D graph is used when only graphing a single parameter. If you graph 2 parameters then a 3D graph is displayed.
 

        Understanding the 2D optimization graph
permalink
        Understanding the 3D optimization graph
permalink
Within the Help Guide are numerous videos providing a step by step tour through the NinjaTrader Platform. Select your area of interest below to view an expanded list of all available topics within each category.
        Order Entry
permalink
        Advanced Trade Management (ATM) Strategies
permalink
        SuperDOM
permalink
        Control Center
permalink
        Market Analyzer
permalink
        Alerts
permalink
        Charts
permalink
        Market Data Windows
permalink
        Miscellaneous
permalink
        Strategy Backtesting and Optimization
permalink
Definition
Determines if the following declared property should be included in the NinjaScript object's constructor as a parameter.  This is useful if you plan on calling a NinjaScript object from another (e.g., calling a custom indicator from a strategy) or customizing the display parameter data on a grid or from a chart. This also used to make parameters optimizable in the Strategy Analyzer.
 
 
 
Syntax
[NinjaScriptProperty]
 
Parameters
This object contains no parameters
 
 
Examples
 
 
Using the OnStateChange() Method to Configure the Strategy
The OnStateChange() method is called once prior to running a strategy and can be used to set properties or call methods in preparation for running a strategy.
 
Enter the code contained within the OnStateChange() method in the image below into the OnStateChange() method when we are in the State.DataLoaded state in the NinjaScript Editor.
 
 
For more information on the strategy properties added in State.SetDefaults, please see our complete Strategy documentation.
The AddChartIndicator() method is called and the RSI() indicator method is passed in which will automatically plot this indicator on a chart when the strategy runs.
 
The method signature for the RSI() indicator is:
 
 
It is valid to have used the Add() method in the following manner:
 
 
However, instead of hard coding the period value to 14 and the smooth value to 3, we substituted the values for the user defined inputs we defined in the wizard. Calling the Add() method in the following manner:
 
 
Allows us to change the period and smooth parameters of the embedded RSI indicator in the strategy at run time. This gives us a higher level of flexibility when working with our strategy.
 
SetStopLoss() and SetProfitTarget() are called with CalculationMode.Ticks. This means that when a position is opened, the strategy will immediately submit a stop and target order with a price that is calculated based on the StopLoss and ProfitTarget parameters passed in offset from the positions average entry price.
 
 
Using the OnBarUpdate() Method for the Core Strategy Logic
The OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations. Therefore, this is the main method called for strategy calculation and we will use this method to enter the script that check for entry and exit conditions.
 
Enter the code contained within the OnBarUpdate() method in the image below into the OnBarUpdate() method in the NinjaScript Editor:
 
 
Since our strategy exit logic has already been set up in the OnStateChange() method above, we only need to focus on expressing our entry logic. The strategy entry logic is very straight forward and can be translated to English:
 
if we have not seen the number of bars specified by the user defined input ""RSIPeriod"" then do not go any further
 
if RSI crosses above a value of 20 within the last bar, go long
 
To accomplish this we used the following methods and properties:
 
CurrentBar - A value representing the current bar being processed (think of a chart where the left most bar would be equal to one)
CrossAbove() - Checks for a cross above condition and returns true or false
RSI() - Returns the value of the RSI indicator
EnterLong() - Enters a market order long
Definition
This method must be overridden in order to optimize a strategy. This method is called once per optimization run (not once per iteration).
 
Method Return Value
This method does not return a value.
 
Syntax
You must override the method in your Optimizer with the following syntax.
 
protected override void OnOptimize()
{
 
}
 
 
 
Examples
Anchored Walk Forward optimization is similar to the Walk Forward Optimization. However, each optimization is run from the start time then increases the end date.
 
Walk Forward optimization is the process by which you optimize strategy input parameters on a historical segment of market data, then test the strategy forward in time on data following the optimization segment using the optimized input values. The central idea is that you evaluate strategy performance data on the test data, not the data used in the optimization. This process is then repeated by moving the optimization and test segments forward in time. To run a walk forward optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
        How to run an Anchored Walk Forward Optimization 
permalink
        Understanding Anchored Walk Forward properties
permalink
        Understanding Anchored Walk Forward results
permalink
Walk Forward optimization is the process by which you optimize strategy input parameters on a historical segment of market data, then test the strategy forward in time on data following the optimization segment using the optimized input values. The central idea is that you evaluate strategy performance data on the test data, not the data used in the optimization. This process is then repeated by moving the optimization and test segments forward in time. To run a walk forward optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
 
        How to run a Walk Forward Optimization 
permalink
        Understanding Walk Forward properties
permalink
        Understanding Walk Forward results
permalink
Very simply put the Genetic Algorithm attempts to find the most optimal set of parameters for a strategy. It does this not by brute force testing each individual combination as the default optimization method does, but instead using the concept of evolutionary theory borrowed from biology where only the fittest parents (combined with mutation and crossover) produce children for the next generation. Through testing of multiple generations you should have narrowed down on the most optimal parameters and therefore saving you time from having to test every single parameter combination.
 
        Understanding the Genetic Algorithm
permalink
        Understanding Genetic Algorithm parameters
permalink
The AI Generate optimizer is an experimental tool designed to help traders find new strategy approaches. It can combine up to 73 NinjaTrader default indicators, 25 Candlestick patterns, and single series custom indicators.
Internally a Genetic Algorithm is used to search through the potential entry and exit combinations possible to find the best performing ones according to the Max Strength optimization criterion.
To prevent against potentially over-fitting against historical data, the AI Generate will check its own results after each generation using a Monte Carlo Simulation, it finds the 95% confidence interval.
 
We are excited to bring you this new tool to enhance your NinjaTrader strategy trading and are looking for feedback to further enhance it.
 
To run an AI Generate optimization you will need:
 
•Access to historical data
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
        How to run an AI Generate Optimization 
permalink
The AI Generate optimizer is an experimental tool designed to help traders find new strategy approaches. It can combine up to 73 NinjaTrader default indicators, 25 Candlestick patterns, and single series custom indicators.
Internally a Genetic Algorithm is used to search through the potential entry and exit combinations possible to find the best performing ones according to the Max Strength optimization criterion.
To prevent against potentially over-fitting against historical data, the AI Generate will check its own results after each generation using a Monte Carlo Simulation, it finds the 95% confidence interval.
 
We are excited to bring you this new tool to enhance your NinjaTrader strategy trading and are looking for feedback to further enhance it.
 
To run an AI Generate optimization you will need:
 
•Access to historical data
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
        How to run an AI Generate Optimization 
permalink
The following page covers how to set up and run NinjaTrader's Monte Carlo Simulation
        Understanding Monte Carlo simulation
permalink
        How to run a Monte Carlo simulation
permalink
        Understanding the Monte Carlo Simulation report
permalink
Definition
Used to override the default NinjaScript Clone() method which is called any time an instance of a NinjaScript object is created.  By default,  the NinjaScript Clone() method will copy all the Property Info and Browsable Attributes to the new instance when the object is created (e.g., when an optimization is ran a new instance of the strategy will be created for each iteration).  However it is possible to override this behavior if desired for custom development.  There is no requirement to override the Clone behavior and this method will use the default constructor if not overridden.  
 
 
 
Method Return Value
A virtual object representing the NinjaScript type.
 
Syntax
public override object Clone()
 
 
Parameters
This method does not take any parameters
 
 
Examples
Definition
An event driven method which is called while the chart scale is being updated.  This method is used to determine the highest and lowest value that can be used for the chart scale. It is only called when the chart object is either set to IsAutoScale while there are multiple charts objects rendered or only a single object would be rendered on the chart.  
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
You must override the method in your NinjaScript object with the following syntax:
 
public override void OnCalculateMinMax()
{
 
}
 
Method Parameters
This method does not accept any parameters.
 
Examples
NinjaTrader supports trading and viewing market data for spot forex pairs, in addition to other supported instrument types. Due to the unique nature of forex markets, there are a number of features throughout the platform tailored specifically to these instruments, and a few considerations to keep in mind when working with forex in NinjaTrader.
        Pips Calculation Mode
permalink
        Pips in ATM Strategies
permalink
        Forex Lot Sizes
permalink
        Forex-Specific Trading Windows
permalink
        How Bars Are Built and Orders Filled
permalink
        Forex Trading Hours
permalink
        Calculating Pip Value
permalink
NinjaTrader allows a convenient way to save strategy parameters to easily transition to a live running strategy.
 
Saving a Template
Using the 'template' button on the bottom of the settings button shows 'Save' and 'Load'. Selecting 'Save' allows you to save the selected settings for this strategy. If you have performed an optimization the selected optimization result set will be saved. This is signified by the ""("" + "")"" number directly to the right of the strategy parameter control.
 
If you save as 'Default' the template will be automatically loaded as you load the strategy.
 
Loading a Template
Using the 'template' button on the bottom of the settings button shows 'Save' and 'Load'. Selecting 'Load' opens the loading dialog box where any templates specific to this strategy can be loaded. This allows you to have multiple configurations customized per instrument.
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
Definition
Used to render custom drawing to a chart from various chart objects, such as an Indicator, DrawingTool or Strategy.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
 
}
 
 
 
Method Parameters
 
 
 
 
Examples
 
 
 
 

"
Optimization Parameters.docx,"Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
Informs the Strategy Analyzer how many iterations of optimizing it needs to do.
 
Property Value
An int value.
 
Syntax
NumberOfIterations
 
 
Examples

"
Optimization.docx,"Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
Reserved for Walk-Forward Optimization, this property determines the number of days used for the ""in sample"" backtest period for a given strategy.  See also TestPeriod.
 
 
Property Value
An int value representing the number of ""in sample"" days used for walk-forward optimization; Default value is set to 10.
 
Syntax
OptimizationPeriod
 
 
Examples
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
Represents the real-world or simulation Account configured for the strategy.
 
Property Value
An Account object configured for the strategy
 
Syntax
Account
 
Examples
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
Definition
Adds an instance of custom Performance Metric to a strategy used in strategy calculations.
 
Method Return Value
This method does not return a value.
 
Syntax
AddPerformanceMetric(PerformanceMetricBase performanceMetric)
 
 
 
Parameters
 
 
 
Examples
 
Definition
Adds an instance of custom Performance Metric to a strategy used in strategy calculations.
 
Method Return Value
This method does not return a value.
 
Syntax
AddPerformanceMetric(PerformanceMetricBase performanceMetric)
 
 
 
Parameters
 
 
 
Examples
 
Definition
Changes the price of the specified entry order.
 
Method Return Value
Returns true if the specified order was found; otherwise false.
 
Syntax
AtmStrategyChangeEntryOrder(double limitPrice, double stopPrice, string orderId)
 
 
Parameters
 
 
Examples
Definition
Changes the price of the specified order of the specified ATM strategy.
 
Method Return Value
Returns true if the specified order was found; otherwise false.
 
Syntax
AtmStrategyChangeStopTarget(double limitPrice, double stopPrice, string orderName, string atmStrategyId)
 
Parameters
 
 
 
Examples
Definition
Cancels any working orders and closes any open position of a strategy using the default ATM strategy close behavior.
 
Method Return Value
Returns true if the specified ATM strategy was found; otherwise false.
 
 
 
Syntax
AtmStrategyClose(string atmStrategyId)
 
Parameters
 
 
Examples
Definition
Submits an entry order that will execute a specified ATM Strategy.  
 
 
 
Method Return Value
This method does not return a value
 
Syntax
AtmStrategyCreate(OrderAction action, OrderType orderType, double limitPrice, double stopPrice, TimeInForce timeInForce, string orderId, string strategyTemplateName, string atmStrategyId, Action<Cbi.ErrorCode, string> callback)
 
 
Parameters
 
 
 
 
Examples
The methods and properties covered in this section are unique to custom strategy development.
 
In this section
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
The following are what we suggest for best practices for distribution.
 
Do not deploy NinjaScript Source Files
If you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.
 
Naming Conventions
Please use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is ""Hyper"" you could name your indicators ""HyperTrend"" or ""HyperOscillator"" for example.
 
In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader will automatically block incompatible scripts from importing so there will be no confusion by the user as to whether they are installing Version 7 or 8 scripts to their NinjaTrader installation. It is advisable to include the NinjaTrader version number in the export archive which will reduce potential support burden. For example, you could name your indicators “MyIndicator_7.zip” and “MyIndicator_8.zip”.
 
Clean up your resources
Always free up resources such as external windows DLL's or license management related resources. Resources should be freed within the OnStateChange() method in State.Terminate. NinjaTrader calls this method at the point at which a script is no longer used.
 
User Authentication Trigger
If you use a proprietary user authentication process, ensure that it is triggered within the OnStateChange() method in State.SetDefaults. This ensures that users are not forced to endure unnecessary delays on NinjaTrader start up or dialog windows that display available indicators and strategies as the windows are loaded. NinjaTrader, LLC provides a free licensing service for qualified 3rd party developers. For more information on this free service, contact your NinjaTrader Business Development representative.
 
User Authentication Check State
A license check should only be performed once and maintain its check state.
 
User Authentication Time Out
A license check should have a time out in case of internet issues, to enhance performance in this case.
 
Custom Installer
If you provide a custom installer, the installer should not overwrite any NinjaTrader deployed files, and you should provide an uninstall option which removes all installed files.
 
It is also preferred that you provide one installer that provides the user the option to install either a version 7 or version 8 compatible version of your product(s). Ensure that you only copy the correct files to the correct NinjaTrader installation folders since if you don’t it is possible that it could cause compile issues for the customer and it will be extremely difficult for all involved to isolate the cause.
 
These are the following folder names:
•Documents\NinjaTrader 7\bin\Custom
•Documents\NinjaTrader 8\bin\Custom
 
Test on Legacy Operating Systems
Some NinjaTrader customers run on older Operating Systems (such as Windows 7) and you should make sure that your indicators, custom installers and external DLLs (if any are used) properly run on these legacy operating systems.
 
Expose Indicator States
If your proprietary indicator acts as a trend state (green bars are bullish, red bearish) its good practice to expose the indicators's state so that consumers of your indicators can use them within their own custom indicator or strategy.
Understanding the SharpDX .NET Library
NinjaTrader Chart objects (such as Indicators, Strategies, DrawingTools, ChartStyles) implement an OnRender() method aimed to render custom lines, shapes, and text to the chart.  To achieve the level of performance required to keep up with market data events, NinjaTrader uses a 3rd-party open-source .NET library named SharpDX.  This 3rd party library provides a C# wrapper for the powerful Microsoft DirectX API used for graphics processing and known for its hardware-accelerated performance, including 2D vector and text layout graphics used for NinjaTrader Chart Rendering.  The SharpDX/DirectX library is extensive, although NinjaTrader only uses a handful of namespaces and classes, which are documented as a guide in this reference.  In addition to this educational resource, we have also compiled a more focused collection of SharpDX SDK Reference resources to help you learn the SharpDX concepts used in NinjaTrader Chart Rendering.
 
 
There are three main SharpDX namespaces you need to be familiar with:
 
 
The rest of this page will help you navigate the fundamental concepts needed to achieve custom rendering to your charts.
        SharpDX Vectors and Charting Coordinates
permalink
        SharpDX Brush Resources
permalink
        SharpDX RenderTarget
permalink
        SharpDX Lines and Shapes
permalink
        SharpDX Text Rendering
permalink
        SharpDX Stroke Style
permalink
         Best Practices for SharpDX Resources
permalink
Welcome to the NinjaTrader 8 Beta Release!
We are very excited to openly release NinjaTrader 8 Beta to our general user base. The purpose of this program is to have you start testing the platform to in order to solicit feedback in the form of bug reports and constructive criticism. The beta process is a critical step in the software development cycle during which time we jointly work towards improving quality and performance with a goal of reaching a stable product ready for general release.
 
This release marks the introduction of our next generation trading platform. NinjaTrader 8 adds over 500+ new features and functionality on top of a re-designed architecture built to take advantage of new development practices and modern technologies. This is our most ambitious project to date and we are excited to get it in the hands of our customers.
 
 
 
Bug reports and providing feedback
Support will be driven via our NinjaTrader Support Forum NinjaTrader 8 section. When running into unexpected behavior please create a bug report in the NinjaTrader support forum's bug report section. Bug reports will be reviewed by our support and development staff inside of a 48 hour period. If you are unable to post to the bug section of the forum please contact platformsupport@ninjatrader.com.  
        Installation Guide
permalink
        Expectations during beta
permalink
        NinjaScript
permalink
The Condition Builder is a very powerful feature that allows you to define complex conditions for your automated trading systems without having to know how to program.
        Understanding the Condition Builder
permalink
        How to make price data comparisons
permalink
        How to offset an item value
permalink
        How to make indicator to value comparisons
permalink
        How to compare plot values of multi-plot indicators
permalink
        How to use user inputs & variables
permalink
        How to create a cross over condition
permalink
        How to use indicator inputs in other indicators
permalink
        How to check for volume expansion
permalink
        How to create market position comparisons
permalink
        How to create time comparisons
permalink
        How to negate a condition
permalink
 
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
Description
The Polarized Fractal Efficiency indicator uses fractal geometry to determine how efficiently the price is moving. When the PFE is zigzagging around zero, then the price is congested and not trending. When the PFE is smooth and above/below zero, then the price is in an up/down trend. The higher/lower the PFE value, the stronger the trend is.
 
... Courtesy of FMLabs
 
 
Syntax
PFE(int period, int smooth)
PFE(ISeries<double> input, int period, int smooth)
 
Returns default value
PFE(int period, int smooth)[int barsAgo]
PFE(ISeries<double> input, int period, int smooth)[int barsAgo]
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
Description
Developed by Perry Kaufman, this indicator is an EMA using an Efficiency Ratio to modify the smoothing constant, which ranges from a minimum of Fast Length to a maximum of Slow Length.
 
 
Syntax
KAMA(int fast, int period, int slow)
KAMA(ISeries<double> input, int fast, int period, int slow)
 
Returns default value
KAMA(int fast, int period, int slow)[int barsAgo]
KAMA(ISeries<double> input, int fast, int period, int slow)[int barsAgo]
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•""UI"" instances representing its default properties on various user interfaces
•The ""configured"" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select ""Indicator""
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses ""Apply"" or ""OK""
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of ""Available"" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of ""Available"" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the ""Properties"" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd ""configured"" instance you are concerned with developing, but you should also be aware of the ""UI"" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or ""Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
The following are what we suggest for best practices for distribution.
 
Do not deploy NinjaScript Source Files
If you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.
 
Naming Conventions
Please use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is ""Hyper"" you could name your indicators ""HyperTrend"" or ""HyperOscillator"" for example.
 
In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader will automatically block incompatible scripts from importing so there will be no confusion by the user as to whether they are installing Version 7 or 8 scripts to their NinjaTrader installation. It is advisable to include the NinjaTrader version number in the export archive which will reduce potential support burden. For example, you could name your indicators “MyIndicator_7.zip” and “MyIndicator_8.zip”.
 
Clean up your resources
Always free up resources such as external windows DLL's or license management related resources. Resources should be freed within the OnStateChange() method in State.Terminate. NinjaTrader calls this method at the point at which a script is no longer used.
 
User Authentication Trigger
If you use a proprietary user authentication process, ensure that it is triggered within the OnStateChange() method in State.SetDefaults. This ensures that users are not forced to endure unnecessary delays on NinjaTrader start up or dialog windows that display available indicators and strategies as the windows are loaded. NinjaTrader, LLC provides a free licensing service for qualified 3rd party developers. For more information on this free service, contact your NinjaTrader Business Development representative.
 
User Authentication Check State
A license check should only be performed once and maintain its check state.
 
User Authentication Time Out
A license check should have a time out in case of internet issues, to enhance performance in this case.
 
Custom Installer
If you provide a custom installer, the installer should not overwrite any NinjaTrader deployed files, and you should provide an uninstall option which removes all installed files.
 
It is also preferred that you provide one installer that provides the user the option to install either a version 7 or version 8 compatible version of your product(s). Ensure that you only copy the correct files to the correct NinjaTrader installation folders since if you don’t it is possible that it could cause compile issues for the customer and it will be extremely difficult for all involved to isolate the cause.
 
These are the following folder names:
•Documents\NinjaTrader 7\bin\Custom
•Documents\NinjaTrader 8\bin\Custom
 
Test on Legacy Operating Systems
Some NinjaTrader customers run on older Operating Systems (such as Windows 7) and you should make sure that your indicators, custom installers and external DLLs (if any are used) properly run on these legacy operating systems.
 
Expose Indicator States
If your proprietary indicator acts as a trend state (green bars are bullish, red bearish) its good practice to expose the indicators's state so that consumers of your indicators can use them within their own custom indicator or strategy.
NinjaTrader provides a free vendor license management service for user authentication to qualified 3rd party developers.
 
The service includes the following features:
 
•One method call within your NinjaScript indicator or strategy's constructor will enable the authentication process
•A NinjaScript AddOn dedicated to license management (Manage license, provide free trials)
•Licenses are exclusively tied to a combination of user-defined prefix + PC machine ID value, ensuring that licenses cannot be shared
•Manage all of your individual products, or group products together for licensing
•Licenses expire based on time/date
•Create free trial periods
 
For more information please contact sales@ninjatrader.com or your NinjaTrader Business Development representative. Once approved, you will receive a unique Vendor ID used to manage your user licenses, a Vendor Licensing Help Guide containing information, samples, and resources to guide you through the process of managing licensing.

"
Parameter Configuration Guid.docx,"Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Indicator and strategy parameters (user defined inputs) will always be displayed in an order that the user specifies in the NinjaScript file.
 
In the NinjaScript Editor, expand the ""Properties"" region of your code where all of your parameters are defined. In this example, this will be our Properties section:
 
In this case, the Fast parameter will show up as the first parameter with the Slow parameter showing as the second.
 
To switch the order around, we could modify Order. If we change Slow's Order to 0 and Fast's Order to 1 as shown below ...
 
... the Slow property will show first and the Fast property second.
You can create user defined input parameters for both NinjaScript Indicators and Strategies. Although user defined input parameters can be specified as part of the initial set up of NinjaScript Indicator or Strategies using the Wizard you may have a requirement to add new parameters at a later point in your development process. To create these parameters you will need to edit your NinjaScript code and follow these steps.
1.Open your NinjaScript file
2.Inside of the if (State == State.SetDefaults) statement, assign a value to the variable for your parameter
 
 
 
3.Scroll down to the bottom of the editor and expand the minimized ""Properties"" section by clicking on the + sign on the left.
4.Use the following template code for each parameter you wish to create. Please note that the type (int, double, etc) will differ depending on what type of variable you wish to create
 
5.To specify lower and upper bounds, you would modify [Range(1, int.MaxValue)]. For example:
 
6.Use the ""Description"" field to provide a brief description of what the parameter does.
7.Pay attention to this line as the object type will vary depending on the type of parameter you wish to make:
 
8.Now, wherever in your code you want to call the user-definable parameter, just use ""Period"".
The Condition Builder is a very powerful feature that allows you to define complex conditions for your automated trading systems without having to know how to program.
        Understanding the Condition Builder
permalink
        How to make price data comparisons
permalink
        How to offset an item value
permalink
        How to make indicator to value comparisons
permalink
        How to compare plot values of multi-plot indicators
permalink
        How to use user inputs & variables
permalink
        How to create a cross over condition
permalink
        How to use indicator inputs in other indicators
permalink
        How to check for volume expansion
permalink
        How to create market position comparisons
permalink
        How to create time comparisons
permalink
        How to negate a condition
permalink
 
Definition
Determines how the following declared property display on the NinjaTrader UI's property grid.  
 
 
 
Syntax
[Display(Name=string)]
[Display(Description=string)]
[Display(GroupName=string)]
[Display(Order=int)]
 
 
 
Parameters
 
 
 
 
Examples
Definition
Determines if the following declared property should be included in the NinjaScript object's constructor as a parameter.  This is useful if you plan on calling a NinjaScript object from another (e.g., calling a custom indicator from a strategy) or customizing the display parameter data on a grid or from a chart.
 
 
 
Syntax
[NinjaScriptProperty]
 
Parameters
This object contains no parameters
 
 
Examples
 
 
The following section documents both .NET native and NinjaScript custom attributes which are commonly used to define the behavior of a NinjaScript property or object.  The attributes outlined in the section are primarily used to customize how properties display on the UI, but may also control or how the object is compiled and executed at run time.  
 
 
 
Common Attributes
 
 
Applying Attributes
Attributes are applied directly before the property, method, or class, and are identified by wrapping brackets:
 
 
 
Definition
Determines if the value of the following declared property is valid within a specified range.  These values are checked when the NinjaScript object has reached State.Configure.  For configuration through the UI (e.g., the user has selected Apply or OK to configure the value from the indicator dialog box) and determines to be invalid, the value will be automatically rounded to the nearest minimum or maximum value. Should the property be set as a NinjaScriptAttribute and called from a hosting NinjaScript object and determines to be invalid, an exception will be thrown and the hosted indicator will NOT execute.
 
 
 
Syntax
[Range(int minimum, int maximum)]
[Range(double minimum, double maximum)]
[Range(type type, string minimum, string aximum)]
 
Parameters
 
 
Examples
Definition
Determines the sequence in which a NinjaScript object's Display.GroupName categories are arranged in relation to other categories in the UI.   The default behavior will display each GroupName of an object in alphabetical order, however this behavior can be changed by defining the CategoryOrder attribute before the object's declaration.
 
 
 
NinjaScript Indicators
The follow table applies for Indicators configured from a Chart Indicator, Market Analyzer Indicator Column, or SuperDOM Indicator:
 
 
 
NinjaScript Strategies
The following table applies to Chart Strategies, Control Center Strategies Grid, and the Strategy Analyzer
 
 
 
 
 
Syntax
[Gui.CategoryOrder(string category, int order)]
 
 
 
Parameters
 
 
Examples
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 

"
Performance Metrics.docx,"Definition
Returns a collection of custom Performance Metrics. These need to have been enabled in Tools > Options > General to be able to use them.
 
Syntax
<TradeCollection>.TradesPerformance.PerformanceMetrics
 
 
Examples
 
Definition
The Values array holds an 5 values corresponding to each Cbi.PerformanceUnit. NinjaTrader will then access the Values property to display the calculated performance metric in the UI. You can also access these performance metrics for a NinjaScript strategy.
 
Syntax
public double[] Values
{ get; private set; }
 
Calculating Values OnAddTrade Example
 
Calculating Values On Demand Example
Definition
Enumeration defining each type of PerformanceUnit calculated by NinjaTrader. Used to store a value for this performance type in PerformanceMetrics.
 
Syntax
PerformanceUnit.Currency
PerformanceUnit.Percent
PerformanceUnit.Pips
PerformanceUnit.Points
PerformanceUnit.Ticks
 
Examples
Definition
Holds an array of PerformanceMetrics objects that represent custom metrics that can be used for strategy calcuations.
 
Index value is based on the the array of Bars objects added via the AddPerformanceMetric method.
 
Property Value
An array of PerformanceMetrics objects.
 
Syntax
PerformanceMetrics[int index]
 
 
Examples
Definition
This method is called when the Performance Metric would be aggregated and merged together (E.g. on the Strategy Analyzer's total row).
 
Syntax
protected override void OnMergePerformanceMetric(PerformanceMetricBase merge)
{
 
}
 
Examples
Definition
This method is called when the Performance Metric would be aggregated and merged together (E.g. on the Strategy Analyzer's total row).
 
Syntax
protected override void OnMergePerformanceMetric(PerformanceMetricBase merge)
{
 
}
 
Examples
Definition
This method allows you to customize the rendering of the performance value on the Summary grid.
 
Syntax
public override string Format(object value, Cbi.PerformanceUnit unit, string propertyName)
{
 
}
 
 
Examples
Definition
This method is called as each trade is added. You would add any custom math you wanted to do here.
 
 
 
Syntax
protected override void OnAddTrade(Cbi.Trade trade)
{
 
}
 
Examples
Definition
Called as the values of a trade metric are saved.
 
Syntax
protected override void OnCopyTo(PerformanceMetricBase target)
{
 
}
 
Examples
Definition
This method is called when the Performance Metric would be aggregated and merged together (E.g. on the Strategy Analyzer's total row).
 
Syntax
protected override void OnMergePerformanceMetric(PerformanceMetricBase merge)
{
 
}
 
Examples
Definition
Enumeration defining each type of PerformanceUnit calculated by NinjaTrader. Used to store a value for this performance type in PerformanceMetrics.
 
Syntax
PerformanceUnit.Currency
PerformanceUnit.Percent
PerformanceUnit.Pips
PerformanceUnit.Points
PerformanceUnit.Ticks
 
Examples
Definition
The Values array holds an 5 values corresponding to each Cbi.PerformanceUnit. NinjaTrader will then access the Values property to display the calculated performance metric in the UI. You can also access these performance metrics for a NinjaScript strategy.
 
Syntax
public double[] Values
{ get; private set; }
 
Calculating Values OnAddTrade Example
 
Calculating Values On Demand Example
Definition
Returns the average number of bars per trade.
 
Property Value
A double value that represents the average number of bars per trade.
 
Syntax
<TradeCollection>.TradesPerformance.AverageBarsInTrade
 
 
 
Examples
Definition
Returns the average entry efficiency.
 
Property Value
A double value that represents the average entry efficiency.
 
Syntax
<TradeCollection>.TradesPerformance.AverageEntryEfficiency
 
 
 
Examples
Definition
Returns the average duration of a trade weighted by quantity.
 
Property Value
A TimeSpan value that represents the quantity-weighted average duration of a trade.
 
Syntax
<TradeCollection>.TradesPerformance.AverageTimeInMarket
 
 
 
Examples
Definition
Returns the average duration of a trade weighted by quantity.
 
Property Value
A TimeSpan value that represents the quantity-weighted average duration of a trade.
 
Syntax
<TradeCollection>.TradesPerformance.AverageTimeInMarket
 
 
 
Examples
Definition
Returns the average total efficiency.
 
Property Value
A double value that represents the average total efficiency.
 
Syntax
<TradeCollection>.TradesPerformance.AverageTotalEfficiency
 
 
 
Examples
Definition
Returns the total commission.
 
Property Value
A double value that represents the total commission.
 
Syntax
<TradeCollection>.TradesPerformance.TotalCommission
 
 
Examples
 
Definition
Returns a TradesPerformanceValues object in currency.
 
Property Value
A TradesPerformanceValues object that is represented in currency.
 
Syntax
<TradeCollection>.TradesPerformance.Currency
 
 
 
Examples
Definition
Returns the gross loss.
 
Property Value
A double value that represents the gross loss.
 
Syntax
<TradeCollection>.TradesPerformance.GrossLoss
 
 
 
Examples
Definition
Returns the gross profit.
 
Property Value
A double value that represents the gross profit.
 
Syntax
<TradeCollection>.TradesPerformance.GrossProfit
 
 
 
Examples
Definition
Returns the longest duration of being flat.
 
Property Value
A TimeSpan value that represents the longest duration of being flat.
 
Syntax
<TradeCollection>.TradesPerformance.LongestFlatPeriod
 
 
 
Examples
Definition
Returns the maximum number of consecutive losers seen.
 
Property Value
An int value that represents the maximum number of consecutive losers seen.
 
Syntax
<TradeCollection>.TradesPerformance.MaxConsecutiveLoser
 
 
 
Examples
Definition
Returns the maximum number of consecutive winners seen.
 
Property Value
An int value that represents the maximum number of consecutive winners seen.
 
Syntax
<TradeCollection>.TradesPerformance.MaxConsecutiveWinner
 
 
 
Examples
Definition
Returns the maximum time to recover from a draw down.
 
Property Value
A TimeSpan value that represents the maximum time to recover from a draw down.
 
Syntax
<TradeCollection>.TradesPerformance.MaxTimeToRecover
 
 
Examples
Definition
Returns the monthly standard deviation.
 
Property Value
A double value that represents the monthly standard deviation.
 
Syntax
<TradeCollection>.TradesPerformance.MonthlyStdDev
 
 
 
Examples
Definition
Returns the monthly Ulcer index.
 
Property Value
A double value that represents the monthly Ulcer index.
 
Syntax
<TradeCollection>.TradesPerformance.MonthlyUlcer
 
 
 
Examples
Definition
Returns the net profit.
 
Property Value
A double value that represents the net profit.
 
Syntax
<TradeCollection>.TradesPerformance.NetProfit
 
 
Examples
Definition
Returns a collection of custom Performance Metrics. These need to have been enabled in Tools > Options > General to be able to use them.
 
Syntax
<TradeCollection>.TradesPerformance.PerformanceMetrics
 
 
Examples
 
Definition
Returns a TradesPerformanceValues object in pips.
 
Property Value
A TradesPerformanceValues object that is represented in pips.
 
Syntax
<TradeCollection>.TradesPerformance.Pips
 
 
Examples
 
Definition
Returns a TradesPerformanceValues object in points.
 
Property Value
A TradesPerformanceValues object that is represented in points.
 
Syntax
<TradeCollection>.TradesPerformance.Points
 
 
Examples
 
Definition
Returns the profit factor.
 
Property Value
A double value that represents the profit factor.
 
Syntax
<TradeCollection>.TradesPerformance.ProfitFactor
 
 
Examples
 
The methods and properties covered in this section are unique to custom strategy development.
 
In this section
Definition
Adds an instance of custom Performance Metric to a strategy used in strategy calculations.
 
Method Return Value
This method does not return a value.
 
Syntax
AddPerformanceMetric(PerformanceMetricBase performanceMetric)
 
 
 
Parameters
 
 
 
Examples
 
Release Date
February 16, 2016
 
This is a general maintenance release which includes various bug fixes due to feedback received during beta. Please note that as this is a maintenance release, there are still outstanding bugs which were reported in previous beta versions and this release does not guarantee all previously reported bugs have been resolved.  If you cannot find the status of a bug you previously reported using the table below, please feel free to contact our support team with the tracking ID which was provided at the time the bug was reported (e.g., NTEIGHT-1234)
 
 
 
 
 
Code Breaking Changes
 
 
•SetTrailStop(), SetStopLoss(), SetProfitTarget() - removed redundant double type ""currency"" overloaded.  Set CalculationMode enum instead e.g., SetTrailStop(CalculationMode.Price, Low[0])
•DrawingTools.ChartAnchor - removed ChartAnchor constructor with int type ""barsAgo"" parameter as it was problematic.  Use DateTime time values to build your drawing tools chart anchor objects instead.
•Bars.SessionIterator object was removed due to complications with some bar types.  You can use your own custom SessionIterator built from a Bars object instead.  
a.For Indicators, please see the system Custom\Indicators @CurrentDayOHL.cs, @Pivots.cs, PriorDayOHLC.cs, or the examples in the SessionIterator Help guide section for examples of correct indicator usage.  
b.For custom Bar Types, please see the BarsType.SessionIterator Help Guide page, or any of the system Custom\BarTypes installed by default.
•There were several changes to PerformanceMetrics.  These changes will NOT affect any strategy/system performance calculations, but if you develop own custom PerformanceMetric please be aware of the changes listed below.  You may also review the PerformanceMetric @SampleCumProfit.cs for an example of correct usage.
a.PerformanceMetric.ValueArrayLength was removed as it is no longer need
b.Added new OnCopyTo() method
c.OnMergePerformanceMetric() has a reversed the target/source logic to be in sync with new OnCopyTo() method
 
Notes

Understanding the SharpDX .NET Library
NinjaTrader Chart objects (such as Indicators, Strategies, DrawingTools, ChartStyles) implement an OnRender() method aimed to render custom lines, shapes, and text to the chart.  To achieve the level of performance required to keep up with market data events, NinjaTrader uses a 3rd-party open-source .NET library named SharpDX.  This 3rd party library provides a C# wrapper for the powerful Microsoft DirectX API used for graphics processing and known for its hardware-accelerated performance, including 2D vector and text layout graphics used for NinjaTrader Chart Rendering.  The SharpDX/DirectX library is extensive, although NinjaTrader only uses a handful of namespaces and classes, which are documented as a guide in this reference.  In addition to this educational resource, we have also compiled a more focused collection of SharpDX SDK Reference resources to help you learn the SharpDX concepts used in NinjaTrader Chart Rendering.
 
 
There are three main SharpDX namespaces you need to be familiar with:
 
 
The rest of this page will help you navigate the fundamental concepts needed to achieve custom rendering to your charts.
        SharpDX Vectors and Charting Coordinates
permalink
        SharpDX Brush Resources
permalink
        SharpDX RenderTarget
permalink
        SharpDX Lines and Shapes
permalink
        SharpDX Text Rendering
permalink
        SharpDX Stroke Style
permalink
         Best Practices for SharpDX Resources
permalink
Definition
Called as the values of a trade metric are saved.
 
Syntax
protected override void OnCopyTo(PerformanceMetricBase target)
{
 
}
 
Examples
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 

"
Performance Optimization.docx,"Los siguientes consejos de rendimiento son específicos de la ventana Market Analyzer .
 
Número de instrumentos y columnas.
•Market Analyzer no tiene límite para la cantidad de instrumentos que se pueden agregar. Es importante monitorear los recursos de la computadora para comprender el límite de su PC.
•Market Analyzer no tiene límite para la cantidad de columnas, específicamente columnas indicadoras, que se pueden agregar. Dependiendo del indicador y la propiedad ""Marco de tiempo"" que se describe a continuación, puede tomar algunos segundos calcular el indicador. Este tiempo se multiplica por la cantidad de instrumentos en el Market Analyzer que puede resultar en unos minutos de tiempo de carga. Disminuya el número de instrumentos o columnas indicadoras para disminuir este tiempo de carga.
 
Columnas Indicadoras
•La propiedad Marco de tiempo (""Barras para cargar"", ""Días atrás"", ""Rango personalizado"") determina el número mínimo de barras requerido para inicializar correctamente cada columna de indicador. Cuanto mayor sea el número, más tardará en cargar los datos y más memoria (RAM) usará NinjaTrader para mantener los datos en la memoria.
•Cada indicador tiene un parámetro Retrospectiva de barras máximas en la ventana Columnas que determina cuántos valores de indicadores históricos se almacenan para el acceso. Está configurado en TwoHundredFiftySix de forma predeterminada para un rendimiento óptimo. Establecer esto en Infinito tomará más tiempo para calcular y NinjaTrader usará más memoria (RAM) para mantener los valores adicionales en la memoria.
 
Indicador Calcular en parámetro de cierre de barra
•Todos los indicadores agregados a Market Analyzer tienen el parámetro ""Calcular"" establecido en ""Al cerrar la barra"" de forma predeterminada, que solo calcula el valor del indicador en la barra cercana para ayudar con el rendimiento de la PC.  Este parámetro se puede configurar opcionalmente en ""En cambio de precio"", que solo se calculará cuando haya habido un cambio en el precio, o en ""En cada tic"" que permita un cálculo tick por tick (que utilizará más recursos de CPU).  
 
Clasificación dinámica y frecuencia de clasificación
•Dependiendo de la cantidad de instrumentos que haya agregado a supantalla deMarket Analyzer, el uso de un valor bajo de ""Clasificación automática de segundos"" puede hacer que su CPU se dispare a medida que la función de clasificación automática continúa reevaluando la clasificación de la columna que está clasificando.  Por ejemplo, usar un valor de 1 segundo en 100 instrumentos podría sobrecargar su CPU.  Establecer esto en un valor más alto, como cada 10-30 segundos, reducirá la carga de trabajo de la CPU y seguirá manteniendo la ordenación dinámica en un intervalo personalizable.  Debe monitorear la carga de trabajo de su CPU para encontrar la cantidad de segundos que funcionan para su sistema.
Market Analyzer se puede personalizar según sus preferencias en la ventana Propiedades de Market Analyzer.
 
        Cómo acceder a la ventana de propiedades de Market Analyzer
permalink
 
        Propiedades disponibles y definiciones 
permalink
 
        Cómo preestablecer valores predeterminados de propiedad
permalink
 
Factores de rendimiento
Hay muchas variables que contribuyen al rendimiento general de laaplicaciónNinjaTrader.
 
•Los diferentes proveedores de conectividad (proveedores de datos del mercado y tecnologías de intermediario) que admite NinjaTrader varían en su nivel de servicio de datos en tiempo real. Por ejemplo, los proveedores que entregan datos de ticks sin filtrar (enviar todos los ticks de mercado) impondrán una mayor carga de procesamiento que un proveedor que proporciona datos de mercado limitados.
•La carga que coloque en laaplicaciónNinjaTrader (la ejecución de 200 gráficos consumirá más poder de procesamiento que la ejecución de solo 20 gráficos)
•La capacidad del hardware de su PC (¿está ejecutando una nueva máquina de última generación o una PC de 4 años con RAM limitada)?
•Una sola ""configuración"" incorrecta puede causar problemas de rendimiento y una única secuencia de comandos de terceros activa puede causar un problema de rendimiento general. Consulte lasecciónComprender el impacto de instalar complementos.
 
 
 
Optimizar el rendimiento
Las siguientes son algunas sugerencias que pueden ayudarlo a ajustar lainstalación deNinjaTrader para que se ejecute de manera óptima.
 
1.Cierre cualquier espacio de trabajo abierto innecesario. Aunque es posible que un área de trabajo no esté a la vista, aún utiliza los recursos del sistema cuando está abierto.
2.Salga de cualquier gráfico innecesario, SuperDOM, analizadores de mercado, etc. en su (s) espacio (s) de trabajo abierto (s). Además, si tiene varias pestañas en las ventanas que no necesita, salga de ellas.
3.Asegúrese de que todos los indicadores aplicados utilicen la configuración Calcular de Cambio de precio o Cierre de barra. No hay ningún beneficio al usar En cada marca a menos que el indicador se ocupe del conteo de volumen o marca.
4.Elimine los indicadores innecesarios de Gráficos, Analizadores de mercado y SuperDOM.
5.Reduzca los días para cargar en gráficos y en las columnas de indicadores de Market Analyzer. Esto puede ser especialmente efectivo con cualquier serie basada en ticks.
6.Use Tick Replay con moderación y solo cuando sea necesario. Por ejemplo, un indicador Pivot simple que solo usa los niveles de precios diarios actuales y anteriores no vería ninguna ventaja al usar la reproducción de ticks. En contraste, un indicador de perfil de volumen que se basa en la secuencia exacta de operaciones para calcular varios niveles se beneficiaría enormemente del uso de la repetición de ticks.
7.Eliminar objetos de dibujo innecesarios. Especialmente con el tiempo, ya que tiene más objetos de dibujo en sus gráficos, el rendimiento puede disminuir ya que hay más que representar.
8.Los espacios de trabajo que tienen un número único o menor de instrumentos no pueden aprovechar los procesadores de varios núcleos. Por ejemplo, tener 30 gráficos con el mismo instrumento no funcionará tan bien como 30 gráficos de diferentes instrumentos en un procesador multi-core. Reducir el número de ventanas con el mismo instrumento puede aumentar el rendimiento. Alternativamente, los espacios de trabajo que tienen uno o solo unos pocos instrumentos se beneficiarían de un procesador con una velocidad de reloj más alta.
9.Reduzca la cantidad de gráficos con la mira global habilitada.
10.Establezca la cruz para dibujar solo el cursor. Los sistemas con GPU menos potentes pueden beneficiarse de la reducción de la ruptura que resulta en este cambio. Esta configuración está dentro de las propiedades del gráfico.
11.Restablecer y borrar el historial de su cuenta de simulación. Una gran cantidad de operaciones simuladas puede aumentar el tamaño de su base de datos. Si no necesita esta información histórica, completar este paso liberará más recursos.
12.ReinicieNinjaTraderdiariamente.
13.Deshabilite la grabación de mercado para Reproducir y Grabar datos en vivo como históricos si no son necesarios.
14.Notas: ""Guardar datos de gráficos como históricos"" solo debe verificarse si utiliza un proveedor de conectividad que NO proporciona datos históricos. Muchos de los instrumentos de forex y futuros más populares están grabados en nuestros servidores y están disponibles para descargarlos para su reproducción.
15.La propiedad ""Mostrar texto de volumen"" en la columna Volumen de SuperDOM puede afectar el rendimiento de la PC y la velocidad de representación de los objetos en el SuperDOM. Esta propiedad está deshabilitada de manera predeterminada para minimizar el impacto en el rendimiento y, cuando está deshabilitada, puede colocar el cursor del mouse sobre cualquier fila de Volumen para ver el volumen exacto en esa fila.
16.Algunas configuraciones de computadora proporcionan dos tarjetas gráficas (integradas vs. dedicadas).  Para aprovechar al máximo el rendimiento de representación de gráficos, habilite un procesador gráfico dedicado de alto rendimiento.
17.Utilice una conexión a internet por cable. Las conexiones inalámbricas y por satélite pueden dejar caer paquetes o tener una latencia pobre. Si una conexión de baja latencia no está disponible, un VPS puede ser una gran solución.
18.Configure su conexión para conectarse en el arranque. Esto hará que su espacio de trabajo solo necesite cargarse una vez, en lugar de una vez cuando inicie NinjaTrader, y una segunda vez cuando se descarguen nuevos datos después de conectarse.
19.Reduzca la cantidad de aplicaciones que se ejecutan en su sistema.
20.La indexación de búsqueda de Windows también puede suponer una carga adicional para su procesador cuando ejecutaNinjaTrader, lo que afecta negativamente el rendimiento. También se recomienda excluir de la indexación las carpetas enumeradas a continuación, lo que puede hacerse a través del Panel de control de Windows.
 C:\Users\User\Documents\NinjaTrader 8
 C:\Program Files (x86)\NinjaTrader 8
 
Reproducción
1.Eliminar las suscripciones de instrumentos no utilizados en la reproducción. En su configuración de reproducción, tenga en cuenta los instrumentos que ha agregado (por ejemplo, en un Market Analyzer o mediante Cartas) que tendría datos para reproducir realmente disponibles, ya que cada suscripción de instrumento aquí consumiría ciclos de CPU y, por lo tanto, contribuiría al rendimiento experimentado. Por ejemplo, tener el índice SP500 agregado en su Market Analyzer, pero luego solo se espera que la reproducción de datos de MSFT tenga un rendimiento más bajo en comparación con tener solo este instrumento MSFT incluido en Market Analyzer también.
 
Diagnósticos adicionales
Si aún tiene problemas de rendimiento, siga estos pasos de diagnóstico para aislar el problema.
 
1.Inicia NinjaTrader en modo seguro.
 El Modo seguro evitará que NinjaTrader:
         Cargando espacios de trabajo.
         Conexión en la puesta en marcha.
         Cargando ensamblajes personalizados.
         Obteniendo actualizaciones de instrumentos desde el servidor.
 
 Para habilitar el modo seguro, siga los siguientes pasos:
         Salir NinjaTrader.
         Mantenga presionada la tecla CONTROL y haga doble clic en elicono deNinjaTrader.
         Mantenga presionada la tecla CONTROL hasta que vea el Centro de control.
         Puede verificar que está en modo seguro yendo a Ayuda -&gt; Acerca de.
2.Abra algunas ventanas y pruebe el rendimiento sin cargar ningún indicador personalizado.
3.Si todo se ve bien, intenta abrir tu espacio de trabajo. Es posible que deba cerrar su área de trabajo, sin guardarla y volver a abrirla. Si esto funciona bien, los montajes personalizados instalados pueden ser la causa.
4.Si el rendimiento es deficiente con el área de trabajo en modo seguro, podría ser que el área de trabajo tenga demasiados recursos para su sistema, que puede ser de los scripts que se están utilizando.
5.Para determinar si hay secuencias de comandos específicas que tienen como resultado un rendimiento deficiente, deberá volver a crear su área de trabajo y agregar las secuencias de comandos de una en una para ver cuál de ellas puede resultar en un rendimiento deficiente.
6.Para obtener más ayuda o asistencia con cualquiera de estos pasos, escriba aplatformupport@ninjatrader.com
Complementos de terceros
El entorno de desarrollo integral y flexible de NinjaTrader permite a los Desarrolladores de terceros desarrollar aplicaciones ricas e integradas. Estos complementos permiten una personalización infinita
        Instalación de complementos
permalink
 
        Comprender el impacto de instalar complementos
permalink
 
        Actualización y eliminación de complementos
permalink
 
        Deshabilitar temporalmente los complementos
permalink
 
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
Definition
This method calculates the value for the Optimization Fitness.
 
Syntax
protected override void OnCalculatePerformanceValue(StrategyBase strategy)
{
 
}
 
 
Examples
Definition
The value an optimization would be calculating against when using this Optimization Fitness.
 
Property Value
A double value.
 
Syntax
Value
 
 
Examples
Definition
Determines if the strategy will save orders, trades, and execution history. When this property is set to false you will see significant memory savings at the expense of having access to the detailed trading information.
 
 
 
Property Value
This property returns true if the strategy will include trade history; otherwise, false. Default is set to true.  Always false during a strategy analyzer optimization on a 32-bit process.
 
 
 
Syntax
IncludeTradeHistoryInBacktest
 
Examples
Puede ajustar los parámetros de entrada de una estrategia a través de la optimización. La optimización es el proceso de probar un rango de valores a través de pruebas repetitivas iterativas para determinar los valores de entrada óptimos durante el período de prueba histórico en función de su capacidad de optimización. Para ejecutar una optimización, necesitará:
 
•Acceso a datos históricos.
•Costumbre NinjaScript * estrategia
•Una comprensión profunda de las capacidades de backtesting de Strategy Analyzer
 
 
        Cómo ejecutar una optimización
permalink
 
        Comprender las propiedades de optimización
permalink
 
        Comprender los resultados de optimización
permalink
 
        Ejecutando una prueba de canasta
permalink
 
        Comprender los factores que afectan el rendimiento de la optimización.
permalink
 
 
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Definition
Holds an array of ISeries<double> objects holding hold the indicator's underlying calculated values. ISeries<double> values are added to this array when calling the AddPlot() method. In case of a MultiSeries indicator synched to the primary series.
 
Property Value
A collection of ISeries<double> objects.
 
Syntax
Values[int index]
 
 
Examples
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Definition
This method calculates the value for the Optimization Fitness.
 
Syntax
protected override void OnCalculatePerformanceValue(StrategyBase strategy)
{
 
}
 
 
Examples
Definition
The value an optimization would be calculating against when using this Optimization Fitness.
 
Property Value
A double value.
 
Syntax
Value
 
 
Examples


"
Plots and Lines Implementation Guide.docx,"The OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method called for indicator calculation, and we will calculate the CCI value and set the conditions used to draw the CCI plot within this method.
 
The OnStateChange() method is called once before any bar data is loaded, and is used to configure the indicator (among other things).
 
Initializing the Indicator
The code below is automatically generated by the wizard and added to the OnStateChange() method, within State.SetDefaults. It configures the indicator for one plot and five lines, and sets the parameters entered in the wizard:
 
 
To change the visual properties of the Zero Line, replace the third line in the code above with the line below. This will change the color to black and the line style to ""dash:""
 
 
The code above uses an alternative method overload (an alternative set of arguments passed in to the AddLine() method), in order to pass in a Stroke object rather than a Brush. With a Stroke, not only can we still specify a Brush, but we have additional options to change the dash style (via DashStyleHelper) and the line width. After this change, your configured lines and plots should look like this:
 
 
Adding Core Indicator Logic
Since this tutorial is meant to cover custom drawing and manually changing properties within an indicator, we will not go too in-depth into the core calculation logic for this custom CCI. Instead, we will copy and paste the core calculation logic from the @CCI indicator already built-in to NinjaTrader.
 
The @CCI indicator uses an SMA object in its calculations. To add this, copy the line below from @CCI into your custom CCI, directly below the class declaration:
 
 
Next, copy the following initialization for the SMA object into the OnStateChange() method, within State.Configure:
 
 
Next, copy the core calculation logic from @CCI into the OnBarUpdate() method of your custom indicator:
 
 
The code for your MyCCI class should now look as follows (in addition to the using statements and class declaration) :
 
 
Custom Drawing
Add the following code into the OnBarUpdate() method, directly beneath the core calculation logic:
 
 
This will conditionally change the color of the CCI plot (referenced by Values[0]) based on its value. By using PlotBrushes[0][0], we are specifying that we wish to change the color of the first plot in the collection at a specific bar index (the current bar index each time the condition is triggered), and we wish for the plot the remain that color at that index, even if the plot value changes in the future. If instead we wished to change the entire plot color, we could use Plots[0].Brush.
 
PlotBrushes holds a collection of brushes used for the various plots in the indicator. In addition to this, there are several other collections that serve similar purposes, which can be used in the same way. Some examples of these collections are below:
 
 
Now that everything is in place, your class code should look as below. You are now ready to compile the indicator and configure it on a chart.
 
Release Date
July 11, 2016
 
Code Breaking Changes
Compile Errors
•The NinjaScript Strategy ""AccountSize"" concept was removed due to limited functionality.  This change would also impact strategies which were coded to use SetOrderQuantity.ByAccountSize.  Please use your own variables to set quantities by account size. Tip:  NinjaTrader 8 can read real-world account values for live trading purposes through the Account class, e.g., Account.Get(AccountItem.CashValue, Currency.UsDollar) provides a method for returning a double value representing the current cash value of the account.
 
Implementation changes
•The concept used to force plot series objects through ForcePlotsMaximumBarsLookBackInfinite was disabled and tagged as obsolete.  You should set any indicator/strategy plots to MaximumBarsLookBack.Infinite during its construction.
•It is recommended that any strategies generated with the 'Strategy Builder' tool via Control Center > New > Strategy Builder be removed and recreated after installing B12. If you had invested significant effort in a Strategy Builder generated strategy in B11 which you would like to continue to use, please contact us platformsupport@ninjatrader.com
 
Notes
Release Date
May 12, 2016
 
Code Breaking Changes
Compile Errors
•Draw.RegionHighlightY(), Draw.ArrowLine() – Added missing ""isAutoScale"" bool to some signatures
 
Implementation changes
•In some scenarios, the OnRender() method no longer guarantees the bars indexer to be up to date before it is called. Due to the multi-threaded nature of NinjaTrader, attempting to access a series barsAgo value could return seemingly unexpected results (E.g., Close[0], SMA(20)[0], etc).  This change does NOT impact data driven events, such as OnBarUpdate(), OnMarketData(), OnOrderUpdate(), etc.  For all OnRender() purposes, you should consider using an absolute index lockup through Bars.GetClose(barIndex), or <series>.GetValueAt(barIndex) which are generally more reliable in non-data driven events.  Please also see the new IsValidDataPointAt() which was added to help with absolute index look up.
 
•Type Casting DrawObjects can fail from a compiled assembly.  In situations where you need to cast a draw object in an assembly, it is recommended you use the dynamic type and compare the object type by its string.  This is not required for non-protected scripts.  Please see the help guide article on Considerations For Compiled Assemblies for more details and examples.
 
Notes
 
 

"
series lSeries.docx,"Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Price Data Overview
The core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.
 
Definitions
 
 
Referencing Series
 
You will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:
 
 High[1] < High[0];
 
You could write a statement to calculate the average closing price of the last three bars like this:
 
 ( Close[2] + Close[1] + Close[0] ) / 3;
 
As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.
 
 
 
Referencing Indicator Data
NinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.
 
All indicator values can be accessed in the following way:
 
 indicator(parameters)[int barsAgo]
 
where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.
 
As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:
 
 Close[0] > SMA(20)[0];
 
If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:
 
 Close[0] > SMA(High, 20)[0];
 
You could write a statement to see if a 14 period CCI indicator is rising like this:
 
 CCI(14)[0] > CCI(14)[1];
 
Value of a 10 period CCI 1 bar ago = CCI(10)[1]
 
Please review the Indicator Methods section for proper syntax for accessing different indicator values.
Definition
Adds a Bars object for developing a multi-series (multi-time frame or multi-instrument) NinjaScript.
 
Related Methods and Properties
 
 
Syntax
The following syntax will add another Bars object for the primary instrument of the script.
AddDataSeries(BarsPeriod barsPeriod)
AddDataSeries(BarsPeriodType periodType, int period)
 
The following syntax allows you to add another Bars object for a different instrument to the script:
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period)
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period, MarketDataType marketDataType)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, int barsToLoad, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName) //only for R15 and higher
 
 
 
Parameters
 
 
 
 
Examples
 
 
Adding additional series to a script can be useful. You may also want to use this added data for an indicator's Input Series.
 
Key concepts in this example
•Adding series
•Supplying a series object to an indicator as the input series parameter
•Plotting using data from two different series
 
Important related documentation
•AddDataSeries()
•AddPlot()
•IsValidDataPoint()
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
SampleSecondarySeriesAsInputSeries_NT8.zip
//
// Copyright (C) 2018, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA);
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				if (CurrentBar == 0)
					Value[0] = Input[0];
				else
				{
					double last = Value[1] * Math.Min(CurrentBar, Period);

					if (CurrentBar >= Period)
						Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);
					else
						Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));
				}
			}
			else
			{
				if (IsFirstTickOfBar)
					priorSum = sum;

				sum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
				Value[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Indicators in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Indicators
{
	public class SampleSecondarySeriesAsInputSeries : Indicator
	{
		private SMA sma1;
		private SMA sma2;
		
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description									= @"""";
				Name										= ""SampleSecondarySeriesAsInputSeries"";
				Calculate									= Calculate.OnBarClose;
				IsOverlay									= true;
				DisplayInDataBox							= true;
				
				BarsRequiredToPlot							= 14;
				
				AddPlot(Brushes.Blue, ""SMA Primary Series"");
				AddPlot(Brushes.Green, ""SMA Secondary Series"");
			}
			else if (State == State.Configure)
			{
				// Adds a secondary bar object to the indicator
				AddDataSeries(BarsPeriodType.Minute, 5);
			}
			else if (State == State.DataLoaded)
			{
				// initialize the SMA using the primary series and assign to sma1
				sma1 = SMA(BarsArray[0], 14);
				// initialize the SMA using the secondary 5 minute series and assign to sma1
				sma2 = SMA(BarsArray[1], 14);
			}
		}

		protected override void OnBarUpdate()
		{
			// ensure both series have at least one bar
			if (CurrentBars[0] < 1 || CurrentBars[1] < 1)
				return;			
			
			// when the 5 minute series is processing set the secondary plot to the sma with the secondary series input
			if (BarsInProgress == 1)
				SMASecondary[0] = sma2[0];
			
			// when the primary series is processing set the primary plot to the sma with the primary series input
			if (BarsInProgress == 0)
			{
				SMAPrimary[0] = sma1[0];
				
				// if the secondary 5 minute series did not close, set the current bar's value to the previous bar's value to prevent gaps 
				if (!SMASecondary.IsValidDataPoint(0))
					SMASecondary[0] = SMASecondary[1];
			}
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> SMAPrimary
		{
			get { return Values[0]; }
		}
		
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> SMASecondary
		{
			get { return Values[1]; }
		}
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleSecondarySeriesAsInputSeries[] cacheSampleSecondarySeriesAsInputSeries;
		public SampleSecondarySeriesAsInputSeries SampleSecondarySeriesAsInputSeries()
		{
			return SampleSecondarySeriesAsInputSeries(Input);
		}

		public SampleSecondarySeriesAsInputSeries SampleSecondarySeriesAsInputSeries(ISeries<double> input)
		{
			if (cacheSampleSecondarySeriesAsInputSeries != null)
				for (int idx = 0; idx < cacheSampleSecondarySeriesAsInputSeries.Length; idx++)
					if (cacheSampleSecondarySeriesAsInputSeries[idx] != null &&  cacheSampleSecondarySeriesAsInputSeries[idx].EqualsInput(input))
						return cacheSampleSecondarySeriesAsInputSeries[idx];
			return CacheIndicator<SampleSecondarySeriesAsInputSeries>(new SampleSecondarySeriesAsInputSeries(), input, ref cacheSampleSecondarySeriesAsInputSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleSecondarySeriesAsInputSeries SampleSecondarySeriesAsInputSeries()
		{
			return indicator.SampleSecondarySeriesAsInputSeries(Input);
		}

		public Indicators.SampleSecondarySeriesAsInputSeries SampleSecondarySeriesAsInputSeries(ISeries<double> input )
		{
			return indicator.SampleSecondarySeriesAsInputSeries(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleSecondarySeriesAsInputSeries SampleSecondarySeriesAsInputSeries()
		{
			return indicator.SampleSecondarySeriesAsInputSeries(Input);
		}

		public Indicators.SampleSecondarySeriesAsInputSeries SampleSecondarySeriesAsInputSeries(ISeries<double> input )
		{
			return indicator.SampleSecondarySeriesAsInputSeries(input);
		}
	}
}

#endregion
Definition
Returns the underlying input value at a specified bar index value.
 
Method Return Value
A double value representing the value at a specified bar.
 
Syntax
GetValueAt(int barIndex)
ISeries<T>.GetValueAt(int barIndex)
 
 
Parameters
 
 
Examples
Definition
Holds an array of ISeries<double> objects holding hold the indicator's underlying calculated values. ISeries<double> values are added to this array when calling the AddPlot() method. In case of a MultiSeries indicator synched to the primary series.
 
Property Value
A collection of ISeries<double> objects.
 
Syntax
Values[int index]
 
 
Examples
Definition
Indicates the number total number of values in the ISeries<T> array.  This value should always be in sync with the CurrentBars array for that series.
 
Method Return Value
A int representing the total size of the series
 
Syntax
Count
 
 
Examples
Definition
The number of historical bars required before the strategy starts processing order methods called in the OnBarUpdate() method. This property is generally set via the UI when starting a strategy.
 
 
 
Property Value
An int value representing the number of historical bars.  Default value is set to 20.
 
 
 
Syntax
BarsRequiredToTrade
 
 
 
Examples
 
 
 
 
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
Holds an array of ISeries<double> objects holding hold the indicator's underlying calculated values. ISeries<double> values are added to this array when calling the AddPlot() method. In case of a MultiSeries indicator synched to the primary series.
 
Property Value
A collection of ISeries<double> objects.
 
Syntax
Values[int index]
 
 
Examples
Definition
Indicates the number total number of values in the ISeries<T> array.  This value should always be in sync with the CurrentBars array for that series.
 
Method Return Value
A int representing the total size of the series
 
Syntax
Count
 
 
Examples
Definition
Represents historical time stamps as an ISeries<DateTime> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<DateTime>
 
 
Multi-Time Frame ISeries<DateTime>
 
Definition
Represents historical volume data as ISeries<double> interface which can be used for custom NinjaScript object calculations
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Definition
Indicates if the specified input is set at a barsAgo value relative to the current bar.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
Syntax
IsValidDataPoint(int barsAgo)
ISeries<T>.IsValidDataPoint(int barsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Indicates if the specified input is set at a specified bar index value.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
 
 
Syntax
IsValidDataPointAt(int barIndex)
ISeries<T>.IsValidDataPointAt(int barIndex)
 
Parameters
 
 
Examples


"
Series y ISeries completo.docx,"Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Definition
Represents historical data as an ISeries<double> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Definition
Represents historical time stamps as an ISeries<DateTime> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<DateTime>
 
 
Multi-Time Frame ISeries<DateTime>
 
Definition
Represents historical volume data as ISeries<double> interface which can be used for custom NinjaScript object calculations
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Price Data Overview
The core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.
 
Definitions
 
 
Referencing Series
 
You will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:
 
 High[1] < High[0];
 
You could write a statement to calculate the average closing price of the last three bars like this:
 
 ( Close[2] + Close[1] + Close[0] ) / 3;
 
As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.
 
 
 
Referencing Indicator Data
NinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.
 
All indicator values can be accessed in the following way:
 
 indicator(parameters)[int barsAgo]
 
where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.
 
As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:
 
 Close[0] > SMA(20)[0];
 
If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:
 
 Close[0] > SMA(High, 20)[0];
 
You could write a statement to see if a 14 period CCI indicator is rising like this:
 
 CCI(14)[0] > CCI(14)[1];
 
Value of a 10 period CCI 1 bar ago = CCI(10)[1]
 
Please review the Indicator Methods section for proper syntax for accessing different indicator values.
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create ""myDoubleSeries"" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the ""myDoubleSeries"" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a ""barsAgo"" value of ""0"" or, for historical bars, by choosing a ""barsAgo"" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
// 
// Copyright (C) 2016, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA);
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				if (CurrentBar == 0)
					Value[0] = Input[0];
				else
				{
					double last = Value[1] * Math.Min(CurrentBar, Period);

					if (CurrentBar >= Period)
						Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);
					else
						Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));
				}
			}
			else
			{
				if (IsFirstTickOfBar)
					priorSum = sum;

				sum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
				Value[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
     public class SampleCustomSeries : Indicator
     {		
		// Defines the Series object
		private Series<double> myDoubleSeries;

        protected override void OnStateChange()
        {
			if (State == State.SetDefaults)
			{
				// Adds a plot to our NinjaScript Indicator
	            AddPlot(new Stroke(Brushes.Orange, 1), PlotStyle.Bar, ""Average Range"");
				
				Period					= 5;
				Name					= ""Sample custom series"";
	            Calculate				= Calculate.OnBarClose;
	            IsOverlay				= false;
			}
			
			else if (State == State.DataLoaded)
			{
				// Create a new Series object and assign it to the variable myDoubleSeries declared in the ‘Variables’ region above
				myDoubleSeries = new Series<double>(this);
			}
        }

        protected override void OnBarUpdate()
        {
			/* To set values to our Series object we use the [] method. Here we are setting the DataSeries
			object for the current bar to take on the absolute value of the difference between the current bar's
			open and close. */
			
			myDoubleSeries[0] = Math.Abs(Close[0] - Open[0]);
			
			/* Take note that the method for setting the value to be plotted is the same as for setting a value
			to a DataSeries object. The difference here is that the custom DataSeries object is not plotted while
			this ""Average Range"" is plotted.
			
			In this case we are plotting the Simple Moving Average of the intermediate calculation step stored in our
			Series object. */
			
            Value[0] = SMA(myDoubleSeries, Period)[0];
        }

        #region Properties
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = ""Period"", GroupName = ""NinjaScriptParameters"", Order = 0)]
		public int Period
		{ get; set; }

		#endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleCustomSeries[] cacheSampleCustomSeries;
		public SampleCustomSeries SampleCustomSeries(int period)
		{
			return SampleCustomSeries(Input, period);
		}

		public SampleCustomSeries SampleCustomSeries(ISeries<double> input, int period)
		{
			if (cacheSampleCustomSeries != null)
				for (int idx = 0; idx < cacheSampleCustomSeries.Length; idx++)
					if (cacheSampleCustomSeries[idx] != null && cacheSampleCustomSeries[idx].Period == period && cacheSampleCustomSeries[idx].EqualsInput(input))
						return cacheSampleCustomSeries[idx];
			return CacheIndicator<SampleCustomSeries>(new SampleCustomSeries(){ Period = period }, input, ref cacheSampleCustomSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

#endregion
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
In C#, square brackets represent a way to access values stored within an collection. NinjaScript comes with quite a few collections that we call ISeries objects which could be accessed with square brackets. ISeries objects are linked to the underlying bars series in that they hold the same number of values as the number of bars on a chart. For example, to get the close price one bar ago, you would use Close[1] since the value of 1 within the square brackets represents the number of bars ago whose value you wish to reference. As another example, to get the high three bars ago, you would use High[3].
 
 
Many of NinjaTrader's indicators store their values in Series as well, generally in a Plot. Plots are essentially a Series<double> object and to retrieve values from them you need to specify which value you want to access. In most cases, you'd like the current value, so you could use SMA(14)[0], not just SMA(14). SMA(14) is the Indicator its self or Series, and you can't access its values by calling it directly. Using SMA(14)[0] retrieves the part of the Series you're interested in--the most current value.
 
 
Most of the time, you need an index value (number in the square brackets), but there are also cases when you need to use the ISeries instead. CrossAbove() and CrossBelow() are two key examples. If you look at the reference page for CrossAbove(), the two method signatures (overloads) look like this:
 
 
This means the first variable must always be a ISeries<double> object, and the second variable can be either another ISeries<double> or a double value (100, 70.25, etc). To specify a ISeries<double> object, you can just leave off the square brackets. For example if(CrossAbove(SMA(14), SMA(28), 1)) checks if the 14 period SMA has crossed above the 28 period SMA within the last bar. if(CrossAbove(SMA(14)[0], SMA(28)[0], 1)) would give you a compile error because it expects a ISeries<double> as input, not a double value (which is returned when an index is present).
 
Definition
Indicates if the specified input is set at a barsAgo value relative to the current bar.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
Syntax
IsValidDataPoint(int barsAgo)
ISeries<T>.IsValidDataPoint(int barsAgo)
 
 
 
Parameters
 
 
Examples
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
Represents historical data as an ISeries<double> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Definition
Represents historical time stamps as an ISeries<DateTime> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<DateTime>
 
 
Multi-Time Frame ISeries<DateTime>
 
Definition
Represents historical volume data as ISeries<double> interface which can be used for custom NinjaScript object calculations
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 


"
Working with Price Series.docx,"Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
The main historical data input. If implemented in the NinjaScript object, it allows for more flexibility as non bars based series such as plot series could be passed in and drive the calculation outcomes - an example would be a custom moving average that should have the ability to operate on another moving average (i.e. the SMA) as input series.
 
Property Value
An ISeries<double> type object that implements the Series<double> interface. Accessing this property via an index value [int barsAgo] returns a double value representing the price of the referenced bar.
 
Syntax
Input
Input[int barsAgo]
 
 
 
Examples
 
 
 
 
Definition
Returns the number of bars elapsed since the start of the trading day relative to the current bar processing.
 
Property Value
An int value representing the number of bars elapsed.  This property cannot be set.
 
Syntax
Bars.BarsSinceNewTradingDay
 
Examples
Definition
Returns the ask price value at a selected absolute bar index value.  
 
 
 
Method Return Value
A double value that represents the asking price at the desired bar index.
 
Syntax
Bars.GetAsk(int index)
 
Parameters
 
Examples
Definition
Returns the first bar that matches the time stamp of the ""time"" parameter provided.  
 
 
 
Method Return Value
An int value representing an absolute bar index value.
 
Syntax
Bars.GetBar(DateTime time)
 
Parameters
 
 
Examples
Definition
Returns the bid price value at a selected absolute bar index value.
 
 
 
Method Return Value
A double value that represents the biding price at the desired bar index.
 
Syntax
Bars.GetBid(int index)
 
Parameters
 
 
Examples
Definition
Returns the closing price at the current bar index value.
 
Method Return Value
A double value that represents the close price at the desired bar index.
 
Syntax
Bars.GetClose(int index)
 
Parameters
 
 
Examples
Definition
Returns a virtual historical Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.
 
 
 
Method Return Value
A virtual bar object representing the current configured session. Otherwise null if there is insufficient intraday data
 
Syntax
The properties below return double values:
Bars.GetDayBar(int tradingDaysBack).Open
Bars.GetDayBar(int tradingDaysBack).High
Bars.GetDayBar(int tradingDaysBack).Low
Bars.GetDayBar(int tradingDaysBack).Close
 
The property below returns a DateTime structure:
Bars.GetDayBar(int tradingDaysBack).Time
 
The property below returns an int value:
Bars.GetDayBar(int tradingDaysBack).Volume
 
 
 
Parameters
 
 
Examples
Definition
Returns a virtual historical Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.
 
 
 
Method Return Value
A virtual bar object representing the current configured session. Otherwise null if there is insufficient intraday data
 
Syntax
The properties below return double values:
Bars.GetDayBar(int tradingDaysBack).Open
Bars.GetDayBar(int tradingDaysBack).High
Bars.GetDayBar(int tradingDaysBack).Low
Bars.GetDayBar(int tradingDaysBack).Close
 
The property below returns a DateTime structure:
Bars.GetDayBar(int tradingDaysBack).Time
 
The property below returns an int value:
Bars.GetDayBar(int tradingDaysBack).Volume
 
 
 
Parameters
 
 
Examples
Definition
Returns the high price at the selected bar index value.
 
Method Return Value
A double value that represents the high price at the desired bar index.
 
Syntax
Bars.GetHigh(int index)
 
Parameters
 
 
Examples
Definition
Returns the low price at the selected bar index value.
 
Method Return Value
A double value that represents the low price at the desired bar index.
 
Syntax
Bars.GetLow(int index)
 
Parameters
 
 
Examples
Definition
Returns the open price at the selected bar index value.
 
Method Return Value
A double value that represents the open price at the desired bar index.
 
Syntax
Bars.GetOpen(int index)
 
Parameters
 
 
Examples
Definition
Returns the time stamp at the current bar index value.
 
 
 
Method Return Value
A DateTime structure that represents the time stamp at the desired bar index.
 
Syntax
Bars.GetTime(int index)
 
Parameters
 
 
Examples
Definition
Returns the volume at the selected bar index value.
 
Method Return Value
A long value represents the volume at the desired bar index.
 
Syntax
Bars.GetVolume(int index)
 
Parameters
 
 
Examples
Definition
Indicates if the current bar processing is the first bar updated in a trading session.
 
 
 
Property Value
This property returns true if the bar is the first processed in a session; otherwise, false.  This property is read-only.
 
 
 
Syntax
Bars.IsFirstBarOfSession
 
 
 
Examples
Definition
Indicates if the selected bar index value is the first bar of a trading session.
 
Property Value
This property returns true if the bar is the first bar of a session; otherwise, false.  This property is read-only.
 
Syntax
Bars.IsFirstBarOfSessionByIndex(int index)
 
 
 
Parameters
 
Examples
Definition
Indicates if the current bar processing is the last bar updated in a trading session.
 
 
 
Property Value
This property returns true if the bar is the last processed in a session; otherwise, false.  This property is read-only.
 
Syntax
Bars.IsLastBarOfSession
 
Examples
Definition
Indicates if the bars series is using the Break EOD data series property.  
 
Property Value
This property returns true if the bars series should reset on a new trading day; otherwise, false.  This property is read-only.
 
Syntax
Bars.IsResetOnNewTradingDay
 
 
 
Examples
Definition
Indicates if the bar series is using the Tick Replay data series property.
 
Property Value
This property returns true if the bar series is using tick replay; otherwise, false.  This property is read-only.
 
Syntax
Bars.IsTickReplay
 
 
 
Examples
Definition
Returns a value indicating the percentage complete of the real-time bar processing.
 
 
 
Property Value
A double value representing a percent e.g. a value of .5 indicates the bar was at 50%.  This property is read-only.
 
Syntax
Bars.PercentComplete
 
 
 
Examples
Definition
Returns the total number of ticks of the current bar processing.
 
 
 
Property Value
A long value that represents the total number of ticks of the current bar.
 
Syntax
Bars.TickCount
 
Examples
Definition
Returns the bars series as a formatted string, including the Instrument.FullName, BarsPeriod Value, and BarsPeriodType name.
 
 
 
Syntax
Bars.ToChartString()
 
Return Value
A string value that represents the bars series
 
Parameters
This method does not accept any parameters
 
Examples

"
Working with Price Series2.docx,"Multi-Series Scripting Overview
NinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.
 
 
It is also important that you understand the following method and properties:
 
•AddDataSeries()
•BarsArray
•BarsInProgress
•CurrentBars
 
        Working With Multi-Time Frame Objects
permalink
        Adding Additional Bars Objects to NinjaScript
permalink
        Creating Series<T> Objects
permalink
        How Bars Data is Referenced
permalink
        Using Bars Objects as Input to Indicator Methods
permalink
        True Event Driven OnBarUpdate() Method
permalink
        Accessing the Price Data in a Multi-Bars NinjaScript
permalink
        Entering, Exiting and Retrieving Position Information
permalink
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
        Error handling practices
        Performance practices
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
The main historical data input. If implemented in the NinjaScript object, it allows for more flexibility as non bars based series such as plot series could be passed in and drive the calculation outcomes - an example would be a custom moving average that should have the ability to operate on another moving average (i.e. the SMA) as input series.
 
Property Value
An ISeries<double> type object that implements the Series<double> interface. Accessing this property via an index value [int barsAgo] returns a double value representing the price of the referenced bar.
 
Syntax
Input
Input[int barsAgo]
 
 
 
Examples
 
 
 
 
Price Data Overview
The core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.
 
Definitions
 
 
Referencing Series
 
You will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:
 
 High[1] < High[0];
 
You could write a statement to calculate the average closing price of the last three bars like this:
 
 ( Close[2] + Close[1] + Close[0] ) / 3;
 
As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.
 
 
 
Referencing Indicator Data
NinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.
 
All indicator values can be accessed in the following way:
 
 indicator(parameters)[int barsAgo]
 
where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.
 
As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:
 
 Close[0] > SMA(20)[0];
 
If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:
 
 Close[0] > SMA(High, 20)[0];
 
You could write a statement to see if a 14 period CCI indicator is rising like this:
 
 CCI(14)[0] > CCI(14)[1];
 
Value of a 10 period CCI 1 bar ago = CCI(10)[1]
 
Please review the Indicator Methods section for proper syntax for accessing different indicator values.
See additional patch notes at the bottom
 
8.1.2.0 Release Date
October 25, 2023
 
 
 
8.1.2.1 Release Date
November 27, 2023
NinjaTrader comes with over 100 pre-built technical indicators, which can be added, removed and edited via the Indicators window. Indicators can be applied to charts, the SuperDOM, or Market Analyzer columns, and custom technical indicators can be created via the NinjaScript Editor.
 
        Understanding the Indicators window
permalink
        How to add an Indicator
permalink
        How to edit an Indicator's parameters 
permalink
        How to remove an Indicator
permalink
        Custom Indicator development
permalink
        Working with Indicators in Market Analyzer columns
permalink
        Working with Indicators in the SuperDOM
permalink
 
NinjaTrader Order Flow Volumetric bars provide a detailed ‘x-ray’ view into each price bar’s aggressive buying and selling activity. This technique primarily attempts to answer the question which side was the most aggressive at each price level. This is done by calculating the delta (greek for difference) between buying and selling volume (please see the Delta type property explanation below).
 
With the delta value known for each price level in the bar, it is then classified per each session for analysis and emphasizes the buying / selling strength unfolding. This is done by a gradient coloring approach shading the value cells in the bar, where the level of sensitivity for the gradient can be set via the Shading sensitivity property. The higher this value is set, the finer the gradient can be applied to various levels of strength - the NinjaTrader default is 20 levels.
 
This can be thought of as a way of not only saying who ‘won / lost’ the price level’s auction, but also by what margin or strength. This is not a signal in itself per se, but rather a mechanical means to classify the buying vs selling activity at each individual price level and thus offer the trader a more detailed look what happens inside the price bars.
 
A second comparison of buy sell volumes is the Imbalance detection. Here the price level buying and selling volumes are compared diagonally to understand which side of the market was stronger by exceeding the set Imbalance ratio. For example if the buying volume was 1000 contracts and the selling volume diagonal below was 300 then buying Imbalance was detected (assuming a default Imbalance ratio of 1.5). This can be helpful especially if multiple Imbalances 'cluster' close together to form support / resistance areas.
 
NinjaTrader Order Flow Volumetric bars can provide a large degree of details and facilitate displaying the information in a dynamically sized way, as the text is re-sized as your horizontally or vertically adjust the chart's scale range.
 
 
        Order Flow Volumetric Overview
permalink
 
        Order Flow Volumetric Imbalance Customization Example
permalink
 
        Order Flow Volumetric Bars parameters
permalink
 
        Order Flow Volumetric Values NinjaScript access
permalink
 
Advanced order handling is reserved for EXPERIENCED programmers. Through advanced order handling you can submit, change and cancel orders at your discretion through any event-driven method within a strategy. Each order method within the ""Managed Approach"" section has a method overload designed for advanced handling.
 
        Live Until Cancelled Orders
permalink
        The Order Class
permalink
        Transitioning order references from historical to live
permalink
        Working with a Multi-Instrument Strategy
permalink
8.0.15.0 Release Date
July 30, 2018
 
 
 
8.0.15.1 Release Date
August 1, 2018
 
Release Date
January 9, 2017
 
 
 
The OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (testing to see if a Close price on a specified bar was greater than the previous Close price) within this method.
 
Adding the Condition and Assigning the Plot Value
Enter the following code in the OnBarUpdate() method in the NinjaScript Editor:
 
 
 
Although the code above fits on a single line, it is doing several things. Firstly, it is important to understand the structure that we are using in this statement. We are using a Ternary Operator, which provides a way to assign one of two values to a variable based on a condition. We begin by stating that we wish to assign a value to the indicator plot at a bar index corresponding to BarsAgo. We do this by using Values, which is a collection holding values for all plots configured in the indicator:
 
 
 
Next, we add a condition to test. In this case, we are testing to see whether Close at a bar index corresponding to the value of BarsAgo was greater than Close at a value of BarsAgo + 1. If BarsAgo was set to 5, for example, this would compare Close[5] to Close[6]:
 
 
 
If the condition evaluates to true, then the first expression will be run (the expression on the left side of the colon "":""), which will assign the value of the indicator plot to the High price of the specified bar, plus five ticks. We obtain the tick size value for the configured instrument via the TickSize property:
 
 
 
if the condition evaluates to false, then the second expression will be run (the expression on the right side of the colon "":"", which will assign the value of the indicator plot to the Low price of the specified bar, less five ticks:
 
 
 
The core indicator logic is now in place, but running this code as it is can result in an ""Index out of range"" exception. Since we are looking a certain number of bars back in time, we need to make sure that there are always enough bars on the chart for us to look back. For example, if BarsAgo were set to 5, then we would be comparing the value of five bars ago to the value of six bars ago, but on Bars # 1, 2, 3, 4, or 5, at which point we do not have five or six bars to look back, the indicator will cause an error. To resolve this, we will add a condition which will prevent the core calculations from running unless we know there are enough bars on the chart. Add the following line just above the line you have been working on throughout this page:
 
 
 
This line says, ""if there is not a number of bars equal to one number greater than the value of BarsAgo, then exit OnBarUpdate().""
 
Now that everything is in place, your class code should look as below. You are now ready to compile the indicator and configure it on a chart.
 
A Data Series represents a series of price data, which can be displayed on a chart using one of several Bar Types and Chart Styles. One or more Data Series will be applied to a new chart when it is created, and additional Data Series can be added, edited, or removed via the Data Series window.
 
        Understanding the Data Series Window
permalink
        How to add a Data Series
permalink
        How to edit Data Series parameters
permalink
        How to change a Data Series
permalink
        Removing a Data Series
permalink
 
 
The SuperDOM's Price Ladder display has the ability to add any number of price action indicators which can be used to visualize and analyze indicator values in relation to the SuperDOM display, as well as attaching working orders to the indicator price level for a hand-free trade management system.
 

 
NinjaTrader comes with over 30 pre-built indicators which can be added the SuperDOM. Indicators can be added, removed and edited via the Indicators window.
        Understanding the Indicators window
permalink
        How to add an indicator
permalink
        How to edit an indicator's parameters
permalink
        Understanding how indicators are displayed
permalink
        How to remove an indicator
permalink
        Custom indicator development
permalink
NinjaTrader supports a large variety of chart Bar Types. This page explains how each Bar Type is created in a chart. Please see the Working with Price Data page for information on how to change Bar Types.
 
        Understanding Tick bars
permalink
        Understanding Volume bars
permalink
        Understanding Range bars
permalink
        Understanding Time based bars
permalink
        Understanding Heiken Ashi bars
permalink
        Understanding Kagi bars
permalink
        Understanding Renko bars
permalink
        Understanding Point and Figure bars
permalink
        Understanding Line Break bars
permalink
        Understanding Order Flow Volumetric Bars
permalink
        Understanding Order Flow Delta Bars
permalink
        Understanding Order Flow Price On Volume Bars
permalink
8.0.7.0 Release
June 6, 2017
 
 
 
8.0.7.1 Release
June 21, 2017
 
8.0.7.0 Release
June 6, 2017
 
 
 
8.0.7.1 Release
June 21, 2017
 
Multiple Data Series
Multiple Data Series objects can be be viewed within a single chart window, and there are several ways to add Data Series to a chart.
        How to Add a Data Series
permalink
        Managing Multiple Data Series
permalink
NinjaTrader supports trading and viewing market data for spot forex pairs, in addition to other supported instrument types. Due to the unique nature of forex markets, there are a number of features throughout the platform tailored specifically to these instruments, and a few considerations to keep in mind when working with forex in NinjaTrader.
        Pips Calculation Mode
permalink
        Pips in ATM Strategies
permalink
        Forex Lot Sizes
permalink
        Forex-Specific Trading Windows
permalink
        How Bars Are Built and Orders Filled
permalink
        Forex Trading Hours
permalink
        Calculating Pip Value
permalink
Release Date
January 31, 2017
 
8.0.20.1 Release Date
December 23, 2019
 
 
 
8.0.20.0 Release Date
December 5, 2019
 
 
 
8.0.6.0 Release
April 17, 2017
 
 
 
8.0.6.1 Release
April 25, 2017
 
The OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations and is called on each bar of a data series when re-calculating the indicator. For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed. Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate the ROC value.
 
Setting Plot Thresholds
The OnStateChange() method is called once before any bar data is loaded and is used to configure the indicator. The code below is automatically generated by the wizard and added to the OnStateChange() method. It configures the indicator for two plots and one line and sets the parameters.
 
 
Enter the following code in the OnStateChange() method and below the wizard generated code:
 
 
The concept of setting threshold values is to set when and when not to paint a plot on the chart. In this indicator, we have an ""AboveZero"" plot with a default color of green which we only want to see when the value of ROC is above zero and a ""BelowZero"" plot with a default color of OrangeRed which we only want to see when the value of ROC is below zero. In order to make that happen we have to set the threshold values of each plot.
 
Plots[0].Min = 0;
 
This statement says, in the collection of Plot objects, take the first one (Plots[0]) and set its minimum value to zero. This means any value below zero will not display.
 
Plots[1].Max = 0;
 
This statement says, in the collection of Plot objects, take the second one (Plots[1]) and set its maximum value to zero. This means any value above zero will not display.
 
We now have a simple plot switching mechanism that displays the correct colored line depending on if the value of ROC is above or below zero. In fact, you can take this concept a little bit farther. You can even set different plots style (bar, dot etc..) depending on threshold values.
 
A quick word about collections. Collections are objects that store a collection of objects, kind of like a container. In this case we are working with a collection of plots. In the above wizard generated code you will notice that we are adding new plots to the ""Plots"" collection. ""AboveZero"" was added first and then ""BelowZero"". This means that we can reference the ""AboveZero"" plot object through Plots[0]. The reason we don't pass in a value of 1 is because collections are zero based indexes. This means the first item has an index of 0, the second time an index of 1 and so forth.
 
Completing the Indicator
This indicator is actually quite simple in its implementation. The last thing we need to do is add the calculation code and set the value of ROC to both our plot lines.
Replace the wizard generated code with the following code into the OnBarUpdate() method in the NinjaScript Editor:
 
 
The calculation first checks to ensure there are enough bars to complete the calculation and then sets both plot lines to the ROC value.
 
The class code in your editor should look identical to the image below. You are now ready to compile the indicator and configure it on a chart.
 
Charts in NinjaTrader can contain and display multiple objects, including Data Series, Drawing Objects, and indicator plots. Objects on charts can be managed in a number ways, such as dragging and dropping them to new panels, changing the axis of their price scale (if applicable), or changing the order in which they are painted on a chart.
        How to drag and drop chart objects
permalink
        How to copy and paste chart objects
permalink
        How to change the z-order (paint order) of a chart object
permalink
The Builder point and click interface is a powerful entrypoint into NinjaScript strategy development for non programmers. Even if you target more deeper custom coding later on in the development cycle, the Builder can provide a great foundation to start with. To get started directly into full fledged programming a strategy object in the NinjaScript editor, please check into NinjaScript Wizard.
 
        Understanding the Welcome screen
permalink
        Understanding the General screen
permalink
        Understanding the Default properties screen
permalink
        Understanding the Additional data screen
permalink
        Understanding the Inputs and Variables screen
permalink
        Understanding the Conditions and Actions screen
permalink
        Understanding the Stops and Targets screen
permalink
        Understanding the Finish screen
permalink
The Builder point and click interface is a powerful entrypoint into NinjaScript strategy development for non programmers. Even if you target more deeper custom coding later on in the development cycle, the Builder can provide a great foundation to start with. To get started directly into full fledged programming a strategy object in the NinjaScript editor, please check into NinjaScript Wizard.
 
        Understanding the Welcome screen
permalink
        Understanding the General screen
permalink
        Understanding the Default properties screen
permalink
        Understanding the Additional data screen
permalink
        Understanding the Inputs and Variables screen
permalink
        Understanding the Conditions and Actions screen
permalink
        Understanding the Stops and Targets screen
permalink
        Understanding the Finish screen
permalink
Description
Order Flow Volume profile tools are available as both an Indicator and Drawing Tool and along with the suite of the 'Order Flow +' tools only available to NinjaTrader lifetime license holders. The indicator is used to plot singular static profiles containing a certain defined range of data or repeating profiles on a per bar or per session basis. The drawing tool allows you to easily define both the start and end point to create a custom profile for any bar range on a chart.
 
        Order Flow Volume Profile Concepts
permalink
        Understanding Price Profiles
permalink
        Understanding Composite Profiles
permalink
        Understanding the Order Flow Volume Profile Drawing Tool
permalink
        Order Flow Volume Profile 'Set up' Parameters
permalink
        Order Flow Volume Profile 'Visual' Parameters
permalink
        Order Flow Volume Profile 'Lines' Parameters
permalink
        Order Flow Volume Profile 'Label' Parameters
permalink
Definition
Used to render custom drawing to a chart from various chart objects, such as an Indicator, DrawingTool or Strategy.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
 
}
 
 
 
Method Parameters
 
 
 
 
Examples
 
 
 
 
Chart Trader allows for the placement of orders, and the management of orders and positions, directly from a chart. Orders and positions within Chart Trader are displayed in a visual manner, allowing you to quickly compare them with current market movements while modifying orders in real-time. Chart Trader contains two primary components: the Chart Trader panel, which is used to place, modify, or cancel/close orders and positions, and the chart panel, on which Chart Trader draws visual representations of resting orders and open positions.
        Understanding order display
permalink
        Understanding Position Display
permalink
        Working with multiple instruments
permalink
The Managed approach in NinjaScript is designed to offer the greatest ease of use for beginner to intermediate programmers. The order methods are wrapped in a convenience layer that allows you to focus on your system's trading rules, leaving the underlying mechanics of order management and the relationships between entry orders, exit orders, and positions to NinjaTrader. This approach is best suited for simple to moderate order complexity, and can be further broken down into a Basic/Common Managed approach and a more Advanced Managed approach. The following section will discuss the use of the Basic/Common approach.
 
A few key points to keep in mind:
 
•Orders are submitted as live and working when a strategy is running in real-time
•Profit target, stop loss and trail stop orders are submitted immediately when an entry order is filled, and are tied together via OCO (One Cancels Other)
•Order changes and cancellations are queued in the event that the order is in a state where it can't be cancelled or modified
•By default, orders submitted via Entry() and Exit() methods automatically cancel at the end of a bar if not re-submitted
•Entry() methods will reverse the position automatically. For example if you are in a 1 contract long position and now call EnterShort() -> you will see 2 executions, one to close the prior long position and the other to get you into the desired 1 contract short position.
 
* Via the SetProfitTarget(), SetStopLoss(), SetTrailStop() and SetParabolicStop methods
 
        Order submission for entry and exit methods - basic operation
permalink
        Order Entry Methods
permalink
        Quantity Type and TIF
permalink
        How to close a position
permalink
        Understanding core order objects
permalink
        Internal Order Handling Rules that Reduce Unwanted Positions
permalink
 
 
 
Definition
Returns a measurement of the steepness of a price series (y value) measured by the change over time (x value).  The return value can also be thought of as the ratio between the startBarsAgo and endBarsAgo parameters passed to the method.  
 
The formula which is returned from the parameters passed is:
 
(series[endBarsAgo] - series[startBarsAgo]) / (startBarsAgo - endBarsAgo)
 
 
 
Method Return Value
This method returns a double value indicating the slope of a line;  A value of 0 returns if the either the startBars or endBars parameters are less than 0 or both parameters are of equal value.
 
Syntax
Slope(ISeries<double> series, int startBarsAgo, int endBarsAgo)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 

"
