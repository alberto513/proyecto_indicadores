Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Custom Optimizers can be used to optimize your Strategy through different algorithms. These may allow you to make trade offs like being able to find adequate results quickly as opposed to trying to find the absolute best result but through a time consuming process. The methods and properties covered in this section are unique to custom Optimizer development.
 
In this section
Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
Informs the Strategy Analyzer if this Optimizer can do multi-objective optimizations.
 
Property Value
A bool value.
 
Syntax
SupportsMultiObjectiveOptimization
 
 
Examples
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Multi-Objective optimization takes standard optimization a step further by allowing you to choose multiple objectives to test for. When results are returned instead of a singlular list of best results ranked from best to least best instead you will be presented a graph. With multiple objective there is no single best result, instead its up to the trader to choose what is the best tradeoff between two objectives. To run a Multi-objective optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
 
        How to run a Multi-Objective Optimization 
permalink
        Understanding Multi-Objective  properties
permalink
        Understanding Multi-Objective results
permalink
Multi-Objective optimization takes standard optimization a step further by allowing you to choose multiple objectives to test for. When results are returned instead of a singlular list of best results ranked from best to least best instead you will be presented a graph. With multiple objective there is no single best result, instead its up to the trader to choose what is the best tradeoff between two objectives. To run a Multi-objective optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
 
        How to run a Multi-Objective Optimization 
permalink
        Understanding Multi-Objective  properties
permalink
        Understanding Multi-Objective results
permalink
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
You can fine tune the input parameters of a strategy through optimization. Optimization is the process of testing a range of values through iterative backtests to determine the optimal input values over the historical test period based on your optimization fitness. To run an optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting capabilities
 
 
        How to run an Optimization
permalink
        Understanding optimization properties
permalink
        Understanding optimization results
permalink
        Running a basket test
permalink
        Understanding factors that affect optimization performance
permalink
The Optimization Graph can only be selected in the Display selector only after an optimization has been run. The optimization graph can be displayed in a 2D or 3D graph. A 2D graph is used when only graphing a single parameter. If you graph 2 parameters then a 3D graph is displayed.
 

        Understanding the 2D optimization graph
permalink
        Understanding the 3D optimization graph
permalink
Within the Help Guide are numerous videos providing a step by step tour through the NinjaTrader Platform. Select your area of interest below to view an expanded list of all available topics within each category.
        Order Entry
permalink
        Advanced Trade Management (ATM) Strategies
permalink
        SuperDOM
permalink
        Control Center
permalink
        Market Analyzer
permalink
        Alerts
permalink
        Charts
permalink
        Market Data Windows
permalink
        Miscellaneous
permalink
        Strategy Backtesting and Optimization
permalink
Definition
Determines if the following declared property should be included in the NinjaScript object's constructor as a parameter.  This is useful if you plan on calling a NinjaScript object from another (e.g., calling a custom indicator from a strategy) or customizing the display parameter data on a grid or from a chart. This also used to make parameters optimizable in the Strategy Analyzer.
 
 
 
Syntax
[NinjaScriptProperty]
 
Parameters
This object contains no parameters
 
 
Examples
 
 
Using the OnStateChange() Method to Configure the Strategy
The OnStateChange() method is called once prior to running a strategy and can be used to set properties or call methods in preparation for running a strategy.
 
Enter the code contained within the OnStateChange() method in the image below into the OnStateChange() method when we are in the State.DataLoaded state in the NinjaScript Editor.
 
 
For more information on the strategy properties added in State.SetDefaults, please see our complete Strategy documentation.
The AddChartIndicator() method is called and the RSI() indicator method is passed in which will automatically plot this indicator on a chart when the strategy runs.
 
The method signature for the RSI() indicator is:
 
 
It is valid to have used the Add() method in the following manner:
 
 
However, instead of hard coding the period value to 14 and the smooth value to 3, we substituted the values for the user defined inputs we defined in the wizard. Calling the Add() method in the following manner:
 
 
Allows us to change the period and smooth parameters of the embedded RSI indicator in the strategy at run time. This gives us a higher level of flexibility when working with our strategy.
 
SetStopLoss() and SetProfitTarget() are called with CalculationMode.Ticks. This means that when a position is opened, the strategy will immediately submit a stop and target order with a price that is calculated based on the StopLoss and ProfitTarget parameters passed in offset from the positions average entry price.
 
 
Using the OnBarUpdate() Method for the Core Strategy Logic
The OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations. Therefore, this is the main method called for strategy calculation and we will use this method to enter the script that check for entry and exit conditions.
 
Enter the code contained within the OnBarUpdate() method in the image below into the OnBarUpdate() method in the NinjaScript Editor:
 
 
Since our strategy exit logic has already been set up in the OnStateChange() method above, we only need to focus on expressing our entry logic. The strategy entry logic is very straight forward and can be translated to English:
 
if we have not seen the number of bars specified by the user defined input "RSIPeriod" then do not go any further
 
if RSI crosses above a value of 20 within the last bar, go long
 
To accomplish this we used the following methods and properties:
 
CurrentBar - A value representing the current bar being processed (think of a chart where the left most bar would be equal to one)
CrossAbove() - Checks for a cross above condition and returns true or false
RSI() - Returns the value of the RSI indicator
EnterLong() - Enters a market order long
Definition
This method must be overridden in order to optimize a strategy. This method is called once per optimization run (not once per iteration).
 
Method Return Value
This method does not return a value.
 
Syntax
You must override the method in your Optimizer with the following syntax.
 
protected override void OnOptimize()
{
 
}
 
 
 
Examples
Anchored Walk Forward optimization is similar to the Walk Forward Optimization. However, each optimization is run from the start time then increases the end date.
 
Walk Forward optimization is the process by which you optimize strategy input parameters on a historical segment of market data, then test the strategy forward in time on data following the optimization segment using the optimized input values. The central idea is that you evaluate strategy performance data on the test data, not the data used in the optimization. This process is then repeated by moving the optimization and test segments forward in time. To run a walk forward optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
        How to run an Anchored Walk Forward Optimization 
permalink
        Understanding Anchored Walk Forward properties
permalink
        Understanding Anchored Walk Forward results
permalink
Walk Forward optimization is the process by which you optimize strategy input parameters on a historical segment of market data, then test the strategy forward in time on data following the optimization segment using the optimized input values. The central idea is that you evaluate strategy performance data on the test data, not the data used in the optimization. This process is then repeated by moving the optimization and test segments forward in time. To run a walk forward optimization you will need:
 
•Access to historical data
•Custom NinjaScript *strategy
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
 
 
        How to run a Walk Forward Optimization 
permalink
        Understanding Walk Forward properties
permalink
        Understanding Walk Forward results
permalink
Very simply put the Genetic Algorithm attempts to find the most optimal set of parameters for a strategy. It does this not by brute force testing each individual combination as the default optimization method does, but instead using the concept of evolutionary theory borrowed from biology where only the fittest parents (combined with mutation and crossover) produce children for the next generation. Through testing of multiple generations you should have narrowed down on the most optimal parameters and therefore saving you time from having to test every single parameter combination.
 
        Understanding the Genetic Algorithm
permalink
        Understanding Genetic Algorithm parameters
permalink
The AI Generate optimizer is an experimental tool designed to help traders find new strategy approaches. It can combine up to 73 NinjaTrader default indicators, 25 Candlestick patterns, and single series custom indicators.
Internally a Genetic Algorithm is used to search through the potential entry and exit combinations possible to find the best performing ones according to the Max Strength optimization criterion.
To prevent against potentially over-fitting against historical data, the AI Generate will check its own results after each generation using a Monte Carlo Simulation, it finds the 95% confidence interval.
 
We are excited to bring you this new tool to enhance your NinjaTrader strategy trading and are looking for feedback to further enhance it.
 
To run an AI Generate optimization you will need:
 
•Access to historical data
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
        How to run an AI Generate Optimization 
permalink
The AI Generate optimizer is an experimental tool designed to help traders find new strategy approaches. It can combine up to 73 NinjaTrader default indicators, 25 Candlestick patterns, and single series custom indicators.
Internally a Genetic Algorithm is used to search through the potential entry and exit combinations possible to find the best performing ones according to the Max Strength optimization criterion.
To prevent against potentially over-fitting against historical data, the AI Generate will check its own results after each generation using a Monte Carlo Simulation, it finds the 95% confidence interval.
 
We are excited to bring you this new tool to enhance your NinjaTrader strategy trading and are looking for feedback to further enhance it.
 
To run an AI Generate optimization you will need:
 
•Access to historical data
•A thorough understanding of the Strategy Analyzer's backtesting and optimization capabilities
 
        How to run an AI Generate Optimization 
permalink
The following page covers how to set up and run NinjaTrader's Monte Carlo Simulation
        Understanding Monte Carlo simulation
permalink
        How to run a Monte Carlo simulation
permalink
        Understanding the Monte Carlo Simulation report
permalink
Definition
Used to override the default NinjaScript Clone() method which is called any time an instance of a NinjaScript object is created.  By default,  the NinjaScript Clone() method will copy all the Property Info and Browsable Attributes to the new instance when the object is created (e.g., when an optimization is ran a new instance of the strategy will be created for each iteration).  However it is possible to override this behavior if desired for custom development.  There is no requirement to override the Clone behavior and this method will use the default constructor if not overridden.  
 
 
 
Method Return Value
A virtual object representing the NinjaScript type.
 
Syntax
public override object Clone()
 
 
Parameters
This method does not take any parameters
 
 
Examples
Definition
An event driven method which is called while the chart scale is being updated.  This method is used to determine the highest and lowest value that can be used for the chart scale. It is only called when the chart object is either set to IsAutoScale while there are multiple charts objects rendered or only a single object would be rendered on the chart.  
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
You must override the method in your NinjaScript object with the following syntax:
 
public override void OnCalculateMinMax()
{
 
}
 
Method Parameters
This method does not accept any parameters.
 
Examples
NinjaTrader supports trading and viewing market data for spot forex pairs, in addition to other supported instrument types. Due to the unique nature of forex markets, there are a number of features throughout the platform tailored specifically to these instruments, and a few considerations to keep in mind when working with forex in NinjaTrader.
        Pips Calculation Mode
permalink
        Pips in ATM Strategies
permalink
        Forex Lot Sizes
permalink
        Forex-Specific Trading Windows
permalink
        How Bars Are Built and Orders Filled
permalink
        Forex Trading Hours
permalink
        Calculating Pip Value
permalink
NinjaTrader allows a convenient way to save strategy parameters to easily transition to a live running strategy.
 
Saving a Template
Using the 'template' button on the bottom of the settings button shows 'Save' and 'Load'. Selecting 'Save' allows you to save the selected settings for this strategy. If you have performed an optimization the selected optimization result set will be saved. This is signified by the "(" + ")" number directly to the right of the strategy parameter control.
 
If you save as 'Default' the template will be automatically loaded as you load the strategy.
 
Loading a Template
Using the 'template' button on the bottom of the settings button shows 'Save' and 'Load'. Selecting 'Load' opens the loading dialog box where any templates specific to this strategy can be loaded. This allows you to have multiple configurations customized per instrument.
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
Definition
Used to render custom drawing to a chart from various chart objects, such as an Indicator, DrawingTool or Strategy.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
 
}
 
 
 
Method Parameters
 
 
 
 
Examples
 
 
 
 


Los siguientes consejos de rendimiento son específicos de la ventana Market Analyzer .
 
Número de instrumentos y columnas.
•Market Analyzer no tiene límite para la cantidad de instrumentos que se pueden agregar. Es importante monitorear los recursos de la computadora para comprender el límite de su PC.
•Market Analyzer no tiene límite para la cantidad de columnas, específicamente columnas indicadoras, que se pueden agregar. Dependiendo del indicador y la propiedad "Marco de tiempo" que se describe a continuación, puede tomar algunos segundos calcular el indicador. Este tiempo se multiplica por la cantidad de instrumentos en el Market Analyzer que puede resultar en unos minutos de tiempo de carga. Disminuya el número de instrumentos o columnas indicadoras para disminuir este tiempo de carga.
 
Columnas Indicadoras
•La propiedad Marco de tiempo ("Barras para cargar", "Días atrás", "Rango personalizado") determina el número mínimo de barras requerido para inicializar correctamente cada columna de indicador. Cuanto mayor sea el número, más tardará en cargar los datos y más memoria (RAM) usará NinjaTrader para mantener los datos en la memoria.
•Cada indicador tiene un parámetro Retrospectiva de barras máximas en la ventana Columnas que determina cuántos valores de indicadores históricos se almacenan para el acceso. Está configurado en TwoHundredFiftySix de forma predeterminada para un rendimiento óptimo. Establecer esto en Infinito tomará más tiempo para calcular y NinjaTrader usará más memoria (RAM) para mantener los valores adicionales en la memoria.
 
Indicador Calcular en parámetro de cierre de barra
•Todos los indicadores agregados a Market Analyzer tienen el parámetro "Calcular" establecido en "Al cerrar la barra" de forma predeterminada, que solo calcula el valor del indicador en la barra cercana para ayudar con el rendimiento de la PC.  Este parámetro se puede configurar opcionalmente en "En cambio de precio", que solo se calculará cuando haya habido un cambio en el precio, o en "En cada tic" que permita un cálculo tick por tick (que utilizará más recursos de CPU).  
 
Clasificación dinámica y frecuencia de clasificación
•Dependiendo de la cantidad de instrumentos que haya agregado a supantalla deMarket Analyzer, el uso de un valor bajo de "Clasificación automática de segundos" puede hacer que su CPU se dispare a medida que la función de clasificación automática continúa reevaluando la clasificación de la columna que está clasificando.  Por ejemplo, usar un valor de 1 segundo en 100 instrumentos podría sobrecargar su CPU.  Establecer esto en un valor más alto, como cada 10-30 segundos, reducirá la carga de trabajo de la CPU y seguirá manteniendo la ordenación dinámica en un intervalo personalizable.  Debe monitorear la carga de trabajo de su CPU para encontrar la cantidad de segundos que funcionan para su sistema.
Market Analyzer se puede personalizar según sus preferencias en la ventana Propiedades de Market Analyzer.
 
        Cómo acceder a la ventana de propiedades de Market Analyzer
permalink
 
        Propiedades disponibles y definiciones 
permalink
 
        Cómo preestablecer valores predeterminados de propiedad
permalink
 
Factores de rendimiento
Hay muchas variables que contribuyen al rendimiento general de laaplicaciónNinjaTrader.
 
•Los diferentes proveedores de conectividad (proveedores de datos del mercado y tecnologías de intermediario) que admite NinjaTrader varían en su nivel de servicio de datos en tiempo real. Por ejemplo, los proveedores que entregan datos de ticks sin filtrar (enviar todos los ticks de mercado) impondrán una mayor carga de procesamiento que un proveedor que proporciona datos de mercado limitados.
•La carga que coloque en laaplicaciónNinjaTrader (la ejecución de 200 gráficos consumirá más poder de procesamiento que la ejecución de solo 20 gráficos)
•La capacidad del hardware de su PC (¿está ejecutando una nueva máquina de última generación o una PC de 4 años con RAM limitada)?
•Una sola "configuración" incorrecta puede causar problemas de rendimiento y una única secuencia de comandos de terceros activa puede causar un problema de rendimiento general. Consulte lasecciónComprender el impacto de instalar complementos.
 
 
 
Optimizar el rendimiento
Las siguientes son algunas sugerencias que pueden ayudarlo a ajustar lainstalación deNinjaTrader para que se ejecute de manera óptima.
 
1.Cierre cualquier espacio de trabajo abierto innecesario. Aunque es posible que un área de trabajo no esté a la vista, aún utiliza los recursos del sistema cuando está abierto.
2.Salga de cualquier gráfico innecesario, SuperDOM, analizadores de mercado, etc. en su (s) espacio (s) de trabajo abierto (s). Además, si tiene varias pestañas en las ventanas que no necesita, salga de ellas.
3.Asegúrese de que todos los indicadores aplicados utilicen la configuración Calcular de Cambio de precio o Cierre de barra. No hay ningún beneficio al usar En cada marca a menos que el indicador se ocupe del conteo de volumen o marca.
4.Elimine los indicadores innecesarios de Gráficos, Analizadores de mercado y SuperDOM.
5.Reduzca los días para cargar en gráficos y en las columnas de indicadores de Market Analyzer. Esto puede ser especialmente efectivo con cualquier serie basada en ticks.
6.Use Tick Replay con moderación y solo cuando sea necesario. Por ejemplo, un indicador Pivot simple que solo usa los niveles de precios diarios actuales y anteriores no vería ninguna ventaja al usar la reproducción de ticks. En contraste, un indicador de perfil de volumen que se basa en la secuencia exacta de operaciones para calcular varios niveles se beneficiaría enormemente del uso de la repetición de ticks.
7.Eliminar objetos de dibujo innecesarios. Especialmente con el tiempo, ya que tiene más objetos de dibujo en sus gráficos, el rendimiento puede disminuir ya que hay más que representar.
8.Los espacios de trabajo que tienen un número único o menor de instrumentos no pueden aprovechar los procesadores de varios núcleos. Por ejemplo, tener 30 gráficos con el mismo instrumento no funcionará tan bien como 30 gráficos de diferentes instrumentos en un procesador multi-core. Reducir el número de ventanas con el mismo instrumento puede aumentar el rendimiento. Alternativamente, los espacios de trabajo que tienen uno o solo unos pocos instrumentos se beneficiarían de un procesador con una velocidad de reloj más alta.
9.Reduzca la cantidad de gráficos con la mira global habilitada.
10.Establezca la cruz para dibujar solo el cursor. Los sistemas con GPU menos potentes pueden beneficiarse de la reducción de la ruptura que resulta en este cambio. Esta configuración está dentro de las propiedades del gráfico.
11.Restablecer y borrar el historial de su cuenta de simulación. Una gran cantidad de operaciones simuladas puede aumentar el tamaño de su base de datos. Si no necesita esta información histórica, completar este paso liberará más recursos.
12.ReinicieNinjaTraderdiariamente.
13.Deshabilite la grabación de mercado para Reproducir y Grabar datos en vivo como históricos si no son necesarios.
14.Notas: "Guardar datos de gráficos como históricos" solo debe verificarse si utiliza un proveedor de conectividad que NO proporciona datos históricos. Muchos de los instrumentos de forex y futuros más populares están grabados en nuestros servidores y están disponibles para descargarlos para su reproducción.
15.La propiedad "Mostrar texto de volumen" en la columna Volumen de SuperDOM puede afectar el rendimiento de la PC y la velocidad de representación de los objetos en el SuperDOM. Esta propiedad está deshabilitada de manera predeterminada para minimizar el impacto en el rendimiento y, cuando está deshabilitada, puede colocar el cursor del mouse sobre cualquier fila de Volumen para ver el volumen exacto en esa fila.
16.Algunas configuraciones de computadora proporcionan dos tarjetas gráficas (integradas vs. dedicadas).  Para aprovechar al máximo el rendimiento de representación de gráficos, habilite un procesador gráfico dedicado de alto rendimiento.
17.Utilice una conexión a internet por cable. Las conexiones inalámbricas y por satélite pueden dejar caer paquetes o tener una latencia pobre. Si una conexión de baja latencia no está disponible, un VPS puede ser una gran solución.
18.Configure su conexión para conectarse en el arranque. Esto hará que su espacio de trabajo solo necesite cargarse una vez, en lugar de una vez cuando inicie NinjaTrader, y una segunda vez cuando se descarguen nuevos datos después de conectarse.
19.Reduzca la cantidad de aplicaciones que se ejecutan en su sistema.
20.La indexación de búsqueda de Windows también puede suponer una carga adicional para su procesador cuando ejecutaNinjaTrader, lo que afecta negativamente el rendimiento. También se recomienda excluir de la indexación las carpetas enumeradas a continuación, lo que puede hacerse a través del Panel de control de Windows.
 C:\Users\User\Documents\NinjaTrader 8
 C:\Program Files (x86)\NinjaTrader 8
 
Reproducción
1.Eliminar las suscripciones de instrumentos no utilizados en la reproducción. En su configuración de reproducción, tenga en cuenta los instrumentos que ha agregado (por ejemplo, en un Market Analyzer o mediante Cartas) que tendría datos para reproducir realmente disponibles, ya que cada suscripción de instrumento aquí consumiría ciclos de CPU y, por lo tanto, contribuiría al rendimiento experimentado. Por ejemplo, tener el índice SP500 agregado en su Market Analyzer, pero luego solo se espera que la reproducción de datos de MSFT tenga un rendimiento más bajo en comparación con tener solo este instrumento MSFT incluido en Market Analyzer también.
 
Diagnósticos adicionales
Si aún tiene problemas de rendimiento, siga estos pasos de diagnóstico para aislar el problema.
 
1.Inicia NinjaTrader en modo seguro.
 El Modo seguro evitará que NinjaTrader:
         Cargando espacios de trabajo.
         Conexión en la puesta en marcha.
         Cargando ensamblajes personalizados.
         Obteniendo actualizaciones de instrumentos desde el servidor.
 
 Para habilitar el modo seguro, siga los siguientes pasos:
         Salir NinjaTrader.
         Mantenga presionada la tecla CONTROL y haga doble clic en elicono deNinjaTrader.
         Mantenga presionada la tecla CONTROL hasta que vea el Centro de control.
         Puede verificar que está en modo seguro yendo a Ayuda -&gt; Acerca de.
2.Abra algunas ventanas y pruebe el rendimiento sin cargar ningún indicador personalizado.
3.Si todo se ve bien, intenta abrir tu espacio de trabajo. Es posible que deba cerrar su área de trabajo, sin guardarla y volver a abrirla. Si esto funciona bien, los montajes personalizados instalados pueden ser la causa.
4.Si el rendimiento es deficiente con el área de trabajo en modo seguro, podría ser que el área de trabajo tenga demasiados recursos para su sistema, que puede ser de los scripts que se están utilizando.
5.Para determinar si hay secuencias de comandos específicas que tienen como resultado un rendimiento deficiente, deberá volver a crear su área de trabajo y agregar las secuencias de comandos de una en una para ver cuál de ellas puede resultar en un rendimiento deficiente.
6.Para obtener más ayuda o asistencia con cualquiera de estos pasos, escriba aplatformupport@ninjatrader.com
Complementos de terceros
El entorno de desarrollo integral y flexible de NinjaTrader permite a los Desarrolladores de terceros desarrollar aplicaciones ricas e integradas. Estos complementos permiten una personalización infinita
        Instalación de complementos
permalink
 
        Comprender el impacto de instalar complementos
permalink
 
        Actualización y eliminación de complementos
permalink
 
        Deshabilitar temporalmente los complementos
permalink
 
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
Definition
This method calculates the value for the Optimization Fitness.
 
Syntax
protected override void OnCalculatePerformanceValue(StrategyBase strategy)
{
 
}
 
 
Examples
Definition
The value an optimization would be calculating against when using this Optimization Fitness.
 
Property Value
A double value.
 
Syntax
Value
 
 
Examples
Definition
Determines if the strategy will save orders, trades, and execution history. When this property is set to false you will see significant memory savings at the expense of having access to the detailed trading information.
 
 
 
Property Value
This property returns true if the strategy will include trade history; otherwise, false. Default is set to true.  Always false during a strategy analyzer optimization on a 32-bit process.
 
 
 
Syntax
IncludeTradeHistoryInBacktest
 
Examples
Puede ajustar los parámetros de entrada de una estrategia a través de la optimización. La optimización es el proceso de probar un rango de valores a través de pruebas repetitivas iterativas para determinar los valores de entrada óptimos durante el período de prueba histórico en función de su capacidad de optimización. Para ejecutar una optimización, necesitará:
 
•Acceso a datos históricos.
•Costumbre NinjaScript * estrategia
•Una comprensión profunda de las capacidades de backtesting de Strategy Analyzer
 
 
        Cómo ejecutar una optimización
permalink
 
        Comprender las propiedades de optimización
permalink
 
        Comprender los resultados de optimización
permalink
 
        Ejecutando una prueba de canasta
permalink
 
        Comprender los factores que afectan el rendimiento de la optimización.
permalink
 
 
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Definition
Holds an array of ISeries<double> objects holding hold the indicator's underlying calculated values. ISeries<double> values are added to this array when calling the AddPlot() method. In case of a MultiSeries indicator synched to the primary series.
 
Property Value
A collection of ISeries<double> objects.
 
Syntax
Values[int index]
 
 
Examples
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Definition
This method calculates the value for the Optimization Fitness.
 
Syntax
protected override void OnCalculatePerformanceValue(StrategyBase strategy)
{
 
}
 
 
Examples
Definition
The value an optimization would be calculating against when using this Optimization Fitness.
 
Property Value
A double value.
 
Syntax
Value
 
 
Examples



NinjaTrader makes it easy to distribute complete packages for your clients. Not only can you distribute your indicators and strategies, but you can also seamlessly deploy your own custom assemblies, native DLLs, chart templates, and Market Analyzer templates to your clients.
 
 
Creating the distribution package
To create a distribution package, please follow the steps shown here for creating a Export file containing your NinjaScript indicators and/or strategies.
 
It is strongly recommended that you export your scripts as an assembly and use SecureTeam's Agile.NET. Only this process will provide you with the highest level of security possible in order to protect your intellectual property. For more information on using SecureTeam's Agile.NET please see the Protection/DLL Security section.
 
After you finish using the Export utility you will find the distribution package as a .zip file located in My Documents\NinjaTrader 8\bin\Custom\ExportNinjaScript. If you only wanted to distribute your NinjaScript files then providing your customers with this .zip and having them go through the Import process would install it on their machines. If you wish to add more custom files to your distribution package, please see the sections below.
 
Critical: It is important to let your customers know that NinjaTrader 8 indicators and strategies are NOT necessarily compatible with NinjaTrader Version 7.
        Adding custom assemblies or native DLLs
permalink
        Adding templates
permalink
        Adding workspaces
permalink
        Adding custom resource files
permalink
 
In order to achieve custom rendering for various chart related objects, a Brush is used to "paint" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
permalink
        Understanding custom brushes
permalink
        Using brushes defined on the user interface
permalink
        Using advanced brush types (SharpDX)
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
Release Date
July 11, 2016
 
Code Breaking Changes
Compile Errors
•The NinjaScript Strategy "AccountSize" concept was removed due to limited functionality.  This change would also impact strategies which were coded to use SetOrderQuantity.ByAccountSize.  Please use your own variables to set quantities by account size. Tip:  NinjaTrader 8 can read real-world account values for live trading purposes through the Account class, e.g., Account.Get(AccountItem.CashValue, Currency.UsDollar) provides a method for returning a double value representing the current cash value of the account.
 
Implementation changes
•The concept used to force plot series objects through ForcePlotsMaximumBarsLookBackInfinite was disabled and tagged as obsolete.  You should set any indicator/strategy plots to MaximumBarsLookBack.Infinite during its construction.
•It is recommended that any strategies generated with the 'Strategy Builder' tool via Control Center > New > Strategy Builder be removed and recreated after installing B12. If you had invested significant effort in a Strategy Builder generated strategy in B11 which you would like to continue to use, please contact us platformsupport@ninjatrader.com
 
Notes
NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•"UI" instances representing its default properties on various user interfaces
•The "configured" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select "Indicator"
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses "Apply" or "OK"
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of "Available" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of "Available" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the "Properties" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd "configured" instance you are concerned with developing, but you should also be aware of the "UI" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or "Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
Definition
Adds a Bars object for developing a multi-series (multi-time frame or multi-instrument) NinjaScript.
 
Related Methods and Properties
 
 
Syntax
The following syntax will add another Bars object for the primary instrument of the script.
AddDataSeries(BarsPeriod barsPeriod)
AddDataSeries(BarsPeriodType periodType, int period)
 
The following syntax allows you to add another Bars object for a different instrument to the script:
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period)
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period, MarketDataType marketDataType)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, int barsToLoad, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName) //only for R15 and higher
 
 
 
Parameters
 
 
 
 
Examples
 
 


Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
The optimization parameters selected for the optimization run. (e.g. user parameters or Data Series)
 
Property Value
A bool value.
 
Syntax
Strategies[0].OptimizationParameters
 
 
Examples
Definition
Reserved for Walk-Forward Optimization, this property determines the number of days used for the "in sample" backtest period for a given strategy.  See also TestPeriod.
 
 
Property Value
An int value representing the number of "in sample" days used for walk-forward optimization; Default value is set to 10.
 
Syntax
OptimizationPeriod
 
 
Examples
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
Represents the real-world or simulation Account configured for the strategy.
 
Property Value
An Account object configured for the strategy
 
Syntax
Account
 
Examples
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 
Definition
Adds an instance of custom Performance Metric to a strategy used in strategy calculations.
 
Method Return Value
This method does not return a value.
 
Syntax
AddPerformanceMetric(PerformanceMetricBase performanceMetric)
 
 
 
Parameters
 
 
 
Examples
 
Definition
Adds an instance of custom Performance Metric to a strategy used in strategy calculations.
 
Method Return Value
This method does not return a value.
 
Syntax
AddPerformanceMetric(PerformanceMetricBase performanceMetric)
 
 
 
Parameters
 
 
 
Examples
 
Definition
Changes the price of the specified entry order.
 
Method Return Value
Returns true if the specified order was found; otherwise false.
 
Syntax
AtmStrategyChangeEntryOrder(double limitPrice, double stopPrice, string orderId)
 
 
Parameters
 
 
Examples
Definition
Changes the price of the specified order of the specified ATM strategy.
 
Method Return Value
Returns true if the specified order was found; otherwise false.
 
Syntax
AtmStrategyChangeStopTarget(double limitPrice, double stopPrice, string orderName, string atmStrategyId)
 
Parameters
 
 
 
Examples
Definition
Cancels any working orders and closes any open position of a strategy using the default ATM strategy close behavior.
 
Method Return Value
Returns true if the specified ATM strategy was found; otherwise false.
 
 
 
Syntax
AtmStrategyClose(string atmStrategyId)
 
Parameters
 
 
Examples
Definition
Submits an entry order that will execute a specified ATM Strategy.  
 
 
 
Method Return Value
This method does not return a value
 
Syntax
AtmStrategyCreate(OrderAction action, OrderType orderType, double limitPrice, double stopPrice, TimeInForce timeInForce, string orderId, string strategyTemplateName, string atmStrategyId, Action<Cbi.ErrorCode, string> callback)
 
 
Parameters
 
 
 
 
Examples
The methods and properties covered in this section are unique to custom strategy development.
 
In this section
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
The following are what we suggest for best practices for distribution.
 
Do not deploy NinjaScript Source Files
If you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.
 
Naming Conventions
Please use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is "Hyper" you could name your indicators "HyperTrend" or "HyperOscillator" for example.
 
In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader will automatically block incompatible scripts from importing so there will be no confusion by the user as to whether they are installing Version 7 or 8 scripts to their NinjaTrader installation. It is advisable to include the NinjaTrader version number in the export archive which will reduce potential support burden. For example, you could name your indicators “MyIndicator_7.zip” and “MyIndicator_8.zip”.
 
Clean up your resources
Always free up resources such as external windows DLL's or license management related resources. Resources should be freed within the OnStateChange() method in State.Terminate. NinjaTrader calls this method at the point at which a script is no longer used.
 
User Authentication Trigger
If you use a proprietary user authentication process, ensure that it is triggered within the OnStateChange() method in State.SetDefaults. This ensures that users are not forced to endure unnecessary delays on NinjaTrader start up or dialog windows that display available indicators and strategies as the windows are loaded. NinjaTrader, LLC provides a free licensing service for qualified 3rd party developers. For more information on this free service, contact your NinjaTrader Business Development representative.
 
User Authentication Check State
A license check should only be performed once and maintain its check state.
 
User Authentication Time Out
A license check should have a time out in case of internet issues, to enhance performance in this case.
 
Custom Installer
If you provide a custom installer, the installer should not overwrite any NinjaTrader deployed files, and you should provide an uninstall option which removes all installed files.
 
It is also preferred that you provide one installer that provides the user the option to install either a version 7 or version 8 compatible version of your product(s). Ensure that you only copy the correct files to the correct NinjaTrader installation folders since if you don’t it is possible that it could cause compile issues for the customer and it will be extremely difficult for all involved to isolate the cause.
 
These are the following folder names:
•Documents\NinjaTrader 7\bin\Custom
•Documents\NinjaTrader 8\bin\Custom
 
Test on Legacy Operating Systems
Some NinjaTrader customers run on older Operating Systems (such as Windows 7) and you should make sure that your indicators, custom installers and external DLLs (if any are used) properly run on these legacy operating systems.
 
Expose Indicator States
If your proprietary indicator acts as a trend state (green bars are bullish, red bearish) its good practice to expose the indicators's state so that consumers of your indicators can use them within their own custom indicator or strategy.
Understanding the SharpDX .NET Library
NinjaTrader Chart objects (such as Indicators, Strategies, DrawingTools, ChartStyles) implement an OnRender() method aimed to render custom lines, shapes, and text to the chart.  To achieve the level of performance required to keep up with market data events, NinjaTrader uses a 3rd-party open-source .NET library named SharpDX.  This 3rd party library provides a C# wrapper for the powerful Microsoft DirectX API used for graphics processing and known for its hardware-accelerated performance, including 2D vector and text layout graphics used for NinjaTrader Chart Rendering.  The SharpDX/DirectX library is extensive, although NinjaTrader only uses a handful of namespaces and classes, which are documented as a guide in this reference.  In addition to this educational resource, we have also compiled a more focused collection of SharpDX SDK Reference resources to help you learn the SharpDX concepts used in NinjaTrader Chart Rendering.
 
 
There are three main SharpDX namespaces you need to be familiar with:
 
 
The rest of this page will help you navigate the fundamental concepts needed to achieve custom rendering to your charts.
        SharpDX Vectors and Charting Coordinates
permalink
        SharpDX Brush Resources
permalink
        SharpDX RenderTarget
permalink
        SharpDX Lines and Shapes
permalink
        SharpDX Text Rendering
permalink
        SharpDX Stroke Style
permalink
         Best Practices for SharpDX Resources
permalink
Welcome to the NinjaTrader 8 Beta Release!
We are very excited to openly release NinjaTrader 8 Beta to our general user base. The purpose of this program is to have you start testing the platform to in order to solicit feedback in the form of bug reports and constructive criticism. The beta process is a critical step in the software development cycle during which time we jointly work towards improving quality and performance with a goal of reaching a stable product ready for general release.
 
This release marks the introduction of our next generation trading platform. NinjaTrader 8 adds over 500+ new features and functionality on top of a re-designed architecture built to take advantage of new development practices and modern technologies. This is our most ambitious project to date and we are excited to get it in the hands of our customers.
 
 
 
Bug reports and providing feedback
Support will be driven via our NinjaTrader Support Forum NinjaTrader 8 section. When running into unexpected behavior please create a bug report in the NinjaTrader support forum's bug report section. Bug reports will be reviewed by our support and development staff inside of a 48 hour period. If you are unable to post to the bug section of the forum please contact platformsupport@ninjatrader.com.  
        Installation Guide
permalink
        Expectations during beta
permalink
        NinjaScript
permalink
The Condition Builder is a very powerful feature that allows you to define complex conditions for your automated trading systems without having to know how to program.
        Understanding the Condition Builder
permalink
        How to make price data comparisons
permalink
        How to offset an item value
permalink
        How to make indicator to value comparisons
permalink
        How to compare plot values of multi-plot indicators
permalink
        How to use user inputs & variables
permalink
        How to create a cross over condition
permalink
        How to use indicator inputs in other indicators
permalink
        How to check for volume expansion
permalink
        How to create market position comparisons
permalink
        How to create time comparisons
permalink
        How to negate a condition
permalink
 
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
permalink
        Error handling practices
permalink
        Performance practices
permalink
        Miscellaneous practices
permalink
Description
The Polarized Fractal Efficiency indicator uses fractal geometry to determine how efficiently the price is moving. When the PFE is zigzagging around zero, then the price is congested and not trending. When the PFE is smooth and above/below zero, then the price is in an up/down trend. The higher/lower the PFE value, the stronger the trend is.
 
... Courtesy of FMLabs
 
 
Syntax
PFE(int period, int smooth)
PFE(ISeries<double> input, int period, int smooth)
 
Returns default value
PFE(int period, int smooth)[int barsAgo]
PFE(ISeries<double> input, int period, int smooth)[int barsAgo]
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
Description
Developed by Perry Kaufman, this indicator is an EMA using an Efficiency Ratio to modify the smoothing constant, which ranges from a minimum of Fast Length to a maximum of Slow Length.
 
 
Syntax
KAMA(int fast, int period, int slow)
KAMA(ISeries<double> input, int fast, int period, int slow)
 
Returns default value
KAMA(int fast, int period, int slow)[int barsAgo]
KAMA(ISeries<double> input, int fast, int period, int slow)[int barsAgo]
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
NinjaTrader uses a State change system to represent various life cycles of your NinjaScript object.  For more basic indicators and strategies, simply understanding each State described on the OnStateChange() page is sufficient.  However, for more advanced development projects, it is critical to understand how NinjaTrader calls these states for various instances throughout the lifetime of the entire application.
 
When NinjaTrader instantiates a NinjaScript object
There are two categories of instances instantiated by NinjaTrader:
 
•"UI" instances representing its default properties on various user interfaces
•The "configured" instance executing your custom instructions
 
In both categories, OnStateChange() is called at least twice:  once to State.SetDefaults acquiring various default property values, and then again to State.Terminated handling internal references cleanup.
 
 
To elaborate on that process, imagine the sequence of user events required to start an indicator on a chart:
 
1.User right clicks on a Chart and select "Indicator"
2.User adds an Indicator from the Available list
3.User configures desired Properties and presses "Apply" or "OK"
 
During this sequence, there are actually 3 instances of the same indicator created by NinjaTrader:
 
1.The instance displaying the Name property to the list of "Available" indicators (Note: this process involves creating an instance of all indicators in order to build the complete list)
2.The instance displaying the individual Name and its default Properties
3.The instance configured and executing on the chart
 

 
 
To visualize how each instance goes through its States, please consider the logic and flow chart below:
 
1.In order to display the indicator name in the list of "Available" indicators, the NinjaTrader core must find the Name of each installed indicator defined in their SetDefaults.  This occurs simultaneously for every indicator installed on the system in order to build the full list of available indicators.
2.The selected indicator is then cloned and SetDefaults is called again in order to display the default properties to the "Properties" grid.  This only occurs for the individual indicator.
3.After the user has set their desired property settings and press OK or Apply, the indicator is once again cloned and runs through its full state management.  This only occurs for the indicator configured to execute on the chart.
 
 

 
It is the 3rd "configured" instance you are concerned with developing, but you should also be aware of the "UI" instances which are triggered at various stages of NinjaTrader.
 
 
What does this mean for me?
Since OnStateChange() can be called at various times throughout NinjaTrader, you should be diligent in handling each state and managing resources only when it is appropriate that your NinjaScript object was actually configured:
 
•State.SetDefaults should be kept as lean as possible to prevent logic from processing superfluously and causing problems unrelated to the configured instance.  Only properties which need to be displayed on the UI should be set in this state.
•Resources should only be set up once an object has reached State.Configure or State.DataLoaded (see best practices for more information)
•State.Terminated logic should be specific in when it resets a value or destroys a resource.  Since the running instance can be cloned back to a UI instance, checking that a mutable property exists before accessing sometimes is not enough.  You may need to consider adding a flag to help decide when a resource needs to be reset or destroyed.  
 
Example
Let’s say your object was an indicator looking to add a custom toolbar element to the chart, and when the indicator is removed from the chart, you would want to make sure your toolbar elements are also properly removed.  In the OnStateChange() handler you change could add the custom toolbar once the State has reached State.Historical, and remove the toolbar once the State has reached State.Terminated.
 
To ensure that the remove logic only runs in instances that were actually configured, you can see we in the example below we also track that the toolbar needs a reset in State.Terminated state via a custom bool variable.  In other words, the proper reset request comes from our configured instance and would be ignored if the State.Terminated is called from outside our object (i.e., a UI instance). This will prepare our object to properly handle both situations in which State.Terminated could be called in the NinjaTrader state management system.
 
 
Cloning NinjaScript
Clone is the operation of iterating over all public browsable properties on a NinjaScript object and duplicating the values over to a freshly generated instance. For the majority of NinjaScript with standard properties the clone process is transparent to you and you do not need to be concerned the the clone process. For those of you that want more control or will be utilizing complex properties then knowledge about clone is essential. Cloning is performed in 2 primary use cases:
 
1.Configuring an instance in an object dialog and then cloning the configured data to an actual NinjaScript instance applied for example to a Chart. (Configuration then Run)
2.When triggering 'Reload NinjaScript' or "Reload All Historical Data'
 
NinjaScript objects have a base clone method implemented which will iterating over all browsable properties and copy by value to the next instance. The rules follow the 'clone' rules described in the clone documentation located here and described above. The default behavior will work in almost all cases except for when you have some complex custom property which needs specific clone behavior. In which case we allow the ability to override Clone() and specify your own behavior.
 
 
Saving NinjaScript Properties to the Workspace via XML Serialization
XML Serialization comes into play when you have a set of properties and want those properties to persist the user saved workspace (or any templates that are user created).
 
By default basic types such as int, string, bool will all serialize without issue, if you have a complex property you want its setting maintained on restore then you need to create a string serialized representation of that class. The technique is shown in this example post here where we show how to serialize a color brush.
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
The following are what we suggest for best practices for distribution.
 
Do not deploy NinjaScript Source Files
If you are a commercial vendor, you should never distribute the NinjaScript .cs source code files even if your IP is contained within an assembly or proprietary DLL. Source code files are editable by users and can result in unnecessary support issues.
 
Naming Conventions
Please use consistent naming convention with your indicators and strategies. We suggest adding a prefix to an indicator name. If your company name is "Hyper" you could name your indicators "HyperTrend" or "HyperOscillator" for example.
 
In the event that you provide NinjaScript export archives (zip files) as your means of distribution, NinjaTrader will automatically block incompatible scripts from importing so there will be no confusion by the user as to whether they are installing Version 7 or 8 scripts to their NinjaTrader installation. It is advisable to include the NinjaTrader version number in the export archive which will reduce potential support burden. For example, you could name your indicators “MyIndicator_7.zip” and “MyIndicator_8.zip”.
 
Clean up your resources
Always free up resources such as external windows DLL's or license management related resources. Resources should be freed within the OnStateChange() method in State.Terminate. NinjaTrader calls this method at the point at which a script is no longer used.
 
User Authentication Trigger
If you use a proprietary user authentication process, ensure that it is triggered within the OnStateChange() method in State.SetDefaults. This ensures that users are not forced to endure unnecessary delays on NinjaTrader start up or dialog windows that display available indicators and strategies as the windows are loaded. NinjaTrader, LLC provides a free licensing service for qualified 3rd party developers. For more information on this free service, contact your NinjaTrader Business Development representative.
 
User Authentication Check State
A license check should only be performed once and maintain its check state.
 
User Authentication Time Out
A license check should have a time out in case of internet issues, to enhance performance in this case.
 
Custom Installer
If you provide a custom installer, the installer should not overwrite any NinjaTrader deployed files, and you should provide an uninstall option which removes all installed files.
 
It is also preferred that you provide one installer that provides the user the option to install either a version 7 or version 8 compatible version of your product(s). Ensure that you only copy the correct files to the correct NinjaTrader installation folders since if you don’t it is possible that it could cause compile issues for the customer and it will be extremely difficult for all involved to isolate the cause.
 
These are the following folder names:
•Documents\NinjaTrader 7\bin\Custom
•Documents\NinjaTrader 8\bin\Custom
 
Test on Legacy Operating Systems
Some NinjaTrader customers run on older Operating Systems (such as Windows 7) and you should make sure that your indicators, custom installers and external DLLs (if any are used) properly run on these legacy operating systems.
 
Expose Indicator States
If your proprietary indicator acts as a trend state (green bars are bullish, red bearish) its good practice to expose the indicators's state so that consumers of your indicators can use them within their own custom indicator or strategy.
NinjaTrader provides a free vendor license management service for user authentication to qualified 3rd party developers.
 
The service includes the following features:
 
•One method call within your NinjaScript indicator or strategy's constructor will enable the authentication process
•A NinjaScript AddOn dedicated to license management (Manage license, provide free trials)
•Licenses are exclusively tied to a combination of user-defined prefix + PC machine ID value, ensuring that licenses cannot be shared
•Manage all of your individual products, or group products together for licensing
•Licenses expire based on time/date
•Create free trial periods
 
For more information please contact sales@ninjatrader.com or your NinjaTrader Business Development representative. Once approved, you will receive a unique Vendor ID used to manage your user licenses, a Vendor Licensing Help Guide containing information, samples, and resources to guide you through the process of managing licensing.


When creating Indicators or Strategies you may find that you need to store values in a way that is similar to the way price data is stored in NinjaTrader.
 
Series<T> objects are useful for storing various types of values.
 
Since they are linked to your historical bars object, you can store and link a value to each bar. This allows you the flexibility of accessing the values at any point in the future for further calculations or plotting.
 
 
Key concepts in this example
•Creating objects that store data
•Storing and retrieving values from these objects
 
Important related documentation
•Series<T>
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
SampleCustomSeries_NT8.zip
// 
// Copyright (C) 2016, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA);
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				if (CurrentBar == 0)
					Value[0] = Input[0];
				else
				{
					double last = Value[1] * Math.Min(CurrentBar, Period);

					if (CurrentBar >= Period)
						Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);
					else
						Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));
				}
			}
			else
			{
				if (IsFirstTickOfBar)
					priorSum = sum;

				sum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
				Value[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
     public class SampleCustomSeries : Indicator
     {		
		// Defines the Series object
		private Series<double> myDoubleSeries;

        protected override void OnStateChange()
        {
			if (State == State.SetDefaults)
			{
				// Adds a plot to our NinjaScript Indicator
	            AddPlot(new Stroke(Brushes.Orange, 1), PlotStyle.Bar, "Average Range");
				
				Period					= 5;
				Name					= "Sample custom series";
	            Calculate				= Calculate.OnBarClose;
	            IsOverlay				= false;
			}
			
			else if (State == State.DataLoaded)
			{
				// Create a new Series object and assign it to the variable myDoubleSeries declared in the ‘Variables’ region above
				myDoubleSeries = new Series<double>(this);
			}
        }

        protected override void OnBarUpdate()
        {
			/* To set values to our Series object we use the [] method. Here we are setting the DataSeries
			object for the current bar to take on the absolute value of the difference between the current bar's
			open and close. */
			
			myDoubleSeries[0] = Math.Abs(Close[0] - Open[0]);
			
			/* Take note that the method for setting the value to be plotted is the same as for setting a value
			to a DataSeries object. The difference here is that the custom DataSeries object is not plotted while
			this "Average Range" is plotted.
			
			In this case we are plotting the Simple Moving Average of the intermediate calculation step stored in our
			Series object. */
			
            Value[0] = SMA(myDoubleSeries, Period)[0];
        }

        #region Properties
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		#endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleCustomSeries[] cacheSampleCustomSeries;
		public SampleCustomSeries SampleCustomSeries(int period)
		{
			return SampleCustomSeries(Input, period);
		}

		public SampleCustomSeries SampleCustomSeries(ISeries<double> input, int period)
		{
			if (cacheSampleCustomSeries != null)
				for (int idx = 0; idx < cacheSampleCustomSeries.Length; idx++)
					if (cacheSampleCustomSeries[idx] != null && cacheSampleCustomSeries[idx].Period == period && cacheSampleCustomSeries[idx].EqualsInput(input))
						return cacheSampleCustomSeries[idx];
			return CacheIndicator<SampleCustomSeries>(new SampleCustomSeries(){ Period = period }, input, ref cacheSampleCustomSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

#endregion
Definition
Holds an array of ISeries<double> objects holding hold the indicator's underlying calculated values. ISeries<double> values are added to this array when calling the AddPlot() method. In case of a MultiSeries indicator synched to the primary series.
 
Property Value
A collection of ISeries<double> objects.
 
Syntax
Values[int index]
 
 
Examples
Definition
The Values array holds an 5 values corresponding to each Cbi.PerformanceUnit. NinjaTrader will then access the Values property to display the calculated performance metric in the UI. You can also access these performance metrics for a NinjaScript strategy.
 
Syntax
public double[] Values
{ get; private set; }
 
Calculating Values OnAddTrade Example
 
Calculating Values On Demand Example
There may be cases where you want to have your indicator calculate non-plotted values that you will want to access when using this indicator inside of another indicator or strategy.
 
Key concepts in this example
•Creating exposed BoolSeries objects
•Storing and retrieving values from BoolSeries objects
 
Important related documentation
•Series<T>
We suggest using an available class that implements the Series interface.
•Price Series
•Time Series
•Volume Series
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
SampleBoolSeries_NT8.zip
// 
// Copyright (C) 2016, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The MACD (Moving Average Convergence/Divergence) is a trend following momentum indicator 
	/// that shows the relationship between two moving averages of prices.
	/// </summary>
	public class MACD : Indicator
	{
		private	Series<double>		fastEma;
		private	Series<double>		slowEma;
		private double				constant1;
		private double				constant2;
		private double				constant3;
		private double				constant4;
		private double				constant5;
		private double				constant6;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionMACD;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMACD;
				Fast						= 12;
				IsSuspendedWhileInactive	= true;
				Slow						= 26;
				Smooth						= 9;

				AddPlot(Brushes.Green,									NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameMACD);
				AddPlot(Brushes.DarkViolet,								NinjaTrader.Custom.Resource.NinjaScriptIndicatorAvg);
				AddPlot(new Stroke(Brushes.Navy, 2),	PlotStyle.Bar,	NinjaTrader.Custom.Resource.NinjaScriptIndicatorDiff);
				AddLine(Brushes.DarkGray,				0,				NinjaTrader.Custom.Resource.NinjaScriptIndicatorZeroLine);
			}
			else if (State == State.Configure)
			{
				constant1	= 2.0 / (1 + Fast);
				constant2	= (1 - (2.0 / (1 + Fast)));
				constant3	= 2.0 / (1 + Slow);
				constant4	= (1 - (2.0 / (1 + Slow)));
				constant5	= 2.0 / (1 + Smooth);
				constant6	= (1 - (2.0 / (1 + Smooth)));
				fastEma		= new Series<double>(this);
				slowEma		= new Series<double>(this);
			}
		}

		protected override void OnBarUpdate()
		{
			double input0	= Input[0];

			if (CurrentBar == 0)
			{	
				fastEma[0]		= input0;
				slowEma[0]		= input0;
				Value[0]		= 0;
				Avg[0]			= 0;
				Diff[0]			= 0;
			}
			else
			{
				double fastEma0	= constant1 * input0 + constant2 * fastEma[1];
				double slowEma0	= constant3 * input0 + constant4 * slowEma[1];
				double macd		= fastEma0 - slowEma0;
				double macdAvg	= constant5 * macd + constant6 * Avg[1];

				fastEma[0]		= fastEma0;
				slowEma[0]		= slowEma0;
				Value[0]		= macd;
				Avg[0]			= macdAvg;
				Diff[0]			= macd - macdAvg;
			}
		}

		#region Properties
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Avg
		{
			get { return Values[1]; }
		}

		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Default
		{
			get { return Values[0]; }
		}
		
		[Browsable(false)]
		[XmlIgnore]
		public Series<double> Diff
		{
			get { return Values[2]; }
		}

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Fast", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Fast
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Slow", GroupName = "NinjaScriptParameters", Order = 1)]
		public int Slow
		{ get; set; }

		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Smooth", GroupName = "NinjaScriptParameters", Order = 2)]
		public int Smooth
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MACD[] cacheMACD;
		public MACD MACD(int fast, int slow, int smooth)
		{
			return MACD(Input, fast, slow, smooth);
		}

		public MACD MACD(ISeries<double> input, int fast, int slow, int smooth)
		{
			if (cacheMACD != null)
				for (int idx = 0; idx < cacheMACD.Length; idx++)
					if (cacheMACD[idx] != null && cacheMACD[idx].Fast == fast && cacheMACD[idx].Slow == slow && cacheMACD[idx].Smooth == smooth && cacheMACD[idx].EqualsInput(input))
						return cacheMACD[idx];
			return CacheIndicator<MACD>(new MACD(){ Fast = fast, Slow = slow, Smooth = smooth }, input, ref cacheMACD);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MACD MACD(int fast, int slow, int smooth)
		{
			return indicator.MACD(Input, fast, slow, smooth);
		}

		public Indicators.MACD MACD(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.MACD(input, fast, slow, smooth);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MACD MACD(int fast, int slow, int smooth)
		{
			return indicator.MACD(Input, fast, slow, smooth);
		}

		public Indicators.MACD MACD(ISeries<double> input , int fast, int slow, int smooth)
		{
			return indicator.MACD(input, fast, slow, smooth);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
    public class SampleBoolSeries : Indicator
    {
		/* We declare two Series<bool> objects here. We will expose these objects with the use of 
		public properties later. When we want to expose an object we should always use the associated
		ISeries class type with it. This will ensure that the value accessed is kept up-to-date. */
		private Series<bool> bearIndication;
		private Series<bool> bullIndication;
		
		/* If you happen to have an object that does not have an ISeries class that can be used, you
		will need to manually ensure its values are kept up-to-date. This process will be done in the
		"Properties" region of the code. */
		private double exposedVariable;

        protected override void OnStateChange()
        {
			if(State == State.SetDefaults)
			{
				Name					= "Sample bool series";
	            Calculate				= Calculate.OnBarClose;
	            IsOverlay				= true;
			}
			
			else if(State == State.Configure)
			{
				/* "this" syncs the Series<bool> to the historical bar object of the indicator. It will generate
				one bool value for every price bar. */
				bearIndication			= new Series<bool>(this);
				bullIndication			= new Series<bool>(this);
			}
        }

        protected override void OnBarUpdate()
        {
			// MACD Crossover: Fast Line cross above Slow Line
			if (CrossAbove(MACD(12, 26, 9), MACD(12, 26, 9).Avg, 1))
			{
				// Paint the current price bar lime to draw our attention to it
				BarBrushes[0]		= Brushes.Lime;
				
				/* This crossover condition is considered bullish so we set the "bullIndication" Series<bool> object to true.
				We also set the "bearIndication" object to false so it does not take on a null value. */
				bullIndication[0]	= (true);
				bearIndication[0]	= (false);
			}
			
			// MACD Crossover: Fast Line cross below Slow Line
			else if (CrossBelow(MACD(12, 26, 9), MACD(12, 26, 9).Avg, 1))
			{
				// Paint the current price bar magenta to draw our attention to it
				BarBrushes[0]		= Brushes.Magenta;
				
				/* This crossover condition is considered bearish so we set the "bearIndication" Series<bool> object to true.
				We also set the "bullIndication" object to false so it does not take on a null value. */
				bullIndication[0]	= (false);
				bearIndication[0]	= (true);
			}
			
			// MACD Crossover: No cross
			else
			{
				/* Since no crosses occured we are not receiving any bullish or bearish signals so we
				set our Series<bool> objects both to false. */
				bullIndication[0] = (false);
				bearIndication[0] = (false);
			}
			
			// We set our variable to the close value.
			exposedVariable = Close[0];
        }

		// Important code segment in the Properties section. Please expand to view.
        #region Properties
		// Creating public properties that access our internal Series<bool> allows external access to this indicator's Series<bool>
		[Browsable(false)]
		[XmlIgnore]
        public Series<bool> BearIndication
        {
            get { return bearIndication; }	// Allows our public BearIndication Series<bool> to access and expose our interal bearIndication Series<bool>
        }
		
		[Browsable(false)]
		[XmlIgnore]		
        public Series<bool>  BullIndication
        {
            get { return bullIndication; }	// Allows our public BullIndication Series<bool> to access and expose our interal bullIndication Series<bool>
        }

        public double ExposedVariable
        {
			// We need to call the Update() method to ensure our exposed variable is in up-to-date.
            get { Update(); return exposedVariable; }
        }
        #endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleBoolSeries[] cacheSampleBoolSeries;
		public SampleBoolSeries SampleBoolSeries()
		{
			return SampleBoolSeries(Input);
		}

		public SampleBoolSeries SampleBoolSeries(ISeries<double> input)
		{
			if (cacheSampleBoolSeries != null)
				for (int idx = 0; idx < cacheSampleBoolSeries.Length; idx++)
					if (cacheSampleBoolSeries[idx] != null &&  cacheSampleBoolSeries[idx].EqualsInput(input))
						return cacheSampleBoolSeries[idx];
			return CacheIndicator<SampleBoolSeries>(new SampleBoolSeries(), input, ref cacheSampleBoolSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleBoolSeries SampleBoolSeries()
		{
			return indicator.SampleBoolSeries(Input);
		}

		public Indicators.SampleBoolSeries SampleBoolSeries(ISeries<double> input )
		{
			return indicator.SampleBoolSeries(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleBoolSeries SampleBoolSeries()
		{
			return indicator.SampleBoolSeries(Input);
		}

		public Indicators.SampleBoolSeries SampleBoolSeries(ISeries<double> input )
		{
			return indicator.SampleBoolSeries(input);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

//This namespace holds Strategies in this folder and is required. Do not change it. 
namespace NinjaTrader.NinjaScript.Strategies
{
	public class SampleBoolSeriesStrategy : Strategy
	{
		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= @"Sample strategy demonstrating how to call an exposed BoolSeries object";
				Name						= "SampleBoolSeriesStrategy";
				Calculate					= Calculate.OnBarClose;
				EntriesPerDirection			= 1;
				EntryHandling				= EntryHandling.AllEntries;
				IsExitOnSessionCloseStrategy= true;
				ExitOnSessionCloseSeconds	= 30;
				IsFillLimitOnTouch			= false;
				MaximumBarsLookBack			= MaximumBarsLookBack.TwoHundredFiftySix;
				OrderFillResolution			= OrderFillResolution.Standard;
				Slippage					= 0;
				StartBehavior				= StartBehavior.WaitUntilFlat;
				TimeInForce					= TimeInForce.Gtc;
				TraceOrders					= false;
				RealtimeErrorHandling		= RealtimeErrorHandling.StopCancelClose;
				StopTargetHandling			= StopTargetHandling.PerEntryExecution;
				BarsRequiredToTrade			= 20;
			}
			else if (State == State.Configure)
			{
				AddChartIndicator(MACD(12,26,9));
				AddChartIndicator(SampleBoolSeries());
			}
		}

		protected override void OnBarUpdate()
		{
			/* When our indicator gives us a bull signal we enter long. Notice that we are accessing the
			public BoolSeries we made in the indicator. */
			if (SampleBoolSeries().BullIndication[0])
				EnterLong();
			
			// When our indicator gives us a bear signal we enter short
			if (SampleBoolSeries().BearIndication[0])
				EnterShort();
			
			/* NOTE: This strategy is based on reversals thus there are no explicit exit orders. When you
			are long you will be closed and reversed into a short when the bear signal is received. The vice
			versa is true if you are short. */
			
			/* Print our exposed variable. Because we manually kept it up-to-date it will print values that
			match the bars object. */
			Print(SampleBoolSeries().ExposedVariable);
		}
	}
}
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create "myDoubleSeries" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the "myDoubleSeries" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a "barsAgo" value of "0" or, for historical bars, by choosing a "barsAgo" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Definition
Represents historical data as an ISeries<double> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Definition
Represents historical time stamps as an ISeries<DateTime> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<DateTime>
 
 
Multi-Time Frame ISeries<DateTime>
 
Definition
Represents historical volume data as ISeries<double> interface which can be used for custom NinjaScript object calculations
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In NinjaScript we are able to access the bars we want through proper use of the bar's indexing.
 
The bar's indexing is setup in a reverse chronological order. This means "0" refers to the most recent bar, "1" refers to the previous bar, "2" refers to the bar before that one, etc.
 
For example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:
 
Now that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are CurrentBar and BarsSinceNewTradingDay.
 
CurrentBar
CurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.
 
For example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:
 
 
BarsSinceNewTradingDay
BarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.
 
For example, if you wanted to find the open of the current session you could do this:
 
The example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.
 
 
Other Properties and Methods
There are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:
BarsSinceEntryExecution()
BarsSinceExitExecution()
GetBar()
GetDayBar()
HighestBar()
LowestBar()
LRO()
MRO()
Definition
Returns the number of bars that have elapsed since the last specified entry.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous entry does not exist.
 
Syntax
BarsSinceEntryExecution()
BarsSinceEntryExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceEntryExecution(int barsInProgressIndex, string signalName, int entryExecutionsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars that have elapsed since the last specified exit.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous exit does not exist.
 
Syntax
BarsSinceExitExecution()
BarsSinceExitExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceExitExecution(int barsInProgressIndex, string signalName, int exitExecutionsAgo)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Returns the first bar that matches the time stamp of the "time" parameter provided.  
 
 
 
Method Return Value
An int value representing an absolute bar index value.
 
Syntax
Bars.GetBar(DateTime time)
 
Parameters
 
 
Examples
Definition
Returns a virtual historical Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.
 
 
 
Method Return Value
A virtual bar object representing the current configured session. Otherwise null if there is insufficient intraday data
 
Syntax
The properties below return double values:
Bars.GetDayBar(int tradingDaysBack).Open
Bars.GetDayBar(int tradingDaysBack).High
Bars.GetDayBar(int tradingDaysBack).Low
Bars.GetDayBar(int tradingDaysBack).Close
 
The property below returns a DateTime structure:
Bars.GetDayBar(int tradingDaysBack).Time
 
The property below returns an int value:
Bars.GetDayBar(int tradingDaysBack).Volume
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the highest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
HighestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the lowest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
LowestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars. The LRO() method start from the furthest bar away and works toward the current bar.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
LRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Most Recent Occurrence(MRO)
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars.  The MRO() method starts from the current bar works away (backward) from it.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
MRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Least Recent Occurrence(LRO)
Normally calculated values are carried over between trading sessions, but sometimes you may want to reset these values to begin a trading session fresh. The technique demonstrated in this reference sample can be useful to do things like resetting counters you may be running or clearing bool flags you may have set.
 
Key concepts in this example
•Resetting a variable at the beginning of a new trading session
•Limiting the number of trades a strategy can make per trading session
 
Important related documentation
•IsFirstBarOfSession
•IsFirstTickOfBar
•EnterLong()
•ExitLong()
 
Import instructions
1.Download the file contained in this Help Guide topic to your PC desktop
2.From the Control Center window, select the menu Tools > Import > NinjaScript
3.Select the downloaded file
 
https://ninjatrader.com/support/helpGuides/nt8/samples/SampleTradeLimiter_NT8.zip
Definition
Indicates if the current bar processing is the first bar updated in a trading session.
 
 
 
Property Value
This property returns true if the bar is the first processed in a session; otherwise, false.  This property is read-only.
 
 
 
Syntax
Bars.IsFirstBarOfSession
 
 
 
Examples
Definition
Indicates if the incoming tick is the first tick of a new bar. This property is only of value in scripts that run tick by tick which is when the Calculate property is set to Calculate.OnEachTick or Calculate.OnPriceChange.
 
 
 
 
 
Property Value
This property returns true if the incoming tick is the first tick of a new bar; otherwise, false.
 
Syntax
IsFirstTickOfBar
 
 
Examples
Definition
Generates a buy market order to enter a long position.
 
Method Return Value
An Order read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the Advanced Order Handling section.
 
Syntax
EnterLong()
EnterLong(string signalName)
EnterLong(int quantity)
EnterLong(int quantity, string signalName)
 
The following method variation is for experienced programmers who fully understand Advanced Order Handling concepts:
EnterLong(int barsInProgressIndex, int quantity, string signalName)
 
 
 
 
Parameters
 
 
Examples
Definition
Generates a sell market order to exit a long position.
 
Method Return Value
An Order read-only object that represents the order. Reserved for experienced programmers, additional information can be found within the Advanced Order Handling section.
 
Syntax
ExitLong()
ExitLong(int quantity)
ExitLong(string fromEntrySignal)
ExitLong(string signalName, string fromEntrySignal)
ExitLong(int quantity, string signalName, string fromEntrySignal)
 
The following method variation is for experienced programmers who fully understand Advanced Order Handling concepts:
 
ExitLong(int barsInProgressIndex, int quantity, string signalName, string fromEntrySignal)
 
 
Parameters
 
 
Examples
 
// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The Average Directional Index measures the strength of a prevailing trend as well as whether movement 
	/// exists in the market. The ADX is measured on a scale of 0  100. A low ADX value (generally less than 20) 
	/// can indicate a non-trending market with low volumes whereas a cross above 20 may indicate the start of
	///  a trend (either up or down). If the ADX is over 40 and begins to fall, it can indicate the slowdown of a current trend.
	/// </summary>
	public class ADX : Indicator
	{
		private Series<double>		dmPlus;
		private Series<double>		dmMinus;
		private Series<double>		sumDmPlus;
		private Series<double>		sumDmMinus;
		private Series<double>		sumTr;
		private Series<double>		tr;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionADX;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameADX;
				IsSuspendedWhileInactive	= true;
				Period						= 14;
				
				AddPlot(Brushes.Green, "ADX");
				AddLine(Brushes.DarkViolet, 25, "Lower");
				AddLine(Brushes.YellowGreen, 75, "Upper");
			}
			else if (State == State.Configure)
			{
				dmPlus		= new Series<double>(this);
				dmMinus		= new Series<double>(this);
				sumDmPlus	= new Series<double>(this);
				sumDmMinus	= new Series<double>(this);
				sumTr		= new Series<double>(this);
				tr			= new Series<double>(this);
			}
		}
		
		protected override void OnBarUpdate()
		{
			double high0	= High[0];
			double low0		= Low[0];
			
			if (CurrentBar == 0)
			{
				tr[0]				= high0 - low0;
				dmPlus[0]			= 0;
				dmMinus[0]			= 0;
				sumTr[0]			= tr[0];
				sumDmPlus[0]		= dmPlus[0];
				sumDmMinus[0]		= dmMinus[0];
				Value[0]			= 50;
			}
			else
			{
				double high1		= High[1];
				double low1			= Low[1];
				double close1		= Close[1];

				tr[0]				= Math.Max(Math.Abs(low0 - close1), Math.Max(high0 - low0, Math.Abs(high0 - close1)));
				dmPlus[0]			= high0 - high1 > low1 - low0 ? Math.Max(high0 - high1, 0) : 0;
				dmMinus[0]			= low1 - low0 > high0 - high1 ? Math.Max(low1 - low0, 0) : 0;

				if (CurrentBar < Period)
				{
					sumTr[0]		= sumTr[1] + tr[0];
					sumDmPlus[0]	= sumDmPlus[1] + dmPlus[0];
					sumDmMinus[0]	= sumDmMinus[1] + dmMinus[0];
				}
				else
				{
					double sumTr1		= sumTr[1];
					double sumDmPlus1	= sumDmPlus[1];
					double sumDmMinus1	= sumDmMinus[1];
						
					sumTr[0]			= sumTr1 - sumTr1 / Period + tr[0];
					sumDmPlus[0]		= sumDmPlus1 - sumDmPlus1 / Period + dmPlus[0];
					sumDmMinus[0]		= sumDmMinus1 - sumDmMinus1 / Period + dmMinus[0];
				}
				
				double sumTr0		= sumTr[0];
				double diPlus		= 100 * (sumTr0.ApproxCompare(0) == 0 ? 0 : sumDmPlus[0] / sumTr[0]);
				double diMinus		= 100 * (sumTr0.ApproxCompare(0) == 0 ? 0 : sumDmMinus[0] / sumTr[0]);
				double diff			= Math.Abs(diPlus - diMinus);
				double sum			= diPlus + diMinus;

				Value[0]			= sum.ApproxCompare(0) == 0 ? 50 : ((Period - 1) * Value[1] + 100 * diff / sum) / Period;
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private ADX[] cacheADX;
		public ADX ADX(int period)
		{
			return ADX(Input, period);
		}

		public ADX ADX(ISeries<double> input, int period)
		{
			if (cacheADX != null)
				for (int idx = 0; idx < cacheADX.Length; idx++)
					if (cacheADX[idx] != null && cacheADX[idx].Period == period && cacheADX[idx].EqualsInput(input))
						return cacheADX[idx];
			return CacheIndicator<ADX>(new ADX(){ Period = period }, input, ref cacheADX);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.ADX ADX(int period)
		{
			return indicator.ADX(Input, period);
		}

		public Indicators.ADX ADX(ISeries<double> input , int period)
		{
			return indicator.ADX(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.ADX ADX(int period)
		{
			return indicator.ADX(Input, period);
		}

		public Indicators.ADX ADX(ISeries<double> input , int period)
		{
			return indicator.ADX(input, period);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// Plots the open, high, and low values from the session starting on the current day.
	/// </summary>
	public class CurrentDayOHL : Indicator
	{
		private DateTime				currentDate			=	Core.Globals.MinDate;
		private double					currentOpen			=	double.MinValue;
		private double					currentHigh			=	double.MinValue;
		private double					currentLow			=	double.MaxValue;
		private Data.SessionIterator	sessionIterator;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionCurrentDayOHL;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameCurrentDayOHL;
				IsAutoScale					= false;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				PlotCurrentValue			= false;
				ShowLow						= true;
				ShowHigh					= true;
				ShowOpen					= true;
				BarsRequiredToPlot			= 0;

				AddPlot(new Stroke() { Brush = Brushes.Orange,	Width = 2, DashStyleHelper	= DashStyleHelper.Dash }, PlotStyle.Square, "Current Open");
				AddPlot(new Stroke() { Brush = Brushes.Green,	Width = 2, DashStyleHelper	= DashStyleHelper.Dash }, PlotStyle.Square, "Current High");
				AddPlot(new Stroke() { Brush = Brushes.Red,		Width = 2, DashStyleHelper	= DashStyleHelper.Dash }, PlotStyle.Square, "Current Low");
			}
			else if (State == State.Configure)
			{
				currentDate			= Core.Globals.MinDate;
				currentOpen			= double.MinValue;
				currentHigh			= double.MinValue;
				currentLow			= double.MaxValue;
				sessionIterator		= null;
			}
		}

		protected override void OnBarUpdate()
		{
			if (!Bars.BarsType.IsIntraday)
			{
				Draw.TextFixed(this, "error msg", Custom.Resource.CurrentDayOHLError, TextPosition.BottomRight);
				return;
			}

			if (sessionIterator == null)
				sessionIterator = new Data.SessionIterator(BarsArray[0]);

			bool sameDay = true;
			if (currentDate != sessionIterator.GetTradingDay(Time[0]) || currentOpen == double.MinValue)
			{
				currentOpen 	= Open[0];
				currentHigh 	= High[0];
				currentLow		= Low[0];
				sameDay			= false;
			}

			currentHigh 		= Math.Max(currentHigh, High[0]);
			currentLow			= Math.Min(currentLow, Low[0]);
			
			if (ShowOpen)
			{
				if (!PlotCurrentValue || !sameDay)
					CurrentOpen[0] = currentOpen;
				else
					for (int idx = 0; idx < CurrentBar - 1; idx++)
						CurrentOpen[idx] = currentOpen;
			}

			if (ShowHigh)
			{
				if (!PlotCurrentValue || currentHigh != High[0])
					CurrentHigh[0] = currentHigh;
				else
					for (int idx = 0; idx < CurrentBar - 1; idx++)
						CurrentHigh[idx] = currentHigh;
			}

			if (ShowLow)
			{
				if (!PlotCurrentValue || currentLow != Low[0])
					CurrentLow[0] = currentLow;
				else
					for (int idx = 0; idx < CurrentBar - 1; idx++)
						CurrentLow[idx] = currentLow;
			}

			currentDate = sessionIterator.GetTradingDay(Time[0]);
		}

		#region Properties
        [Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
        [XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
        public Series<double> CurrentOpen
        {
            get { return Values[0]; }
        }

        [Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
        [XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
        public Series<double> CurrentHigh
        {
            get { return Values[1]; }
        }

        [Browsable(false)]	// this line prevents the data series from being displayed in the indicator properties dialog, do not remove
        [XmlIgnore()]		// this line ensures that the indicator can be saved/recovered as part of a chart template, do not remove
        public Series<double> CurrentLow
        {
            get { return Values[2]; }
        }

		[Display(ResourceType = typeof(Custom.Resource), Name = "Plot current value", GroupName = "NinjaScriptParameters", Order = 0)]
		public bool PlotCurrentValue
        { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "Show high", GroupName = "NinjaScriptParameters", Order = 1)]
        public bool ShowHigh
        { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "Show low", GroupName = "NinjaScriptParameters", Order = 2)]
        public bool ShowLow
        { get; set; }

		[Display(ResourceType = typeof(Custom.Resource), Name = "Show open", GroupName = "NinjaScriptParameters", Order = 3)]
        public bool ShowOpen
        { get; set; }
        #endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private CurrentDayOHL[] cacheCurrentDayOHL;
		public CurrentDayOHL CurrentDayOHL()
		{
			return CurrentDayOHL(Input);
		}

		public CurrentDayOHL CurrentDayOHL(ISeries<double> input)
		{
			if (cacheCurrentDayOHL != null)
				for (int idx = 0; idx < cacheCurrentDayOHL.Length; idx++)
					if (cacheCurrentDayOHL[idx] != null &&  cacheCurrentDayOHL[idx].EqualsInput(input))
						return cacheCurrentDayOHL[idx];
			return CacheIndicator<CurrentDayOHL>(new CurrentDayOHL(), input, ref cacheCurrentDayOHL);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.CurrentDayOHL CurrentDayOHL()
		{
			return indicator.CurrentDayOHL(Input);
		}

		public Indicators.CurrentDayOHL CurrentDayOHL(ISeries<double> input )
		{
			return indicator.CurrentDayOHL(input);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.CurrentDayOHL CurrentDayOHL()
		{
			return indicator.CurrentDayOHL(Input);
		}

		public Indicators.CurrentDayOHL CurrentDayOHL(ISeries<double> input )
		{
			return indicator.CurrentDayOHL(input);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all strategies and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Strategies
{
	public class SampleTradeLimiter : Strategy
	{
		private int aDXPeriod 		= 14; // Default setting for ADXPeriod
		private int tradeCounter	= 0;  // This variable represents the number of trades taken per day.
		private int maxTrades		= 5;  // This variable sets the maximum number of trades to take per day.

		protected override void OnStateChange()
		{
			if(State == State.SetDefaults)
			{
				ADXPeriod	= 14;
				MaxTrades	= 5;
				Calculate 	= Calculate.OnBarClose;
				Name		= "Sample Trade Limiter";
			}
			else if(State == State.Configure)
			{
				// Add the current day open, high, low indicator to visually see entry conditions.
				AddChartIndicator(CurrentDayOHL());
			}
		}

		protected override void OnBarUpdate()
		{
			// Make sure there are enough bars.
			if (CurrentBar < 1)
				return;
			
			// Reset the tradeCounter value at the first tick of the first bar of each session.
			if (Bars.IsFirstBarOfSession && IsFirstTickOfBar)
			{
				Print("resetting tradeCounter");
				tradeCounter = 0;	
			}
			
			// If the amount of trades is less than the permitted value and the position is flat, go on to the next set of conditions.
			if (tradeCounter < MaxTrades && Position.MarketPosition == MarketPosition.Flat)
			{
				/* If a new low is made, enter short and increase the trade count by 1.
				In C#, ++ means increment by one. An equilivent would be tradeCounter = tradeCounter + 1; */
				if (CurrentDayOHL().CurrentLow[0] < CurrentDayOHL().CurrentLow[1])
				{
					tradeCounter++;
					EnterShort();
				}
				// If a new high is made, enter long and increase the trade count by 1.
				else if (CurrentDayOHL().CurrentHigh[0] > CurrentDayOHL().CurrentHigh[1])
				{
					tradeCounter++;
					EnterLong();
				}
			}
			
			/* Exit a position if "the trend has ended" as indicated by ADX.
			If the current ADX value is less than the previous ADX value, the trend strength is weakening. */
			if (ADX(ADXPeriod)[0] < ADX(ADXPeriod)[1] && Position.MarketPosition != MarketPosition.Flat)
			{
				if (Position.MarketPosition == MarketPosition.Long)
					ExitLong();
				else if (Position.MarketPosition == MarketPosition.Short)
					ExitShort();
			}
		}

		#region Properties
		[Display(GroupName="Parameters", Description="Period for the ADX indicator")]
		public int ADXPeriod
		{
			get { return aDXPeriod; }
			set { aDXPeriod = Math.Max(1, value); }
		}

		[Display(GroupName="Parameters", Description="Maximum number of trades to take per day.")]
		public int MaxTrades
		{
			get { return maxTrades; }
			set { maxTrades = Math.Max(1, value); }
		}
		#endregion
	}
}

The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
permalink
        Signature Changes Overview
permalink
        Name Changes Overview
permalink
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
Understanding the SharpDX .NET Library
NinjaTrader Chart objects (such as Indicators, Strategies, DrawingTools, ChartStyles) implement an OnRender() method aimed to render custom lines, shapes, and text to the chart.  To achieve the level of performance required to keep up with market data events, NinjaTrader uses a 3rd-party open-source .NET library named SharpDX.  This 3rd party library provides a C# wrapper for the powerful Microsoft DirectX API used for graphics processing and known for its hardware-accelerated performance, including 2D vector and text layout graphics used for NinjaTrader Chart Rendering.  The SharpDX/DirectX library is extensive, although NinjaTrader only uses a handful of namespaces and classes, which are documented as a guide in this reference.  In addition to this educational resource, we have also compiled a more focused collection of SharpDX SDK Reference resources to help you learn the SharpDX concepts used in NinjaTrader Chart Rendering.
 
 
There are three main SharpDX namespaces you need to be familiar with:
 
 
The rest of this page will help you navigate the fundamental concepts needed to achieve custom rendering to your charts.
        SharpDX Vectors and Charting Coordinates
permalink
        SharpDX Brush Resources
permalink
        SharpDX RenderTarget
permalink
        SharpDX Lines and Shapes
permalink
        SharpDX Text Rendering
permalink
        SharpDX Stroke Style
permalink
         Best Practices for SharpDX Resources
permalink
Release Date
August 31st, 2016
 
This release marks our first NinjaTrader 8 Release Candidate.  Since the very first NinjaTrader 8 beta version, we have resolved over 4500 bugs thanks to the ongoing efforts of our beta community, and we feel confident we are closer than ever to a production NinjaTrader 8 release.  If you have installed a NinjaTrader 8 beta version and reported feedback to our support team - thank you!
 
As this is a release candidate, NinjaTrader 8.0.0.13 is still considered a beta product and we will continue to focus on product quality.  Please continue to report any issues you may encounter to our support staff.   We will monitor the status of this release to determine when we will announce and launch the production release of NinjaTrader 8.
 
 
 
Code Breaking Changes
Compile Errors
•The Stroke object .Dispose() method was removed due to technical redundancy.  To remove memory resources from any stroke objects, simply set the stroke to null.
•Removed property Bars.IsTimebased -> please use Bars.BarsType.IsTimeBased instead
•Account.Accounts was renamed to Account.All
 
Implementation changes
•The common signature "isInclude60" used in various SessionIterator methods was renamed to "includesEndTimeStamp" to be more specific
•Category display order values of standard NinjaTrader Property Grid Categories were updated to be more consistent application wide.  These changes could impact any customization you were doing using the CategoryOrderAttribute, however, the documentation was also updated to reflect the implementation more accurately and will allow you to use this attribute reliably.
•To assist with transitioning historical order objects to real-time order references, please use the new GetRealtimeOrder() method.
 
Notes
Definition
Represents an interface that exposes information regarding a Text IDrawingTool.
 
Methods and Properties
 
 
 
Example
Definition
Represents an interface that exposes information regarding a Text Fixed IDrawingTool.
 
Methods and Properties
 
 
 
Example
 
 
 
 
 
Definition
Represents an object that can receive drawing commands.
(See also unmanaged API documentation)
 
Syntax
class RenderTarget
 
 
 
Methods and Properties
Rendering methods and properties can be useful when carrying out custom drawing tasks for chart objects. Event handlers such as OnCalculateMinMax() and OnRender() allow you to override behavior at key points in the rendering process.
 
 
 
Methods and Properties
In order to achieve custom rendering for various chart related objects, a Brush is used to "paint" an area or another chart object.  There are a number of different brushes which are available through the .NET Framework, where the most common type of brush is a SolidColorBrush which is used to paint an area with a single solid color.
 
 
        Understanding predefined brushes
permalink
        Understanding custom brushes
permalink
        Using brushes defined on the user interface
permalink
        Using advanced brush types (SharpDX)
permalink


Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create "myDoubleSeries" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the "myDoubleSeries" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a "barsAgo" value of "0" or, for historical bars, by choosing a "barsAgo" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Definition
Represents historical data as an ISeries<double> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Definition
Represents historical time stamps as an ISeries<DateTime> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<DateTime>
 
 
Multi-Time Frame ISeries<DateTime>
 
Definition
Represents historical volume data as ISeries<double> interface which can be used for custom NinjaScript object calculations
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Price Data Overview
The core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.
 
Definitions
 
 
Referencing Series
 
You will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:
 
 High[1] < High[0];
 
You could write a statement to calculate the average closing price of the last three bars like this:
 
 ( Close[2] + Close[1] + Close[0] ) / 3;
 
As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.
 
 
 
Referencing Indicator Data
NinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.
 
All indicator values can be accessed in the following way:
 
 indicator(parameters)[int barsAgo]
 
where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.
 
As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:
 
 Close[0] > SMA(20)[0];
 
If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:
 
 Close[0] > SMA(High, 20)[0];
 
You could write a statement to see if a 14 period CCI indicator is rising like this:
 
 CCI(14)[0] > CCI(14)[1];
 
Value of a 10 period CCI 1 bar ago = CCI(10)[1]
 
Please review the Indicator Methods section for proper syntax for accessing different indicator values.
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create "myDoubleSeries" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the "myDoubleSeries" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a "barsAgo" value of "0" or, for historical bars, by choosing a "barsAgo" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
// 
// Copyright (C) 2016, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
	/// <summary>
	/// The SMA (Simple Moving Average) is an indicator that shows the average value of a security's price over a period of time.
	/// </summary>
	public class SMA : Indicator
	{
		private double priorSum;
		private double sum;

		protected override void OnStateChange()
		{
			if (State == State.SetDefaults)
			{
				Description					= NinjaTrader.Custom.Resource.NinjaScriptIndicatorDescriptionSMA;
				Name						= NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA;
				IsOverlay					= true;
				IsSuspendedWhileInactive	= true;
				Period						= 14;

				AddPlot(Brushes.Goldenrod, NinjaTrader.Custom.Resource.NinjaScriptIndicatorNameSMA);
			}
			else if (State == State.Configure)
			{
				priorSum	= 0;
				sum			= 0;
			}
		}

		protected override void OnBarUpdate()
		{
			if (BarsArray[0].BarsType.IsRemoveLastBarSupported)
			{
				if (CurrentBar == 0)
					Value[0] = Input[0];
				else
				{
					double last = Value[1] * Math.Min(CurrentBar, Period);

					if (CurrentBar >= Period)
						Value[0] = (last + Input[0] - Input[Period]) / Math.Min(CurrentBar, Period);
					else
						Value[0] = ((last + Input[0]) / (Math.Min(CurrentBar, Period) + 1));
				}
			}
			else
			{
				if (IsFirstTickOfBar)
					priorSum = sum;

				sum = priorSum + Input[0] - (CurrentBar >= Period ? Input[Period] : 0);
				Value[0] = sum / (CurrentBar < Period ? CurrentBar + 1 : Period);
			}
		}

		#region Properties
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }
		#endregion
	}
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SMA[] cacheSMA;
		public SMA SMA(int period)
		{
			return SMA(Input, period);
		}

		public SMA SMA(ISeries<double> input, int period)
		{
			if (cacheSMA != null)
				for (int idx = 0; idx < cacheSMA.Length; idx++)
					if (cacheSMA[idx] != null && cacheSMA[idx].Period == period && cacheSMA[idx].EqualsInput(input))
						return cacheSMA[idx];
			return CacheIndicator<SMA>(new SMA(){ Period = period }, input, ref cacheSMA);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SMA SMA(int period)
		{
			return indicator.SMA(Input, period);
		}

		public Indicators.SMA SMA(ISeries<double> input , int period)
		{
			return indicator.SMA(input, period);
		}
	}
}

#endregion// 
// Copyright (C) 2015, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Declarations
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
#endregion

// This namespace holds all indicators and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators
{
     public class SampleCustomSeries : Indicator
     {		
		// Defines the Series object
		private Series<double> myDoubleSeries;

        protected override void OnStateChange()
        {
			if (State == State.SetDefaults)
			{
				// Adds a plot to our NinjaScript Indicator
	            AddPlot(new Stroke(Brushes.Orange, 1), PlotStyle.Bar, "Average Range");
				
				Period					= 5;
				Name					= "Sample custom series";
	            Calculate				= Calculate.OnBarClose;
	            IsOverlay				= false;
			}
			
			else if (State == State.DataLoaded)
			{
				// Create a new Series object and assign it to the variable myDoubleSeries declared in the ‘Variables’ region above
				myDoubleSeries = new Series<double>(this);
			}
        }

        protected override void OnBarUpdate()
        {
			/* To set values to our Series object we use the [] method. Here we are setting the DataSeries
			object for the current bar to take on the absolute value of the difference between the current bar's
			open and close. */
			
			myDoubleSeries[0] = Math.Abs(Close[0] - Open[0]);
			
			/* Take note that the method for setting the value to be plotted is the same as for setting a value
			to a DataSeries object. The difference here is that the custom DataSeries object is not plotted while
			this "Average Range" is plotted.
			
			In this case we are plotting the Simple Moving Average of the intermediate calculation step stored in our
			Series object. */
			
            Value[0] = SMA(myDoubleSeries, Period)[0];
        }

        #region Properties
		
		[Range(1, int.MaxValue), NinjaScriptProperty]
		[Display(ResourceType = typeof(Custom.Resource), Name = "Period", GroupName = "NinjaScriptParameters", Order = 0)]
		public int Period
		{ get; set; }

		#endregion
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private SampleCustomSeries[] cacheSampleCustomSeries;
		public SampleCustomSeries SampleCustomSeries(int period)
		{
			return SampleCustomSeries(Input, period);
		}

		public SampleCustomSeries SampleCustomSeries(ISeries<double> input, int period)
		{
			if (cacheSampleCustomSeries != null)
				for (int idx = 0; idx < cacheSampleCustomSeries.Length; idx++)
					if (cacheSampleCustomSeries[idx] != null && cacheSampleCustomSeries[idx].Period == period && cacheSampleCustomSeries[idx].EqualsInput(input))
						return cacheSampleCustomSeries[idx];
			return CacheIndicator<SampleCustomSeries>(new SampleCustomSeries(){ Period = period }, input, ref cacheSampleCustomSeries);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.SampleCustomSeries SampleCustomSeries(int period)
		{
			return indicator.SampleCustomSeries(Input, period);
		}

		public Indicators.SampleCustomSeries SampleCustomSeries(ISeries<double> input , int period)
		{
			return indicator.SampleCustomSeries(input, period);
		}
	}
}

#endregion
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
In C#, square brackets represent a way to access values stored within an collection. NinjaScript comes with quite a few collections that we call ISeries objects which could be accessed with square brackets. ISeries objects are linked to the underlying bars series in that they hold the same number of values as the number of bars on a chart. For example, to get the close price one bar ago, you would use Close[1] since the value of 1 within the square brackets represents the number of bars ago whose value you wish to reference. As another example, to get the high three bars ago, you would use High[3].
 
 
Many of NinjaTrader's indicators store their values in Series as well, generally in a Plot. Plots are essentially a Series<double> object and to retrieve values from them you need to specify which value you want to access. In most cases, you'd like the current value, so you could use SMA(14)[0], not just SMA(14). SMA(14) is the Indicator its self or Series, and you can't access its values by calling it directly. Using SMA(14)[0] retrieves the part of the Series you're interested in--the most current value.
 
 
Most of the time, you need an index value (number in the square brackets), but there are also cases when you need to use the ISeries instead. CrossAbove() and CrossBelow() are two key examples. If you look at the reference page for CrossAbove(), the two method signatures (overloads) look like this:
 
 
This means the first variable must always be a ISeries<double> object, and the second variable can be either another ISeries<double> or a double value (100, 70.25, etc). To specify a ISeries<double> object, you can just leave off the square brackets. For example if(CrossAbove(SMA(14), SMA(28), 1)) checks if the 14 period SMA has crossed above the 28 period SMA within the last bar. if(CrossAbove(SMA(14)[0], SMA(28)[0], 1)) would give you a compile error because it expects a ISeries<double> as input, not a double value (which is returned when an index is present).
 
Definition
Indicates if the specified input is set at a barsAgo value relative to the current bar.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
Syntax
IsValidDataPoint(int barsAgo)
ISeries<T>.IsValidDataPoint(int barsAgo)
 
 
 
Parameters
 
 
Examples
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
Represents historical data as an ISeries<double> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 
Definition
Represents historical time stamps as an ISeries<DateTime> interface which can be used for custom NinjaScript object calculations.
 
 
 
Single ISeries<DateTime>
 
 
Multi-Time Frame ISeries<DateTime>
 
Definition
Represents historical volume data as ISeries<double> interface which can be used for custom NinjaScript object calculations
 
 
 
Single ISeries<double>
 
 
Multi-Time Frame ISeries<double>
 



Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Definition
Forces all Series<T> objects including plot series objects to hold the maximum amount of bars possible. This property supercedes the UI property of "Maximum bars look back".  
 
 
Method Return Value
A bool value when true, any ISeries<T> interfaces contained in the scripts MaximumBarsLookBack property will be set to MaximumBarsLookBack.Infinite; otherwise will use the default properties configured.  Default is set to false.
 
Syntax
ForcePlotsMaximumBarsLookBackInfinite
 
 
Examples
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create "myDoubleSeries" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the "myDoubleSeries" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a "barsAgo" value of "0" or, for historical bars, by choosing a "barsAgo" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Release Date
July 11, 2016
 
Code Breaking Changes
Compile Errors
•The NinjaScript Strategy "AccountSize" concept was removed due to limited functionality.  This change would also impact strategies which were coded to use SetOrderQuantity.ByAccountSize.  Please use your own variables to set quantities by account size. Tip:  NinjaTrader 8 can read real-world account values for live trading purposes through the Account class, e.g., Account.Get(AccountItem.CashValue, Currency.UsDollar) provides a method for returning a double value representing the current cash value of the account.
 
Implementation changes
•The concept used to force plot series objects through ForcePlotsMaximumBarsLookBackInfinite was disabled and tagged as obsolete.  You should set any indicator/strategy plots to MaximumBarsLookBack.Infinite during its construction.
•It is recommended that any strategies generated with the 'Strategy Builder' tool via Control Center > New > Strategy Builder be removed and recreated after installing B12. If you had invested significant effort in a Strategy Builder generated strategy in B11 which you would like to continue to use, please contact us platformsupport@ninjatrader.com
 
Notes
Definition
Indicates if the specified input is set at a barsAgo value relative to the current bar.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
Syntax
IsValidDataPoint(int barsAgo)
ISeries<T>.IsValidDataPoint(int barsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Draws a region on a chart.
 
Method Return Value
A Region object that represents the draw object.
 
Syntax
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series, double price, Brush areaBrush, int areaOpacity, int displacement = 0)
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush,
        Brush areaBrush, int areaOpacity, [int displacement])
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series, double price, Brush areaBrush, int areaOpacity)
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush, Brush areaBrush, int areaOpacity)
 
Parameters
 
 
Example
 
 
When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In NinjaScript we are able to access the bars we want through proper use of the bar's indexing.
 
The bar's indexing is setup in a reverse chronological order. This means "0" refers to the most recent bar, "1" refers to the previous bar, "2" refers to the bar before that one, etc.
 
For example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:
 
Now that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are CurrentBar and BarsSinceNewTradingDay.
 
CurrentBar
CurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.
 
For example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:
 
 
BarsSinceNewTradingDay
BarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.
 
For example, if you wanted to find the open of the current session you could do this:
 
The example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.
 
 
Other Properties and Methods
There are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:
BarsSinceEntryExecution()
BarsSinceExitExecution()
GetBar()
GetDayBar()
HighestBar()
LowestBar()
LRO()
MRO()


Modifying Existing NinjaTrader Windows
To modify an existing type of NinjaTrader window (for example, to add a button to all charts), you will first need to obtain a reference to each individual window of that type that is open. This can be done by overriding the OnWindowCreated() method, then declaring an object of the Type of the window you are looking for, and finally assigning the object a reference to the Window passed into the method:
 
 
If you are unsure of the Type name for a particular type of window, you can open an instance of that window then run the code below, which will print the Type to the Output Window:
 
 
Once you've obtained a reference to a window, you can then directly manipulate the WPF grids, controls, and other elements to customize its user interface or functionality. For example, if your goal was to add a new button to Chart Trader on all charts, you could use your reference to Chart objects to first locate their attached Chart Trader instances, then place a custom-defined button directly into the WPF grid used to lay out buttons in Chart Trader. Since this code would run within OnWindowCreated(), it would be applied to every Chart Trader instance that is open. You would not be changing the format used to create Chart Traders in the first place, but would rather be detecting every open instance and adding the buttons into them. This is an important distinction to make, because this approach requires that you also remove the elements you've added when each window is destroyed.
 
 
Since we are dynamically adding elements to open windows, it is important to clean up any unused resources and detach any event handlers when the affected windows are destroyed. You can use the same approach as shown above to obtain a reference to each affected window within the OnWindowDestroyed() method:
 
 
Below is another example of adding elements into chart windows. In this example, we add a new panel to the top of all chart windows, then take all existing chart content and move it into a row beneath the panel we've just added:
 
 
Accessing Account Data
From time to time, you may need to access certain global data, such as account values, order states, position info, etc. In these cases, you can subscribe to an appropriate event using a custom event handler method. Below is a list of a few such events which can be captured:
 
 
 
Accessing Market Data
Market data can be accessed via a BarsRequest object, which can provide real-time or snapshot data for use by your classes. A BarsRequest object can be loaded with a series of bar data without the need to actually draw bars on a chart. The BarsRequest object can then be accessed via the BarsUpdateEventArgs object passed into your event handler via the BarsRequest's Update method. The process for using a BarsRequest is as follows:
 
1.Instantiate an Instrument object
2.Instantiate and parameterize a BarsRequest object
3.Hook the BarsRequest's Update event to a custom event handler
4.Call the BarsRequest's Request() method
5.Access bars data directly from the BarsRequest object within your event handler method
 
The following document is intended as a high level overview of the NinjaScript changes you can expect between NinjaTrader 7 and NinjaTrader 8.  For specific information on a particular method or property, you can refer to the dynamically formatted Code Breaking table at the bottom of this page.  We recommend using the Filter and Sorting features built into the table, as well checking the Summary column and expanding the Details section of each entry for general information.  Referring to the conveniently linked NinjaTrader 8 and NinjaTrader 7 documentation will provide specific information on syntax, usage, and examples of any new implementation or element names.  
 
 
 
For questions or comments, please contact us at platformsupport@ninjatrader.com
        Implementation Changes Overview
permalink
        Signature Changes Overview
permalink
        Name Changes Overview
permalink
 
 
Code Breaking Table
Below you will find a reference table which lists all of the supported NinjaScript changes between NinjaTrader 7 and NinjaTrader 8.
 
 
Show 255075100All entries
Filter results:
Showing 1 to 25 of 197 entries
Previous12345…8Next
permalink
Description
Camarilla pivots are a price analysis too that generates potential support and resistance levels by multiplying the prior range then adding or subtracting it from the close.
 
Syntax
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width)
 
Returns R1 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R1[int barsAgo]
 
Returns R2 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R2[int barsAgo]
 
Returns R3 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]
 
Returns R4 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R3[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).R4[int barsAgo]
 
Returns S1 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S1[int barsAgo]
 
Returns S2 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]
Pivots(ISeries<double> input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S2[int barsAgo]
 
Returns S3 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]
Pivots(ISeries<double>input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]
 
Returns S4 value
Pivots(PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S3[int barsAgo]
Pivots(ISeries<double>input, PivotRange pivotRangeType, HLCCalculationMode priorDayHLC, double userDefinedClose, double userDefinedHigh, double userDefinedLow, int width).S4[int barsAgo]
 
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
 
Definition
Used to render custom drawing to a chart from various chart objects, such as an Indicator, DrawingTool or Strategy.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
 
}
 
 
 
Method Parameters
 
 
 
 
Examples
 
 
 
 
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
An event driven method which is called while the chart scale is being updated.  This method is used to determine the highest and lowest value that can be used for the chart scale and is only called when the chart object is set to IsAutoScale.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
You must override the method in your NinjaScript object with the following syntax:
 
public override void OnCalculateMinMax()
{
 
}
 
Method Parameters
This method does not accept any parameters.
 
Examples
Definition
Adds a Bars object for developing a multi-series (multi-time frame or multi-instrument) NinjaScript.
 
Related Methods and Properties
 
 
Syntax
The following syntax will add another Bars object for the primary instrument of the script.
AddDataSeries(BarsPeriod barsPeriod)
AddDataSeries(BarsPeriodType periodType, int period)
 
The following syntax allows you to add another Bars object for a different instrument to the script:
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period)
AddDataSeries(string instrumentName, BarsPeriodType periodType, int period, MarketDataType marketDataType)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName, BarsPeriod barsPeriod, int barsToLoad, string tradingHoursName, bool? isResetOnNewTradingDay)
AddDataSeries(string instrumentName) //only for R15 and higher
 
 
 
Parameters
 
 
 
 
Examples
 
 
The ChartScale class includes a range of properties related to the Y-Axis values of the ChartPanel on which the calling script resides.  The ChartScale can be configured to Right, Left, or Overlay.
 

 
Methods and Properties
Definition
The primary Bars object time frame (period type and interval).
 
 
 
Property Value
A Bars series object representing the time frame of the Bars.
 
Syntax
 
 
Examples
 
 
Definition
BarsRequest can be used to request Bars data and subscribe to real-time Bars data events.
 
 
 
Syntax
BarsRequest(Cbi.Instrument instrument, int barsBack)
BarsRequest(Cbi.Instrument instrument, DateTime fromLocal, DateTime toLocal)
 
Parameters
 
 
Methods and Properties
 
 
Examples
Definition
Represents various account variables used to reflect values the status of the account.  Each account connected in NinjaTrader will have it's own unique AccountItem values.
 
 
 
Syntax
AccountItem
 
Parameters
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create "myDoubleSeries" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the "myDoubleSeries" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a "barsAgo" value of "0" or, for historical bars, by choosing a "barsAgo" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Code Snippets can provide you with useful code templates to speed up your coding process.
        Understanding Code Snippet shortcuts
permalink
        How to use Code Snippet shortcuts via the keyboard
permalink
        How to insert Code Snippets via the mouse or F2 key
permalink
In C#, square brackets represent a way to access values stored within an collection. NinjaScript comes with quite a few collections that we call ISeries objects which could be accessed with square brackets. ISeries objects are linked to the underlying bars series in that they hold the same number of values as the number of bars on a chart. For example, to get the close price one bar ago, you would use Close[1] since the value of 1 within the square brackets represents the number of bars ago whose value you wish to reference. As another example, to get the high three bars ago, you would use High[3].
 
 
Many of NinjaTrader's indicators store their values in Series as well, generally in a Plot. Plots are essentially a Series<double> object and to retrieve values from them you need to specify which value you want to access. In most cases, you'd like the current value, so you could use SMA(14)[0], not just SMA(14). SMA(14) is the Indicator its self or Series, and you can't access its values by calling it directly. Using SMA(14)[0] retrieves the part of the Series you're interested in--the most current value.
 
 
Most of the time, you need an index value (number in the square brackets), but there are also cases when you need to use the ISeries instead. CrossAbove() and CrossBelow() are two key examples. If you look at the reference page for CrossAbove(), the two method signatures (overloads) look like this:
 
 
This means the first variable must always be a ISeries<double> object, and the second variable can be either another ISeries<double> or a double value (100, 70.25, etc). To specify a ISeries<double> object, you can just leave off the square brackets. For example if(CrossAbove(SMA(14), SMA(28), 1)) checks if the 14 period SMA has crossed above the 28 period SMA within the last bar. if(CrossAbove(SMA(14)[0], SMA(28)[0], 1)) would give you a compile error because it expects a ISeries<double> as input, not a double value (which is returned when an index is present).
 
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Kagi Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType)
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName)
AddKagi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int reversal, Data.ReversalType reversalType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Point-and-Figure Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType)
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName)
AddPointAndFigure(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int boxSize, int reversal, Data.PointAndFigurePriceType pointAndFigurePriceType, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Returns the series value on the chart scale determined by a y pixel coordinate on the chart.
 
Method Return Value
A double value representing a series value on the chart scale.  This is normally a price value, but can represent indicator plot values as well.
 
Syntax
<chartScale>.GetValueByY(float y)
 
Method Parameters
 
 
Examples
 
 
In the image below, we pass a value of 1 for the y value, which tells us the pixel coordinate of 1 is located at a price of 2106.19 on the chart scale
 

Description
The correlation indicator will plot the correlation of the data series to a desired instrument. Values close to 1 indicate movement in the same direction. Values close to -1 indicate movement in opposite directions. Values near 0 indicate no correlation.
 
 
Syntax
Correlation(int period, string correlationSeries)
string correlationSeies(ISeries<double> input, int period, string correlationSeies)
 
 
Return Value
double; Accessing this method via an index value [int barsAgo] returns the indicator value of the referenced bar.
 
 
Parameters
 
 
Examples
 
 
 
 
Source Code
You can view this indicator method source code by selecting the menu New > NinjaScript Editor > Indicators within the NinjaTrader Control Center window.
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Order Flow Volumetric Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, string tradingHoursName, bool? isResetOnNewTradingDay)
AddVolumetric(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.VolumetricDeltaType deltaType, int tickPerLevel, int sizeFilter, string tradingHoursName, bool? isResetOnNewTradingDay) (R17 and higher only)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Heiken Ashi Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType)
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName)
AddHeikenAshi(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Similar to the AddDataSeries() method for adding Bars objects, this method adds a Line Break Bars object for multi-series NinjaScript.
 
 
 
Syntax
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName)
AddLineBreak(string instrumentName, Data.BarsPeriodType baseBarsPeriodType, int baseBarsPeriodTypeValue, int lineBreakCount, Data.MarketDataType marketDataType, string tradingHoursName, bool? isResetOnNewTradingDay)
 
 
 
Parameters
 
 
 
Examples
Definition
Returns the series value on the chart scale determined by a WPF coordinate on the chart.  
 
Method Return Value
A double value representing a series value on the chart scale.  This is normally a price value, but can represent indicator plot values as well.
 
Syntax
<chartScale>.GetValueByYWpf(double y)
 
Method Parameters
 
 
Examples
 
 
In the image below, we used the Chart Control property MouseDownPoint as the "wpfy" variable, which in return tells us the user clicked on a Y value of 2105.499 on the chart scale.
 

8.0.5.0 Release
March 6, 2017
 
 
8.0.5.1 Release
March 8, 2017
 
 
8.0.5.2 Release
March 15, 2017
 
Release Date
August 31st, 2016
 
This release marks our first NinjaTrader 8 Release Candidate.  Since the very first NinjaTrader 8 beta version, we have resolved over 4500 bugs thanks to the ongoing efforts of our beta community, and we feel confident we are closer than ever to a production NinjaTrader 8 release.  If you have installed a NinjaTrader 8 beta version and reported feedback to our support team - thank you!
 
As this is a release candidate, NinjaTrader 8.0.0.13 is still considered a beta product and we will continue to focus on product quality.  Please continue to report any issues you may encounter to our support staff.   We will monitor the status of this release to determine when we will announce and launch the production release of NinjaTrader 8.
 
 
 
Code Breaking Changes
Compile Errors
•The Stroke object .Dispose() method was removed due to technical redundancy.  To remove memory resources from any stroke objects, simply set the stroke to null.
•Removed property Bars.IsTimebased -> please use Bars.BarsType.IsTimeBased instead
•Account.Accounts was renamed to Account.All
 
Implementation changes
•The common signature "isInclude60" used in various SessionIterator methods was renamed to "includesEndTimeStamp" to be more specific
•Category display order values of standard NinjaTrader Property Grid Categories were updated to be more consistent application wide.  These changes could impact any customization you were doing using the CategoryOrderAttribute, however, the documentation was also updated to reflect the implementation more accurately and will allow you to use this attribute reliably.
•To assist with transitioning historical order objects to real-time order references, please use the new GetRealtimeOrder() method.
 
Notes
Definition
An event driven method which is called whenever the script enters a new State. The OnStateChange() method can be used to configure script properties, create one-time behavior when going from historical to real-time, as well as manage clean up resources on termination.
 
 
 
 
Related Methods and Properties
 
 
Method Return Value
This method does not return a value.
 
 
Syntax
See example below. The NinjaScript wizards automatically generate the method syntax for you.
 
Possible states are:
 
 
Active States vs Data Processing States
After State.Configure, each type of NinjaScript type has its own state management system which can be classified under two categories:
 
•Active state:  State.Active
•Data Processing states: State.DataLoaded, State.Historical, State.Transition, State.Realtime
 
The table below lists each NinjaScript type and it's designed state management system:
 
 
 
 
 
Examples
Definition
Determines if the strategy should be re-instantiated (re-created) after each optimization run when using the Strategy Analyzer Optimizer.  
 
The default behavior is to re-instantiate the strategy for each optimization backtest run. However, the process of re-instantiating a strategy requires more time and computer resources to return results, which could impact the amount of time it takes to run an optimization.  When false, the strategy is re-used to save time and computer resources.  Under this design, internal properties are reset to default values after each iteration, but it is possible that user-defined properties and other custom resources may carry their state over from the previous iteration into a new backtest run.  To take advantage of performance optimizations, developers may need to reset class level variables in the strategy otherwise unexpected results can occur.
 
 
 
Property Value
This property returns true if the strategy is not recycled; otherwise, false. Default set to true.
 
 
 
Syntax
IsInstantiatedOnEachOptimizationIteration
 
 
 
Examples
 
 
Definition
Represents a change in fundamental data and is passed as a parameter in the OnFundamentalData() method.
 
Methods and Parameters
 
Examples
 
Tips
1.Not all connectivity providers support all FundamentalDataTypes.
2.EarningsPerShare on eSignal is a trailing twelve months value. On IQFeed it is the last quarter's value.
3.RevenuePerShare is a trailing twelve months value.
Definition
Represents a change in fundamental data and is passed as a parameter in the OnFundamentalData() method.
 
Methods and Parameters
 
Examples
 
Tips
1.Not all connectivity providers support all FundamentalDataTypes.
2.EarningsPerShare on eSignal is a trailing twelve months value. On IQFeed it is the last quarter's value.
3.RevenuePerShare is a trailing twelve months value.


Multi-Series Scripting Overview
NinjaScript supports multiple time frames and instruments in a single script. This is possible because you can add additional Bars objects to indicators or strategies, in addition to the primary Bars object to which they are applied. A Bars object represents all of the bars of data on a chart. For example, if you had a MSFT 1 minute chart with 200 bars on it, the 200 bars represent one Bars object. In addition to adding Bars objects for reference or for use with indicator methods, you can execute trades across all the different instruments in a script. There is extreme flexibility in the NinjaScript model that NinjaTrader uses for multiple-bars scripts, so it is very important that you understand how it all works before you incorporate additional Bars objects in a script. An important fact to understand is that NinjaScript is truly event driven; every Bars object in a script will call the OnBarUpdate() method. The significance of this will become evident throughout this page.
 
 
It is also important that you understand the following method and properties:
 
•AddDataSeries()
•BarsArray
•BarsInProgress
•CurrentBars
 
        Working With Multi-Time Frame Objects
permalink
        Adding Additional Bars Objects to NinjaScript
permalink
        Creating Series<T> Objects
permalink
        How Bars Data is Referenced
permalink
        Using Bars Objects as Input to Indicator Methods
permalink
        True Event Driven OnBarUpdate() Method
permalink
        Accessing the Price Data in a Multi-Bars NinjaScript
permalink
        Entering, Exiting and Retrieving Position Information
permalink
There are some best practices to be aware of when developing NinjaScript classes. The following tables present a non-exhaustive list of considerations to keep in mind when designing and implementing your code.
 
 
        State management practices
        Error handling practices
        Performance practices
Definition
ISeries<T> is an interface that is implemented by all NinjaScript classes that manage historical data as an ISeries<double> (Open, High, Low, Close, etc), used for indicator input, and other object data.  Please see the help guide article on Working with Price Series for a basic overview on how to access this information.
 
Types of ISeries
 
 
Methods and Properties
 
 
 
Examples
 
 
Definition
The main historical data input. If implemented in the NinjaScript object, it allows for more flexibility as non bars based series such as plot series could be passed in and drive the calculation outcomes - an example would be a custom moving average that should have the ability to operate on another moving average (i.e. the SMA) as input series.
 
Property Value
An ISeries<double> type object that implements the Series<double> interface. Accessing this property via an index value [int barsAgo] returns a double value representing the price of the referenced bar.
 
Syntax
Input
Input[int barsAgo]
 
 
 
Examples
 
 
 
 
Price Data Overview
The core objective of developing custom Indicators and Strategies with NinjaScript is to evaluate price data. NinjaScript allows you to reference current and historical price data. There are several categories of price data which include ISeries<T>, Indicator and Custom Historical Series.
 
Definitions
 
 
Referencing Series
 
You will notice that to reference any price data you need to include a value for [int barsAgo]. This is a very simple concept; barsAgo represents the number of bars ago to reference and int indicates that barsAgo is an integer value. As an example, we could write a statement to check if the the high price of 1 bar ago is less than the high price of the current bar like this:
 
 High[1] < High[0];
 
You could write a statement to calculate the average closing price of the last three bars like this:
 
 ( Close[2] + Close[1] + Close[0] ) / 3;
 
As you may have already figured out, referencing the current bar data is accomplished by passing in a value of 0 (zero) to the barsAgo parameter. Basically, we are saying show me the price data of zero bars ago, which means the current bar.
 
 
 
Referencing Indicator Data
NinjaScript includes a library of built in indicators that you can access. Please see the Indicator Methods reference section for clear definitions for how to access each indicator.
 
All indicator values can be accessed in the following way:
 
 indicator(parameters)[int barsAgo]
 
where indicator is the name of the indicator you want to access, parameters is any associated parameters the indicator requires and barsAgo is the number of bars we wish to offset from the current bar.
 
As an example, we could write a statement to check if the current closing price is greater than the 20 period simple moving average like this:
 
 Close[0] > SMA(20)[0];
 
If you wanted to perform the same check but only check against a 20 period simple moving average of high prices you would write it like this:
 
 Close[0] > SMA(High, 20)[0];
 
You could write a statement to see if a 14 period CCI indicator is rising like this:
 
 CCI(14)[0] > CCI(14)[1];
 
Value of a 10 period CCI 1 bar ago = CCI(10)[1]
 
Please review the Indicator Methods section for proper syntax for accessing different indicator values.
See additional patch notes at the bottom
 
8.1.2.0 Release Date
October 25, 2023
 
 
 
8.1.2.1 Release Date
November 27, 2023
NinjaTrader comes with over 100 pre-built technical indicators, which can be added, removed and edited via the Indicators window. Indicators can be applied to charts, the SuperDOM, or Market Analyzer columns, and custom technical indicators can be created via the NinjaScript Editor.
 
        Understanding the Indicators window
permalink
        How to add an Indicator
permalink
        How to edit an Indicator's parameters 
permalink
        How to remove an Indicator
permalink
        Custom Indicator development
permalink
        Working with Indicators in Market Analyzer columns
permalink
        Working with Indicators in the SuperDOM
permalink
 
NinjaTrader Order Flow Volumetric bars provide a detailed ‘x-ray’ view into each price bar’s aggressive buying and selling activity. This technique primarily attempts to answer the question which side was the most aggressive at each price level. This is done by calculating the delta (greek for difference) between buying and selling volume (please see the Delta type property explanation below).
 
With the delta value known for each price level in the bar, it is then classified per each session for analysis and emphasizes the buying / selling strength unfolding. This is done by a gradient coloring approach shading the value cells in the bar, where the level of sensitivity for the gradient can be set via the Shading sensitivity property. The higher this value is set, the finer the gradient can be applied to various levels of strength - the NinjaTrader default is 20 levels.
 
This can be thought of as a way of not only saying who ‘won / lost’ the price level’s auction, but also by what margin or strength. This is not a signal in itself per se, but rather a mechanical means to classify the buying vs selling activity at each individual price level and thus offer the trader a more detailed look what happens inside the price bars.
 
A second comparison of buy sell volumes is the Imbalance detection. Here the price level buying and selling volumes are compared diagonally to understand which side of the market was stronger by exceeding the set Imbalance ratio. For example if the buying volume was 1000 contracts and the selling volume diagonal below was 300 then buying Imbalance was detected (assuming a default Imbalance ratio of 1.5). This can be helpful especially if multiple Imbalances 'cluster' close together to form support / resistance areas.
 
NinjaTrader Order Flow Volumetric bars can provide a large degree of details and facilitate displaying the information in a dynamically sized way, as the text is re-sized as your horizontally or vertically adjust the chart's scale range.
 
 
        Order Flow Volumetric Overview
permalink
 
        Order Flow Volumetric Imbalance Customization Example
permalink
 
        Order Flow Volumetric Bars parameters
permalink
 
        Order Flow Volumetric Values NinjaScript access
permalink
 
Advanced order handling is reserved for EXPERIENCED programmers. Through advanced order handling you can submit, change and cancel orders at your discretion through any event-driven method within a strategy. Each order method within the "Managed Approach" section has a method overload designed for advanced handling.
 
        Live Until Cancelled Orders
permalink
        The Order Class
permalink
        Transitioning order references from historical to live
permalink
        Working with a Multi-Instrument Strategy
permalink
8.0.15.0 Release Date
July 30, 2018
 
 
 
8.0.15.1 Release Date
August 1, 2018
 
Release Date
January 9, 2017
 
 
 
The OnBarUpdate() method is called for each incoming tick, or on the close of a bar (if enabled) when performing real-time calculations, and is called on each bar of a Bars object when re-calculating the indicator (For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed). This is the main method used for indicator calculations, and we will calculate our core indicator logic (testing to see if a Close price on a specified bar was greater than the previous Close price) within this method.
 
Adding the Condition and Assigning the Plot Value
Enter the following code in the OnBarUpdate() method in the NinjaScript Editor:
 
 
 
Although the code above fits on a single line, it is doing several things. Firstly, it is important to understand the structure that we are using in this statement. We are using a Ternary Operator, which provides a way to assign one of two values to a variable based on a condition. We begin by stating that we wish to assign a value to the indicator plot at a bar index corresponding to BarsAgo. We do this by using Values, which is a collection holding values for all plots configured in the indicator:
 
 
 
Next, we add a condition to test. In this case, we are testing to see whether Close at a bar index corresponding to the value of BarsAgo was greater than Close at a value of BarsAgo + 1. If BarsAgo was set to 5, for example, this would compare Close[5] to Close[6]:
 
 
 
If the condition evaluates to true, then the first expression will be run (the expression on the left side of the colon ":"), which will assign the value of the indicator plot to the High price of the specified bar, plus five ticks. We obtain the tick size value for the configured instrument via the TickSize property:
 
 
 
if the condition evaluates to false, then the second expression will be run (the expression on the right side of the colon ":", which will assign the value of the indicator plot to the Low price of the specified bar, less five ticks:
 
 
 
The core indicator logic is now in place, but running this code as it is can result in an "Index out of range" exception. Since we are looking a certain number of bars back in time, we need to make sure that there are always enough bars on the chart for us to look back. For example, if BarsAgo were set to 5, then we would be comparing the value of five bars ago to the value of six bars ago, but on Bars # 1, 2, 3, 4, or 5, at which point we do not have five or six bars to look back, the indicator will cause an error. To resolve this, we will add a condition which will prevent the core calculations from running unless we know there are enough bars on the chart. Add the following line just above the line you have been working on throughout this page:
 
 
 
This line says, "if there is not a number of bars equal to one number greater than the value of BarsAgo, then exit OnBarUpdate()."
 
Now that everything is in place, your class code should look as below. You are now ready to compile the indicator and configure it on a chart.
 
A Data Series represents a series of price data, which can be displayed on a chart using one of several Bar Types and Chart Styles. One or more Data Series will be applied to a new chart when it is created, and additional Data Series can be added, edited, or removed via the Data Series window.
 
        Understanding the Data Series Window
permalink
        How to add a Data Series
permalink
        How to edit Data Series parameters
permalink
        How to change a Data Series
permalink
        Removing a Data Series
permalink
 
 
The SuperDOM's Price Ladder display has the ability to add any number of price action indicators which can be used to visualize and analyze indicator values in relation to the SuperDOM display, as well as attaching working orders to the indicator price level for a hand-free trade management system.
 

 
NinjaTrader comes with over 30 pre-built indicators which can be added the SuperDOM. Indicators can be added, removed and edited via the Indicators window.
        Understanding the Indicators window
permalink
        How to add an indicator
permalink
        How to edit an indicator's parameters
permalink
        Understanding how indicators are displayed
permalink
        How to remove an indicator
permalink
        Custom indicator development
permalink
NinjaTrader supports a large variety of chart Bar Types. This page explains how each Bar Type is created in a chart. Please see the Working with Price Data page for information on how to change Bar Types.
 
        Understanding Tick bars
permalink
        Understanding Volume bars
permalink
        Understanding Range bars
permalink
        Understanding Time based bars
permalink
        Understanding Heiken Ashi bars
permalink
        Understanding Kagi bars
permalink
        Understanding Renko bars
permalink
        Understanding Point and Figure bars
permalink
        Understanding Line Break bars
permalink
        Understanding Order Flow Volumetric Bars
permalink
        Understanding Order Flow Delta Bars
permalink
        Understanding Order Flow Price On Volume Bars
permalink
8.0.7.0 Release
June 6, 2017
 
 
 
8.0.7.1 Release
June 21, 2017
 
8.0.7.0 Release
June 6, 2017
 
 
 
8.0.7.1 Release
June 21, 2017
 
Multiple Data Series
Multiple Data Series objects can be be viewed within a single chart window, and there are several ways to add Data Series to a chart.
        How to Add a Data Series
permalink
        Managing Multiple Data Series
permalink
NinjaTrader supports trading and viewing market data for spot forex pairs, in addition to other supported instrument types. Due to the unique nature of forex markets, there are a number of features throughout the platform tailored specifically to these instruments, and a few considerations to keep in mind when working with forex in NinjaTrader.
        Pips Calculation Mode
permalink
        Pips in ATM Strategies
permalink
        Forex Lot Sizes
permalink
        Forex-Specific Trading Windows
permalink
        How Bars Are Built and Orders Filled
permalink
        Forex Trading Hours
permalink
        Calculating Pip Value
permalink
Release Date
January 31, 2017
 
8.0.20.1 Release Date
December 23, 2019
 
 
 
8.0.20.0 Release Date
December 5, 2019
 
 
 
8.0.6.0 Release
April 17, 2017
 
 
 
8.0.6.1 Release
April 25, 2017
 
The OnBarUpdate() method is called for each incoming tick or on the close of a bar (user defined) when performing real-time calculations and is called on each bar of a data series when re-calculating the indicator. For example, an indicator would be re-calculated when adding it to an existing chart that has existing price data displayed. Therefore, this is the main method called for indicator calculation and we will use this method to enter the script that will calculate the ROC value.
 
Setting Plot Thresholds
The OnStateChange() method is called once before any bar data is loaded and is used to configure the indicator. The code below is automatically generated by the wizard and added to the OnStateChange() method. It configures the indicator for two plots and one line and sets the parameters.
 
 
Enter the following code in the OnStateChange() method and below the wizard generated code:
 
 
The concept of setting threshold values is to set when and when not to paint a plot on the chart. In this indicator, we have an "AboveZero" plot with a default color of green which we only want to see when the value of ROC is above zero and a "BelowZero" plot with a default color of OrangeRed which we only want to see when the value of ROC is below zero. In order to make that happen we have to set the threshold values of each plot.
 
Plots[0].Min = 0;
 
This statement says, in the collection of Plot objects, take the first one (Plots[0]) and set its minimum value to zero. This means any value below zero will not display.
 
Plots[1].Max = 0;
 
This statement says, in the collection of Plot objects, take the second one (Plots[1]) and set its maximum value to zero. This means any value above zero will not display.
 
We now have a simple plot switching mechanism that displays the correct colored line depending on if the value of ROC is above or below zero. In fact, you can take this concept a little bit farther. You can even set different plots style (bar, dot etc..) depending on threshold values.
 
A quick word about collections. Collections are objects that store a collection of objects, kind of like a container. In this case we are working with a collection of plots. In the above wizard generated code you will notice that we are adding new plots to the "Plots" collection. "AboveZero" was added first and then "BelowZero". This means that we can reference the "AboveZero" plot object through Plots[0]. The reason we don't pass in a value of 1 is because collections are zero based indexes. This means the first item has an index of 0, the second time an index of 1 and so forth.
 
Completing the Indicator
This indicator is actually quite simple in its implementation. The last thing we need to do is add the calculation code and set the value of ROC to both our plot lines.
Replace the wizard generated code with the following code into the OnBarUpdate() method in the NinjaScript Editor:
 
 
The calculation first checks to ensure there are enough bars to complete the calculation and then sets both plot lines to the ROC value.
 
The class code in your editor should look identical to the image below. You are now ready to compile the indicator and configure it on a chart.
 
Charts in NinjaTrader can contain and display multiple objects, including Data Series, Drawing Objects, and indicator plots. Objects on charts can be managed in a number ways, such as dragging and dropping them to new panels, changing the axis of their price scale (if applicable), or changing the order in which they are painted on a chart.
        How to drag and drop chart objects
permalink
        How to copy and paste chart objects
permalink
        How to change the z-order (paint order) of a chart object
permalink
The Builder point and click interface is a powerful entrypoint into NinjaScript strategy development for non programmers. Even if you target more deeper custom coding later on in the development cycle, the Builder can provide a great foundation to start with. To get started directly into full fledged programming a strategy object in the NinjaScript editor, please check into NinjaScript Wizard.
 
        Understanding the Welcome screen
permalink
        Understanding the General screen
permalink
        Understanding the Default properties screen
permalink
        Understanding the Additional data screen
permalink
        Understanding the Inputs and Variables screen
permalink
        Understanding the Conditions and Actions screen
permalink
        Understanding the Stops and Targets screen
permalink
        Understanding the Finish screen
permalink
The Builder point and click interface is a powerful entrypoint into NinjaScript strategy development for non programmers. Even if you target more deeper custom coding later on in the development cycle, the Builder can provide a great foundation to start with. To get started directly into full fledged programming a strategy object in the NinjaScript editor, please check into NinjaScript Wizard.
 
        Understanding the Welcome screen
permalink
        Understanding the General screen
permalink
        Understanding the Default properties screen
permalink
        Understanding the Additional data screen
permalink
        Understanding the Inputs and Variables screen
permalink
        Understanding the Conditions and Actions screen
permalink
        Understanding the Stops and Targets screen
permalink
        Understanding the Finish screen
permalink
Description
Order Flow Volume profile tools are available as both an Indicator and Drawing Tool and along with the suite of the 'Order Flow +' tools only available to NinjaTrader lifetime license holders. The indicator is used to plot singular static profiles containing a certain defined range of data or repeating profiles on a per bar or per session basis. The drawing tool allows you to easily define both the start and end point to create a custom profile for any bar range on a chart.
 
        Order Flow Volume Profile Concepts
permalink
        Understanding Price Profiles
permalink
        Understanding Composite Profiles
permalink
        Understanding the Order Flow Volume Profile Drawing Tool
permalink
        Order Flow Volume Profile 'Set up' Parameters
permalink
        Order Flow Volume Profile 'Visual' Parameters
permalink
        Order Flow Volume Profile 'Lines' Parameters
permalink
        Order Flow Volume Profile 'Label' Parameters
permalink
Definition
Used to render custom drawing to a chart from various chart objects, such as an Indicator, DrawingTool or Strategy.
 
 
 
Method Return Value
This method does not return a value
 
Syntax
protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
{
 
}
 
 
 
Method Parameters
 
 
 
 
Examples
 
 
 
 
Chart Trader allows for the placement of orders, and the management of orders and positions, directly from a chart. Orders and positions within Chart Trader are displayed in a visual manner, allowing you to quickly compare them with current market movements while modifying orders in real-time. Chart Trader contains two primary components: the Chart Trader panel, which is used to place, modify, or cancel/close orders and positions, and the chart panel, on which Chart Trader draws visual representations of resting orders and open positions.
        Understanding order display
permalink
        Understanding Position Display
permalink
        Working with multiple instruments
permalink
The Managed approach in NinjaScript is designed to offer the greatest ease of use for beginner to intermediate programmers. The order methods are wrapped in a convenience layer that allows you to focus on your system's trading rules, leaving the underlying mechanics of order management and the relationships between entry orders, exit orders, and positions to NinjaTrader. This approach is best suited for simple to moderate order complexity, and can be further broken down into a Basic/Common Managed approach and a more Advanced Managed approach. The following section will discuss the use of the Basic/Common approach.
 
A few key points to keep in mind:
 
•Orders are submitted as live and working when a strategy is running in real-time
•Profit target, stop loss and trail stop orders are submitted immediately when an entry order is filled, and are tied together via OCO (One Cancels Other)
•Order changes and cancellations are queued in the event that the order is in a state where it can't be cancelled or modified
•By default, orders submitted via Entry() and Exit() methods automatically cancel at the end of a bar if not re-submitted
•Entry() methods will reverse the position automatically. For example if you are in a 1 contract long position and now call EnterShort() -> you will see 2 executions, one to close the prior long position and the other to get you into the desired 1 contract short position.
 
* Via the SetProfitTarget(), SetStopLoss(), SetTrailStop() and SetParabolicStop methods
 
        Order submission for entry and exit methods - basic operation
permalink
        Order Entry Methods
permalink
        Quantity Type and TIF
permalink
        How to close a position
permalink
        Understanding core order objects
permalink
        Internal Order Handling Rules that Reduce Unwanted Positions
permalink
 
 
 
Definition
Returns a measurement of the steepness of a price series (y value) measured by the change over time (x value).  The return value can also be thought of as the ratio between the startBarsAgo and endBarsAgo parameters passed to the method.  
 
The formula which is returned from the parameters passed is:
 
(series[endBarsAgo] - series[startBarsAgo]) / (startBarsAgo - endBarsAgo)
 
 
 
Method Return Value
This method returns a double value indicating the slope of a line;  A value of 0 returns if the either the startBars or endBars parameters are less than 0 or both parameters are of equal value.
 
Syntax
Slope(ISeries<double> series, int startBarsAgo, int endBarsAgo)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Adds an indicator to the strategy only for the purpose of displaying it on a chart.
 
 
 
Method Return Value
This method does not return a value.
 
Syntax
AddChartIndicator(IndicatorBase indicator)
 
 
 
Parameters
 
 
 
Examples
 
 
 
 


Definition
Determines memory performance of custom Series<T> objects (such as Series<double>, Series<long>, etc.).  When using MaximumBarsLookBack.TwoHundredFiftySix, only the last 256 values of the series object will be stored in memory and be accessible for reference. This results in significant memory savings when using multiple series objects. In the rare case should you need older values you can use MaximumBarsLookBack.Infinite to allow full access of the series.
 
 
 
Property Value
A MaximumBarsLookBack enum value. Default value is MaximumBarsLookBack.TwoHundredFiftySix
 
Possible values are:
 
 
 
 
Syntax
MaximumBarsLookBack
 
Examples
 
 
Definition
Forces all Series<T> objects including plot series objects to hold the maximum amount of bars possible. This property supercedes the UI property of "Maximum bars look back".  
 
 
Method Return Value
A bool value when true, any ISeries<T> interfaces contained in the scripts MaximumBarsLookBack property will be set to MaximumBarsLookBack.Infinite; otherwise will use the default properties configured.  Default is set to false.
 
Syntax
ForcePlotsMaximumBarsLookBackInfinite
 
 
Examples
Definition
A Series<T> is a special generic type of data structure that can be constructed with any chosen data type and holds a series of values equal to the same number of elements as bars in a chart. If you have 200 bars loaded in your chart with a moving average plotted, the moving average itself holds a Series<double> object with 200 historical values of data, one for each bar. Series<double> objects can be used as input data for all indicator methods. The Series<T> class implements the ISeries<T> interface.
 
 
 
Parameters
 
Methods and Properties
 
 
Creating Series<T> Objects
When creating custom indicators, Series<double> objects are automatically created for you by calling the AddPlot() method and can be subsequently referenced by the Value and/or Values property. However, you may have a requirement to create a Series<T> object to store values that are part of an overall indicator value calculation. This can be done within a custom indicator or strategy.
 
 
 
To create a Series<T> object:
 
1.Determine the data type of the Series<T> object you wish to create. This could be double, bool, int, string or any other object type you want.
2.Define a variable of type Series<T> that will hold a Series<T> object. This example will create "myDoubleSeries" as a Series<double>.
3.In the OnStateChange() method, in the State.DataLoaded create a new Series<T> object and assign it to the "myDoubleSeries" variable
 
 
 
 
 
Setting Values
You can set the value for the current bar being evaluated by choosing a "barsAgo" value of "0" or, for historical bars, by choosing a "barsAgo" value that represents the number of bars ago that you want the value to be stored at.
 
 
 
 
 
Checking for Valid Values
It is possible that you may use a Series<T> object but decide not to set a value for a specific bar. However, you should not try to access a Series<T>value that has not been set. Internally, a dummy value does exists, but you want to check to see if it was a valid value that you set before trying to access it for use in your calculations.  Please see IsValidDataPoint() more information.
 
 
 
Getting Values
You can access Series<T> object values using the syntax Series<T>[int barsAgo] where barsAgo represents the data value n (number of bars ago).
 
 
Alternatively, you can access a value at an absolute bar index using the GetValueAt() method.
 
 
 
Methods that Accept ISeries<T> as Arguments
All indicator methods accept ISeries<double> objects as arguments. Carrying from the prior examples, let's print out the 10 period simple moving average of range.
 
Release Date
July 11, 2016
 
Code Breaking Changes
Compile Errors
•The NinjaScript Strategy "AccountSize" concept was removed due to limited functionality.  This change would also impact strategies which were coded to use SetOrderQuantity.ByAccountSize.  Please use your own variables to set quantities by account size. Tip:  NinjaTrader 8 can read real-world account values for live trading purposes through the Account class, e.g., Account.Get(AccountItem.CashValue, Currency.UsDollar) provides a method for returning a double value representing the current cash value of the account.
 
Implementation changes
•The concept used to force plot series objects through ForcePlotsMaximumBarsLookBackInfinite was disabled and tagged as obsolete.  You should set any indicator/strategy plots to MaximumBarsLookBack.Infinite during its construction.
•It is recommended that any strategies generated with the 'Strategy Builder' tool via Control Center > New > Strategy Builder be removed and recreated after installing B12. If you had invested significant effort in a Strategy Builder generated strategy in B11 which you would like to continue to use, please contact us platformsupport@ninjatrader.com
 
Notes
Definition
Indicates if the specified input is set at a barsAgo value relative to the current bar.  Please also see the Reset() method for more information.
 
 
 
Method Return Value
A bool value, when true indicates that specified data point is set; otherwise false.
 
Syntax
IsValidDataPoint(int barsAgo)
ISeries<T>.IsValidDataPoint(int barsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Draws a region on a chart.
 
Method Return Value
A Region object that represents the draw object.
 
Syntax
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series, double price, Brush areaBrush, int areaOpacity, int displacement = 0)
Draw.Region(NinjaScriptBase owner, string tag, int startBarsAgo,
        int endBarsAgo, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush,
        Brush areaBrush, int areaOpacity, [int displacement])
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series, double price, Brush areaBrush, int areaOpacity)
Draw.Region(NinjaScriptBase owner, string tag, DateTime startTime,
        DateTime endTime, ISeries<double> series1, ISeries<double> series2, Brush outlineBrush, Brush areaBrush, int areaOpacity)
 
Parameters
 
 
Example
 
 
When coding an indicator or strategy it is important to be able to access the intended bars for correct calculations. In NinjaScript we are able to access the bars we want through proper use of the bar's indexing.
 
The bar's indexing is setup in a reverse chronological order. This means "0" refers to the most recent bar, "1" refers to the previous bar, "2" refers to the bar before that one, etc.
 
For example, if we wanted to subtract the high and low of 10 bars ago from each other we would do this:
 
Now that we know how the indexing works there are several properties and methods at our disposal that can help us access important keystone bars. The more important ones are CurrentBar and BarsSinceNewTradingDay.
 
CurrentBar
CurrentBar returns an int representing the number of bars existing on the chart. This property is most useful when you want to run calculations from the very beginning of the chart.
 
For example, if you wanted to find the average high value of the first 10 bars on the chart you could do this:
 
 
BarsSinceNewTradingDay
BarsSinceNewTradingDay is another property that can help you find the first bar of the current trading day. The difference between BarsSinceNewTradingDay and CurrentBar is that BarsSinceNewTradingDay resets its count whenever a new session begins. This means if you use it in an index it will only get you to the beginning of the current session and not any previous sessions.
 
For example, if you wanted to find the open of the current session you could do this:
 
The example used in the discussion about CurrentBar can also be done with Bars.BarsSinceNewTradingDay if you wanted to calculate values based on the current session instead of the start of the chart too.
 
 
Other Properties and Methods
There are also a number of other properties and methods that can be useful in helping you locate the correct bars index to reference. Please take a look at these in the help guide:
BarsSinceEntryExecution()
BarsSinceExitExecution()
GetBar()
GetDayBar()
HighestBar()
LowestBar()
LRO()
MRO()
Definition
Returns the number of bars that have elapsed since the last specified entry.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous entry does not exist.
 
Syntax
BarsSinceEntryExecution()
BarsSinceEntryExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceEntryExecution(int barsInProgressIndex, string signalName, int entryExecutionsAgo)
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars that have elapsed since the last specified exit.
 
Method Return Value
An int value that represents a number of bars. A value of -1 will be returned if a previous exit does not exist.
 
Syntax
BarsSinceExitExecution()
BarsSinceExitExecution(string signalName)
 
The following method signature should be used when working with multi-time frame and instrument strategies:
 
BarsSinceExitExecution(int barsInProgressIndex, string signalName, int exitExecutionsAgo)
 
 
 
Parameters
 
 
 
 
Examples
Definition
Returns the first bar that matches the time stamp of the "time" parameter provided.  
 
 
 
Method Return Value
An int value representing an absolute bar index value.
 
Syntax
Bars.GetBar(DateTime time)
 
Parameters
 
 
Examples
Definition
Returns a virtual historical Bar object that represents a trading day whose properties for open, high, low, close, time and volume can be accessed.
 
 
 
Method Return Value
A virtual bar object representing the current configured session. Otherwise null if there is insufficient intraday data
 
Syntax
The properties below return double values:
Bars.GetDayBar(int tradingDaysBack).Open
Bars.GetDayBar(int tradingDaysBack).High
Bars.GetDayBar(int tradingDaysBack).Low
Bars.GetDayBar(int tradingDaysBack).Close
 
The property below returns a DateTime structure:
Bars.GetDayBar(int tradingDaysBack).Time
 
The property below returns an int value:
Bars.GetDayBar(int tradingDaysBack).Volume
 
 
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the highest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
HighestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago the lowest price value occurred within the specified look-back period.
 
Method Return Value
An int value representing a value of bars ago.
 
Syntax
LowestBar(ISeries<double> series, int period)
 
Parameters
 
 
Examples
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars. The LRO() method start from the furthest bar away and works toward the current bar.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
LRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Most Recent Occurrence(MRO)
Definition
Returns the number of bars ago that the test condition evaluated to true within the specified look back period expressed in bars.  The MRO() method starts from the current bar works away (backward) from it.
 
 
 
Method Return Value
An int value representing the number of bars ago. Returns a value of -1 if the specified test condition did not evaluate to true within the look-back period.
 
Syntax
MRO(Func<bool> condition, int instance, int lookBackPeriod)
 
 
 
Parameters
 
 
 
 
Examples
 
 
See Also
Least Recent Occurrence(LRO)


