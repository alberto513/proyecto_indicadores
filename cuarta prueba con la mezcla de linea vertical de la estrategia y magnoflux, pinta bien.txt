using System;
using System.Windows.Media;
using System.Collections.Generic;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.Data;

namespace NinjaTrader.NinjaScript.Indicators
{
    public class MagnoFluxScalperIndicator : Indicator
    {
        // Parámetros optimizados y estables
        [NinjaScriptProperty] public int CooldownBars { get; set; } = 1;
        [NinjaScriptProperty] public int MinConditions { get; set; } = 3;
        [NinjaScriptProperty] public double VolumeThreshold { get; set; } = 1.3;
        [NinjaScriptProperty] public int SpeedTicks { get; set; } = 18;
        [NinjaScriptProperty] public double BodyContextRatio { get; set; } = 0.4;
        [NinjaScriptProperty] public double SlopeMin { get; set; } = 0.035;
        [NinjaScriptProperty] public string SessionStart { get; set; } = "10:30";
        [NinjaScriptProperty] public string SessionEnd { get; set; } = "13:00";
        [NinjaScriptProperty] public int StopLossTicks { get; set; } = 36;
        [NinjaScriptProperty] public int ProfitTargetTicks { get; set; } = 30;

        // --- v5 parameters ---
        [NinjaScriptProperty]
        public bool EnableV5Logic { get; set; } = true;

        [NinjaScriptProperty]
        public double MinHertzToAllowTrade { get; set; } = 0.01;

        [NinjaScriptProperty]
        public bool RequireBreakoutBar { get; set; } = false;

        [NinjaScriptProperty]
        public bool EnableMarketOpenFilter { get; set; } = false;

        [NinjaScriptProperty]
        public string NoTradeZoneStart { get; set; } = "00:00";

        [NinjaScriptProperty]
        public string NoTradeZoneEnd { get; set; } = "00:00";

        [NinjaScriptProperty]
        public bool BlockWeakShorts { get; set; } = true;

        private int lastSignalBar = -1000;
        private TimeSpan sessionStart;
        private TimeSpan sessionEnd;

        // --- v5 variables ---
        private int lastSignalBar_v5 = -1000;
        private List<DateTime> signalTimes_v5 = new List<DateTime>();
        private ATR atr;
        private SMA atrAvg;
        private SMA volSma;
        private double currentHz;

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name             = "MagnoFluxScalperIndicator";
                Calculate        = Calculate.OnBarClose;
                IsOverlay        = true;
                DisplayInDataBox = false;
                AddPlot(Brushes.Transparent, "SignalDir");
            }
            else if (State == State.Configure)
            {
                sessionStart = TimeSpan.Parse(SessionStart);
                sessionEnd   = TimeSpan.Parse(SessionEnd);
            }
            else if (State == State.DataLoaded)
            {
                atr = ATR(14);
                atrAvg = SMA(atr, 14);
                volSma = SMA(Volume, 14);
            }
        }

        protected override void OnBarUpdate()
        {
            Values[0][0] = 0;

            if (CurrentBar < 20 || CurrentBar <= lastSignalBar + CooldownBars)
                return;

            var now = Time[0].TimeOfDay;
            if (now < sessionStart || now > sessionEnd)
                return;

            // 1) Filtros comunes
            double avgVol    = SMA(Volume, 10)[0];
            bool volSpike    = Volume[0] > avgVol * VolumeThreshold;
            double fastMove  = Math.Abs(Close[0] - Close[2]) / TickSize;
            bool speedOk     = fastMove >= SpeedTicks;
            double bodySize  = Math.Abs(Close[0] - Open[0]);
            bool contextOk   = bodySize > (High[0] - Low[0]) * BodyContextRatio;
            int passCount = (volSpike ? 1 : 0) + (speedOk ? 1 : 0) + (contextOk ? 1 : 0);

            // 2) Pendiente EMA(14)
            double slope   = (EMA(14)[0] - EMA(14)[3]) / (3 * TickSize);
            bool upTrend   = slope > SlopeMin;
            bool downTrend = slope < -SlopeMin;

            // 3) Señal LONG
            if (upTrend && passCount >= MinConditions && Close[0] > Open[0])
            {
                Print($"{Time[0]:HH:mm:ss} - Signal LONG | TP: {ProfitTargetTicks} ticks | SL: {StopLossTicks} ticks");
                Draw.ArrowUp(this, "mfscalpLong_" + CurrentBar, true, 0, Low[0] - TickSize, Brushes.Lime);
                Draw.VerticalLine(this,
                                  "vlLong_" + CurrentBar,
                                  0,
                                  Brushes.LimeGreen);
                lastSignalBar = CurrentBar;
                Values[0][0] = 1;
            }
            // 4) Señal SHORT

            else if (downTrend && passCount >= MinConditions && Close[0] < Open[0])
            {
                Print($"{Time[0]:HH:mm:ss} - Signal SHORT | TP: {ProfitTargetTicks} ticks | SL: {StopLossTicks} ticks");
                Draw.ArrowDown(this, "mfscalpShort_" + CurrentBar, true, 0, High[0] + TickSize, Brushes.Red);
                Draw.VerticalLine(this,
                                  "vlShort_" + CurrentBar,
                                  0,
                                  Brushes.IndianRed);
                lastSignalBar = CurrentBar;
                Values[0][0] = -1;
            }

            // --- v5 institutional logic (begin) ---
            if (EnableV5Logic && CurrentBar > lastSignalBar_v5)
            {
                UpdateHz_v5();

                if (currentHz >= MinHertzToAllowTrade && !DetectTrapCandle())
                {
                    var tNow = Time[0].TimeOfDay;
                    if (EnableMarketOpenFilter)
                    {
                        TimeSpan s = new TimeSpan(9, 29, 0);
                        TimeSpan e = new TimeSpan(9, 36, 0);
                        if (tNow >= s && tNow <= e)
                            goto end_v5;
                    }

                    if (NoTradeZoneStart != "00:00" || NoTradeZoneEnd != "00:00")
                    {
                        try
                        {
                            TimeSpan ns = TimeSpan.Parse(NoTradeZoneStart);
                            TimeSpan ne = TimeSpan.Parse(NoTradeZoneEnd);
                            if (ns < ne && tNow >= ns && tNow <= ne)
                                goto end_v5;
                        }
                        catch { }
                    }

                    int scoreL = GetInstitutionalScore(true);
                    int scoreS = GetInstitutionalScore(false);

                    bool v5Long  = scoreL >= 4 && IsLongSignal();
                    bool v5Short = scoreS >= 4 && (BlockWeakShorts ? IsShortInstitutional() : IsShortSignal());

                    if (v5Long)
                    {
                        Draw.ArrowUp(this, "v5Long_" + CurrentBar, true, 0, Low[0] - 2 * TickSize, Brushes.LimeGreen);
                        Draw.VerticalLine(this,
                                          "vlV5Long_" + CurrentBar,
                                          0,
                                          Brushes.ForestGreen);
                        Values[0][0] = 1;
                        lastSignalBar_v5 = CurrentBar;
                    }
                    else if (v5Short)
                    {
                        Draw.ArrowDown(this, "v5Short_" + CurrentBar, true, 0, High[0] + 2 * TickSize, Brushes.Red);
                        Draw.VerticalLine(this,
                                          "vlV5Short_" + CurrentBar,
                                          0,
                                          Brushes.Firebrick);
                        Values[0][0] = -1;
                        lastSignalBar_v5 = CurrentBar;
                    }
                }
            }
        end_v5: ;
            // --- v5 institutional logic (end) ---
        }

        private void UpdateHz_v5()
        {
            signalTimes_v5.Add(Time[0]);
            while (signalTimes_v5.Count > 30)
                signalTimes_v5.RemoveAt(0);
            if (signalTimes_v5.Count > 1)
            {
                double seconds = (signalTimes_v5[signalTimes_v5.Count - 1] - signalTimes_v5[0]).TotalSeconds;
                if (seconds > 0)
                    currentHz = (signalTimes_v5.Count - 1) / seconds;
            }
        }

        private int GetInstitutionalScore(bool isLong)
        {
            int score = 0;
            double body = Math.Abs(Close[0] - Open[0]);
            double range = High[0] - Low[0];
            bool breakout = isLong ? Close[0] > High[1] : Close[0] < Low[1];

            if (Volume[0] > volSma[0] * 1.5)
                score++;
            if (range > 0 && body / range > 0.7)
                score++;
            if (breakout)
                score++;
            if (range > atr[0])
                score++;

            if (Volume[1] > volSma[1] * 1.5 && ((Close[1] > Open[1]) != isLong))
                score--;

            if (breakout && Volume[0] > volSma[0] * 1.5 && body / range > 0.6)
                score++;

            if ((isLong && Close[0] > High[1] && Volume[0] > volSma[0]) || (!isLong && Close[0] < Low[1] && Volume[0] > volSma[0]))
                score++;

            if (Volume[0] > volSma[0] * 1.5 && range > 0 && body / range < 0.3)
                score--;

            bool engulfOpp = isLong ? (Close[1] < Open[1] && Open[0] < Close[1] && Close[0] < Open[1])
                                     : (Close[1] > Open[1] && Open[0] > Close[1] && Close[0] > Open[1]);
            if (engulfOpp)
                score -= 2;

            if (RequireBreakoutBar && !breakout)
                score = 0;
            return score;
        }

        private bool IsLongSignal()
        {
            return Close[0] > Open[0];
        }

        private bool IsShortSignal()
        {
            return Close[0] < Open[0];
        }

        private bool IsShortInstitutional()
        {
            double body = Open[0] - Close[0];
            double range = High[0] - Low[0];
            bool volumeHigh = Volume[0] > volSma[0] * 1.5;
            bool bodyLarge = range > 0 && body / range > 0.7;
            bool pressure = Close[0] < Low[1];
            bool prevGreenTrap = Volume[1] > volSma[1] * 1.5 && Close[1] > Open[1];
            bool prevBounce = Close[1] < Open[1] && Low[0] > Low[1];

            if (!volumeHigh || !bodyLarge || !pressure)
                return false;
            if (prevGreenTrap || prevBounce)
                return false;
            return true;
        }

        private bool DetectTrapCandle()
        {
            if (CurrentBar < 2) return false;
            double body = Math.Abs(Close[1] - Open[1]);
            double prevBody = Math.Abs(Close[2] - Open[2]);
            bool trap = body > prevBody * 1.5 && Math.Sign(Close[1] - Open[1]) != Math.Sign(Close[2] - Open[2]);
            bool reversal = Volume[1] > volSma[1] * 1.5 && body / (High[1] - Low[1]) > 0.6 && Math.Sign(Close[1] - Open[1]) != Math.Sign(Close[0] - Open[0]);
            return trap || reversal;
        }
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MagnoFluxScalperIndicator[] cacheMagnoFluxScalperIndicator;
		public MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks, bool enableV5Logic, double minHertzToAllowTrade, bool requireBreakoutBar, bool enableMarketOpenFilter, string noTradeZoneStart, string noTradeZoneEnd, bool blockWeakShorts)
		{
			return MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks, enableV5Logic, minHertzToAllowTrade, requireBreakoutBar, enableMarketOpenFilter, noTradeZoneStart, noTradeZoneEnd, blockWeakShorts);
		}

		public MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input, int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks, bool enableV5Logic, double minHertzToAllowTrade, bool requireBreakoutBar, bool enableMarketOpenFilter, string noTradeZoneStart, string noTradeZoneEnd, bool blockWeakShorts)
		{
			if (cacheMagnoFluxScalperIndicator != null)
				for (int idx = 0; idx < cacheMagnoFluxScalperIndicator.Length; idx++)
					if (cacheMagnoFluxScalperIndicator[idx] != null && cacheMagnoFluxScalperIndicator[idx].CooldownBars == cooldownBars && cacheMagnoFluxScalperIndicator[idx].MinConditions == minConditions && cacheMagnoFluxScalperIndicator[idx].VolumeThreshold == volumeThreshold && cacheMagnoFluxScalperIndicator[idx].SpeedTicks == speedTicks && cacheMagnoFluxScalperIndicator[idx].BodyContextRatio == bodyContextRatio && cacheMagnoFluxScalperIndicator[idx].SlopeMin == slopeMin && cacheMagnoFluxScalperIndicator[idx].SessionStart == sessionStart && cacheMagnoFluxScalperIndicator[idx].SessionEnd == sessionEnd && cacheMagnoFluxScalperIndicator[idx].StopLossTicks == stopLossTicks && cacheMagnoFluxScalperIndicator[idx].ProfitTargetTicks == profitTargetTicks && cacheMagnoFluxScalperIndicator[idx].EnableV5Logic == enableV5Logic && cacheMagnoFluxScalperIndicator[idx].MinHertzToAllowTrade == minHertzToAllowTrade && cacheMagnoFluxScalperIndicator[idx].RequireBreakoutBar == requireBreakoutBar && cacheMagnoFluxScalperIndicator[idx].EnableMarketOpenFilter == enableMarketOpenFilter && cacheMagnoFluxScalperIndicator[idx].NoTradeZoneStart == noTradeZoneStart && cacheMagnoFluxScalperIndicator[idx].NoTradeZoneEnd == noTradeZoneEnd && cacheMagnoFluxScalperIndicator[idx].BlockWeakShorts == blockWeakShorts && cacheMagnoFluxScalperIndicator[idx].EqualsInput(input))
						return cacheMagnoFluxScalperIndicator[idx];
			return CacheIndicator<MagnoFluxScalperIndicator>(new MagnoFluxScalperIndicator(){ CooldownBars = cooldownBars, MinConditions = minConditions, VolumeThreshold = volumeThreshold, SpeedTicks = speedTicks, BodyContextRatio = bodyContextRatio, SlopeMin = slopeMin, SessionStart = sessionStart, SessionEnd = sessionEnd, StopLossTicks = stopLossTicks, ProfitTargetTicks = profitTargetTicks, EnableV5Logic = enableV5Logic, MinHertzToAllowTrade = minHertzToAllowTrade, RequireBreakoutBar = requireBreakoutBar, EnableMarketOpenFilter = enableMarketOpenFilter, NoTradeZoneStart = noTradeZoneStart, NoTradeZoneEnd = noTradeZoneEnd, BlockWeakShorts = blockWeakShorts }, input, ref cacheMagnoFluxScalperIndicator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks, bool enableV5Logic, double minHertzToAllowTrade, bool requireBreakoutBar, bool enableMarketOpenFilter, string noTradeZoneStart, string noTradeZoneEnd, bool blockWeakShorts)
		{
			return indicator.MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks, enableV5Logic, minHertzToAllowTrade, requireBreakoutBar, enableMarketOpenFilter, noTradeZoneStart, noTradeZoneEnd, blockWeakShorts);
		}

		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input , int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks, bool enableV5Logic, double minHertzToAllowTrade, bool requireBreakoutBar, bool enableMarketOpenFilter, string noTradeZoneStart, string noTradeZoneEnd, bool blockWeakShorts)
		{
			return indicator.MagnoFluxScalperIndicator(input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks, enableV5Logic, minHertzToAllowTrade, requireBreakoutBar, enableMarketOpenFilter, noTradeZoneStart, noTradeZoneEnd, blockWeakShorts);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks, bool enableV5Logic, double minHertzToAllowTrade, bool requireBreakoutBar, bool enableMarketOpenFilter, string noTradeZoneStart, string noTradeZoneEnd, bool blockWeakShorts)
		{
			return indicator.MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks, enableV5Logic, minHertzToAllowTrade, requireBreakoutBar, enableMarketOpenFilter, noTradeZoneStart, noTradeZoneEnd, blockWeakShorts);
		}

		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input , int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks, bool enableV5Logic, double minHertzToAllowTrade, bool requireBreakoutBar, bool enableMarketOpenFilter, string noTradeZoneStart, string noTradeZoneEnd, bool blockWeakShorts)
		{
			return indicator.MagnoFluxScalperIndicator(input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks, enableV5Logic, minHertzToAllowTrade, requireBreakoutBar, enableMarketOpenFilter, noTradeZoneStart, noTradeZoneEnd, blockWeakShorts);
		}
	}
}

#endregion
