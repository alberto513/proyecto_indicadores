using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Xml.Serialization;
using System.ComponentModel.DataAnnotations;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.Cbi;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
using System.Windows.Media;

// SharpDX para el panel dibujado en OnRender
using SharpDX;
using D2D = SharpDX.Direct2D1;
using DW  = SharpDX.DirectWrite;

namespace NinjaTrader.NinjaScript.Indicators
{
    public enum PanelCornerKind { TopLeft = 0, TopRight = 1, BottomLeft = 2, BottomRight = 3 }
    // === MOVIDO AL NIVEL DE NAMESPACE (para evitar CS0246 en otros archivos) ===
    public enum BarColoringMode { Off = 0, BiasVsEMA = 1, SignalsOnly = 2 }

    // AumentoV4 final version + panel OnRender (sin PanelBounds) + PARCHE MÍNIMO (Reset + BarColoring)
    public class AumentoV4_1 : Indicator
    {
        #region Parameters
        [NinjaScriptProperty]
        [Range(0,10)]
        [Display(Name="Strictness", Order=0, GroupName="Parameters")]
        public double Strictness { get; set; }

        [NinjaScriptProperty]
        [Display(Name="OverrideSlopeMinEMANorm", Order=10, GroupName="Strictness Overrides")]
        public bool OverrideSlopeMinEMANorm { get; set; }

        [NinjaScriptProperty]
        [Display(Name="OverrideVolSpikeZ", Order=11, GroupName="Strictness Overrides")]
        public bool OverrideVolSpikeZ { get; set; }

        [NinjaScriptProperty]
        [Display(Name="OverrideMinScoreToTrade", Order=12, GroupName="Strictness Overrides")]
        public bool OverrideMinScoreToTrade { get; set; }

        [NinjaScriptProperty]
        [Display(Name="OverrideEMADistMinATR", Order=13, GroupName="Strictness Overrides")]
        public bool OverrideEMADistMinATR { get; set; }

        [NinjaScriptProperty]
        [Display(Name="OverrideEMADistMaxATR", Order=14, GroupName="Strictness Overrides")]
        public bool OverrideEMADistMaxATR { get; set; }

        [NinjaScriptProperty]
        [Display(Name="OverrideATR14vs100Min", Order=15, GroupName="Strictness Overrides")]
        public bool OverrideATR14vs100Min { get; set; }

        [NinjaScriptProperty]
        [Display(Name="OverrideConsolidationRangeBoxes", Order=16, GroupName="Strictness Overrides")]
        public bool OverrideConsolidationRangeBoxes { get; set; }

        // Scoring
        [NinjaScriptProperty]
        [Display(Name="BiasEMA", Order=20, GroupName="Scoring")]
        public int BiasEMA { get; set; }

        [NinjaScriptProperty]
        [Display(Name="BiasSlopeMin", Order=21, GroupName="Scoring")]
        public double BiasSlopeMin { get; set; }

        [NinjaScriptProperty]
        [Display(Name="SlopeMinEMANorm", Order=22, GroupName="Scoring")]
        public double SlopeMinEMANorm { get; set; }

        [NinjaScriptProperty]
        [Display(Name="VolSpikeLookback", Order=23, GroupName="Scoring")]
        public int VolSpikeLookback { get; set; }

        [NinjaScriptProperty]
        [Display(Name="VolSpikeZ", Order=24, GroupName="Scoring")]
        public double VolSpikeZ { get; set; }

        [NinjaScriptProperty]
        [Display(Name="EMADistMinATR", Order=25, GroupName="Scoring")]
        public double EMADistMinATR { get; set; }

        [NinjaScriptProperty]
        [Display(Name="EMADistMaxATR", Order=26, GroupName="Scoring")]
        public double EMADistMaxATR { get; set; }

        [NinjaScriptProperty]
        [Display(Name="BodyContextRatio", Order=27, GroupName="Scoring")]
        public double BodyContextRatio { get; set; }

        [NinjaScriptProperty]
        [Display(Name="MaxOppWickRatio", Order=28, GroupName="Scoring")]
        public double MaxOppWickRatio { get; set; }

        [NinjaScriptProperty]
        [Display(Name="MinScoreToTrade", Order=29, GroupName="Scoring")]
        public int MinScoreToTrade { get; set; }

        [NinjaScriptProperty]
        [Display(Name="wBias", Order=30, GroupName="Weights")]
        public double wBias { get; set; }

        [NinjaScriptProperty]
        [Display(Name="wSlope", Order=31, GroupName="Weights")]
        public double wSlope { get; set; }

        [NinjaScriptProperty]
        [Display(Name="wVol", Order=32, GroupName="Weights")]
        public double wVol { get; set; }

        [NinjaScriptProperty]
        [Display(Name="wDist", Order=33, GroupName="Weights")]
        public double wDist { get; set; }

        [NinjaScriptProperty]
        [Display(Name="wPattern", Order=34, GroupName="Weights")]
        public double wPattern { get; set; }

        // Risk
        [NinjaScriptProperty]
        [Display(Name="UseRR", Order=40, GroupName="Risk")]
        public bool UseRR { get; set; }

        [NinjaScriptProperty]
        [Display(Name="SignalPoints", Order=41, GroupName="Risk")]
        public int SignalPoints { get; set; }

        [NinjaScriptProperty]
        [Display(Name="BaseTicks", Order=42, GroupName="Risk")]
        public int BaseTicks { get; set; }

        [NinjaScriptProperty]
        [Display(Name="R", Order=43, GroupName="Risk")]
        public double R { get; set; }

        [NinjaScriptProperty]
        [Display(Name="BreakEvenTicks", Order=44, GroupName="Risk")]
        public int BreakEvenTicks { get; set; }

        [NinjaScriptProperty]
        [Display(Name="BETriggerTicks", Order=45, GroupName="Risk")]
        public int BETriggerTicks { get; set; }

        [NinjaScriptProperty]
        [Display(Name="BEOffset", Order=46, GroupName="Risk")]
        public int BEOffset { get; set; }

        [NinjaScriptProperty]
        [Display(Name="TrailATRMult", Order=47, GroupName="Risk")]
        public double TrailATRMult { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ConservativeTieBreak", Order=48, GroupName="Risk")]
        public bool ConservativeTieBreak { get; set; }

        // Cluster/pacing
        [NinjaScriptProperty]
        [Display(Name="AllowOverlapSignals", Order=60, GroupName="Cluster/Pacing")]
        public bool AllowOverlapSignals { get; set; }

        [NinjaScriptProperty]
        [Display(Name="MaxConcurrentSignals", Order=61, GroupName="Cluster/Pacing")]
        public int MaxConcurrentSignals { get; set; }

        [NinjaScriptProperty]
        [Display(Name="MinBarsBetweenSignals", Order=62, GroupName="Cluster/Pacing")]
        public int MinBarsBetweenSignals { get; set; }

        [NinjaScriptProperty]
        [Display(Name="CooldownBars", Order=63, GroupName="Cluster/Pacing")]
        public int CooldownBars { get; set; }

        [NinjaScriptProperty]
        [Display(Name="CooldownMinutes", Order=64, GroupName="Cluster/Pacing")]
        public int CooldownMinutes { get; set; }

        [NinjaScriptProperty]
        [Display(Name="TargetSignalsPerHour", Order=65, GroupName="Cluster/Pacing")]
        public double TargetSignalsPerHour { get; set; }

        [NinjaScriptProperty]
        [Display(Name="MinScoreFloor", Order=66, GroupName="Cluster/Pacing")]
        public int MinScoreFloor { get; set; }

        [NinjaScriptProperty]
        [Display(Name="MinScoreCeil", Order=67, GroupName="Cluster/Pacing")]
        public int MinScoreCeil { get; set; }

        [NinjaScriptProperty]
        [Display(Name="VolSpikeZFloor", Order=68, GroupName="Cluster/Pacing")]
        public double VolSpikeZFloor { get; set; }

        [NinjaScriptProperty]
        [Display(Name="VolSpikeZCeil", Order=69, GroupName="Cluster/Pacing")]
        public double VolSpikeZCeil { get; set; }

        // Regimes and time filters
        [NinjaScriptProperty]
        [Display(Name="ATR14vs100Min", Order=70, GroupName="Regimes")]
        public double ATR14vs100Min { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ConsolidationBars", Order=71, GroupName="Regimes")]
        public int ConsolidationBars { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ConsolidationRangeBoxes", Order=72, GroupName="Regimes")]
        public int ConsolidationRangeBoxes { get; set; }

        [NinjaScriptProperty]
        [Display(Name="UseHigherTF", Order=73, GroupName="Regimes")]
        public bool UseHigherTF { get; set; }

        [NinjaScriptProperty]
        [Display(Name="HTFMultiplier", Order=74, GroupName="Regimes")]
        public int HTFMultiplier { get; set; }

        [NinjaScriptProperty]
        [Display(Name="UseHourSideFilters", Order=80, GroupName="Time Filters")]
        public bool UseHourSideFilters { get; set; }

        [NinjaScriptProperty]
        [Display(Name="LongOnlyHoursCsv", Order=81, GroupName="Time Filters")]
        public string LongOnlyHoursCsv { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ShortOnlyHoursCsv", Order=82, GroupName="Time Filters")]
        public string ShortOnlyHoursCsv { get; set; }

        [NinjaScriptProperty]
        [Display(Name="BlockWindowsCsv", Order=83, GroupName="Time Filters")]
        public string BlockWindowsCsv { get; set; }

        // UI / Log
        [NinjaScriptProperty]
        [Display(Name="ShowStatsPanel", Order=90, GroupName="UI/Log")]
        public bool ShowStatsPanel { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ProfileName", Order=91, GroupName="UI/Log")]
        public string ProfileName { get; set; }

        [XmlIgnore]
        [Display(Name="ProfileColor", Order=92, GroupName="UI/Log")]
        public System.Windows.Media.Brush ProfileColor { get; set; } = Brushes.LimeGreen;

        [Browsable(false)]
        public string ProfileColorSerialize
        {
            get { return Serialize.BrushToString(ProfileColor); }
            set { ProfileColor = Serialize.StringToBrush(value); }
        }

        [NinjaScriptProperty]
        [Display(Name="ShowDrawObjects", Order=93, GroupName="UI/Log")]
        public bool ShowDrawObjects { get; set; }

        [NinjaScriptProperty]
        [Display(Name="MaxSignalsToDraw", Order=94, GroupName="UI/Log")]
        public int MaxSignalsToDraw { get; set; }

        [NinjaScriptProperty]
        [Display(Name="RunQuickScan", Order=95, GroupName="QuickScan")]
        public bool RunQuickScan { get; set; }

        [NinjaScriptProperty]
        [Display(Name="QuickScanDays", Order=96, GroupName="QuickScan")]
        public int QuickScanDays { get; set; }

        [NinjaScriptProperty]
        [Display(Name="QuickScanMaxBars", Order=97, GroupName="QuickScan")]
        public int QuickScanMaxBars { get; set; }

        [NinjaScriptProperty]
        [Display(Name="UseShortTime", Order=98, GroupName="UI/Log")]
        public bool UseShortTime { get; set; }

        [NinjaScriptProperty]
        [Display(Name="UseDecimalComma", Order=99, GroupName="UI/Log")]
        public bool UseDecimalComma { get; set; }

        [NinjaScriptProperty]
        [Display(Name="PanelCorner", Order=100, GroupName="UI/Log")]
        public PanelCornerKind PanelCorner { get; set; }

        [NinjaScriptProperty]
        [Display(Name="PanelMargin", Order=101, GroupName="UI/Log")]
        public int PanelMargin { get; set; }

        [NinjaScriptProperty]
        [Range(0.0,1.0)]
        [Display(Name="PanelBgOpacity", Order=102, GroupName="UI/Log")]
        public double PanelBgOpacity { get; set; }

        // === NUEVO: UI/Log ===
        [NinjaScriptProperty]
        [Display(Name="ResetStatsAtSession", Order=103, GroupName="UI/Log")]
        public bool ResetStatsAtSession { get; set; }

        [NinjaScriptProperty]
        [Display(Name="ResetNow", Order=104, GroupName="UI/Log")]
        public bool ResetNow { get; set; }

        // === NUEVO: Visual ===
        [NinjaScriptProperty]
        [Display(Name="BarColoring", Order=201, GroupName="Visual")]
        public BarColoringMode BarColoring { get; set; }
        #endregion

        #region Internal
        private EMA ema34;
        private EMA ema14;
        private ATR atr14;
        private ATR atr100;
        private EMA htfEma34;
        private SMA volSMA;
        private StdDev volStd;
        private Series<double> volSeries;

        private List<int> longHours = new List<int>();
        private List<int> shortHours = new List<int>();
        private List<Tuple<TimeSpan, TimeSpan>> blockWindows = new List<Tuple<TimeSpan, TimeSpan>>();

        private struct Trade
        {
            public int EntryBar;
            public double EntryPrice;
            public double TpPrice;
            public double SlPrice;
            public double Score;
            public double ScoreBias;
            public double ScoreSlope;
            public double ScoreVol;
            public double ScoreDist;
            public double ScorePattern;
            public string Side;
            public bool BreakEvenDone;
            public bool Active;
            public DateTime EntryTime;
        }
        private struct PendingSignal
        {
            public int SignalBar;
            public string Side;
            public double Score;
            public double ScoreBias;
            public double ScoreSlope;
            public double ScoreVol;
            public double ScoreDist;
            public double ScorePattern;
            public DateTime SignalTime;
        }
        private List<PendingSignal> pending = new List<PendingSignal>();
        private List<Trade> openTrades = new List<Trade>();
        private int lastSignalBar = -1000;
        private DateTime lastSignalTime = Core.Globals.MinDate;
        private int drawnSignals;

        private int trades;
        private int wins;
        private int losses;
        private double pnlTicks;
        private string lastClosedSide = string.Empty;
        private double lastClosedScore;

        private int qsTrades;
        private int qsWins;
        private double qsPnlTicks;
        private bool quickScanDone;

        private string csvPath;
        private double lastStrictness = double.NaN;

        private string panelTextCached = string.Empty;

        // === NUEVO ===
        private DateTime statsStart = Core.Globals.MinDate;
        #endregion

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "AumentoV4_1";
                Calculate = Calculate.OnBarClose;
                IsOverlay = true;

                // Preconfig conservadora (WR alto)
                Strictness = 6;
                BiasEMA = 34;
                BiasSlopeMin = 0.015;
                SlopeMinEMANorm = 0.26;
                VolSpikeLookback = 20;
                VolSpikeZ = 1.7;
                EMADistMinATR = 0.15;
                EMADistMaxATR = 1.45;
                BodyContextRatio = 0.35;
                MaxOppWickRatio = 0.30;
                MinScoreToTrade = 8;
                wBias = wSlope = wVol = wDist = wPattern = 1.0;

                UseRR = false;
                SignalPoints = 25;
                BaseTicks = 25;
                R = 1.0;
                BreakEvenTicks = 0;
                BETriggerTicks = 0;
                BEOffset = 0;
                TrailATRMult = 0.0;
                ConservativeTieBreak = true;

                AllowOverlapSignals = false;
                MaxConcurrentSignals = 1;
                MinBarsBetweenSignals = 2;
                CooldownBars = 0;
                CooldownMinutes = 0;
                TargetSignalsPerHour = 0;
                MinScoreFloor = MinScoreToTrade;
                MinScoreCeil = MinScoreToTrade;
                VolSpikeZFloor = VolSpikeZ;
                VolSpikeZCeil = VolSpikeZ;

                ATR14vs100Min = 0.90;
                ConsolidationBars = 12;
                ConsolidationRangeBoxes = 4;
                UseHigherTF = false;
                HTFMultiplier = 4;

                UseHourSideFilters = true;
                LongOnlyHoursCsv = "10,11,14,15";
                ShortOnlyHoursCsv = "10,11,14,15";
                BlockWindowsCsv = "09:30-09:45;12:00-13:00";

                ShowStatsPanel = true;
                ProfileName = "S70";
                ShowDrawObjects = true;
                MaxSignalsToDraw = 200;

                RunQuickScan = false;
                QuickScanDays = 10;
                QuickScanMaxBars = 0;

                UseShortTime = true;
                UseDecimalComma = false;

                PanelCorner = PanelCornerKind.TopLeft;
                PanelMargin = 8;
                PanelBgOpacity = 0.55;

                // === NUEVO defaults ===
                ResetStatsAtSession = true;         // auto reset al inicio de sesión
                ResetNow = false;                   // botón manual
                BarColoring = BarColoringMode.Off;  // color de barras
            }
            else if (State == State.Configure)
            {
                if (UseHigherTF)
                {
                    try { AddDataSeries(BarsPeriod.BarsPeriodType, BarsPeriod.Value * HTFMultiplier); }
                    catch { /* algunos tipos no soportan AddDataSeries */ }
                }
            }
            else if (State == State.DataLoaded)
            {
                ema34 = EMA(BiasEMA);
                ema14 = EMA(14);
                atr14 = ATR(14);
                atr100 = ATR(100);
                volSeries = new Series<double>(this);
                volSMA = SMA(volSeries, VolSpikeLookback);
                volStd = StdDev(volSeries, VolSpikeLookback);
                if (UseHigherTF && BarsArray.Length > 1)
                    htfEma34 = EMA(BarsArray[1], 34);

                ParseHourCsv(LongOnlyHoursCsv, longHours);
                ParseHourCsv(ShortOnlyHoursCsv, shortHours);
                ParseBlockWindows(BlockWindowsCsv);

                csvPath = Path.Combine(Core.Globals.UserDataDir, $"AumentoV4_{ProfileName}.csv");
                ApplyStrictness();
                lastStrictness = Strictness;

                // === NUEVO ===
                statsStart = Core.Globals.MinDate;
            }
        }

        private void ParseHourCsv(string csv, List<int> list)
        {
            list.Clear();
            foreach (var part in csv.Split(new[]{','}, StringSplitOptions.RemoveEmptyEntries))
                if (int.TryParse(part.Trim(), out int hr))
                    list.Add(hr);
        }

        private void ParseBlockWindows(string csv)
        {
            blockWindows.Clear();
            foreach (var w in csv.Split(new[]{';'}, StringSplitOptions.RemoveEmptyEntries))
            {
                var p = w.Split('-');
                if (p.Length != 2) continue;
                if (TimeSpan.TryParse(p[0], out var a) && TimeSpan.TryParse(p[1], out var b))
                    blockWindows.Add(new Tuple<TimeSpan,TimeSpan>(a,b));
            }
        }

        private double Lerp(double a, double b, double t) => a + (b - a) * t;

        private void ApplyStrictness()
        {
            double s = Strictness;
            double t = s / 10.0;
            if (!OverrideSlopeMinEMANorm) SlopeMinEMANorm = Lerp(0.16, 0.30, t);
            if (!OverrideVolSpikeZ) VolSpikeZ = Lerp(1.2, 1.9, t);
            if (!OverrideMinScoreToTrade) MinScoreToTrade = (int)Math.Round(Lerp(5, 10, t));
            if (!OverrideEMADistMinATR) EMADistMinATR = Lerp(0.10, 0.20, t);
            if (!OverrideEMADistMaxATR) EMADistMaxATR = Lerp(1.60, 1.30, t);
            if (!OverrideATR14vs100Min) ATR14vs100Min = Lerp(0.80, 1.00, t);
            if (!OverrideConsolidationRangeBoxes) ConsolidationRangeBoxes = (int)Math.Round(Lerp(3, 5, t));
        }

        private void ResetStats()
        {
            trades = wins = losses = 0;
            pnlTicks = 0;
            qsTrades = qsWins = 0;
            qsPnlTicks = 0;
            lastClosedSide = string.Empty;
            lastClosedScore = 0;
            openTrades.Clear();
            pending.Clear();
            drawnSignals = 0;
            statsStart = Time[0];
            panelTextCached = string.Empty;
        }

        protected override void OnBarUpdate()
        {
            int warm = Math.Max(100, Math.Max(ConsolidationBars + 6, VolSpikeLookback + 6));
            if (CurrentBar < warm)
            {
                if (BarsInProgress == 0)
                    volSeries[0] = Volume[0];
                return;
            }

            if (BarsInProgress != 0)
                return;

            // === NUEVO: Resets ===
            // Reset manual (botón)
            if (ResetNow)
            {
                ResetStats();
                ResetNow = false;   // evitar reseteos repetidos
            }

            // Reset automático al inicio de sesión (cuando ya hay datos suficientes)
            if (ResetStatsAtSession && Bars.IsFirstBarOfSession && CurrentBar > warm)
            {
                ResetStats();
            }
            // === FIN NUEVO ===

            if (pending.Count > 0)
            {
                for (int i = pending.Count - 1; i >= 0; i--)
                {
                    var ps = pending[i];
                    if (CurrentBar <= ps.SignalBar)
                        continue;

                    double entry = Open[0];
                    double tp, sl;
                    if (UseRR)
                    {
                        sl = ps.Side=="LONG" ? entry - TickSize*BaseTicks : entry + TickSize*BaseTicks;
                        tp = ps.Side=="LONG" ? entry + TickSize*BaseTicks*R : entry - TickSize*BaseTicks*R;
                    }
                    else
                    {
                        tp = ps.Side=="LONG" ? entry + TickSize*SignalPoints : entry - TickSize*SignalPoints;
                        sl = ps.Side=="LONG" ? entry - TickSize*SignalPoints : entry + TickSize*SignalPoints;
                    }
                    var t = new Trade
                    {
                        EntryBar = CurrentBar,
                        EntryPrice = entry,
                        TpPrice = tp,
                        SlPrice = sl,
                        Score = ps.Score,
                        ScoreBias = ps.ScoreBias,
                        ScoreSlope = ps.ScoreSlope,
                        ScoreVol = ps.ScoreVol,
                        ScoreDist = ps.ScoreDist,
                        ScorePattern = ps.ScorePattern,
                        Side = ps.Side,
                        BreakEvenDone = false,
                        Active = true,
                        EntryTime = Time[0]
                    };
                    openTrades.Add(t);
                    pending.RemoveAt(i);
                }
            }

            if (Math.Abs(atr14[0]) < 1e-9)
            {
                ManageOpenTrades();
                UpdatePanel();
                return;
            }

            if (double.IsNaN(lastStrictness) || Math.Abs(Strictness - lastStrictness) > 1e-9)
            {
                ApplyStrictness();
                lastStrictness = Strictness;
            }

            volSeries[0] = Volume[0];

            // === NUEVO: Bar coloring por sesgo con EMA ===
            if (BarColoring == BarColoringMode.BiasVsEMA)
            {
                var b = (Close[0] >= ema34[0]) ? Brushes.LimeGreen : Brushes.IndianRed;
                BarBrushes[0] = b;
                CandleOutlineBrushes[0] = b;
            }
            // === FIN NUEVO ===

            if (RunQuickScan && !quickScanDone && State == State.Historical)
                PerformQuickScan();

            if (!IsWithinTimeFilters() || !AtrRegimeOk() || InConsolidation())
            {
                ManageOpenTrades();
                UpdatePanel();
                return;
            }

            bool htfOk = true;
            if (UseHigherTF && BarsArray.Length > 1)
            {
                if (CurrentBars[1] < 50) { ManageOpenTrades(); UpdatePanel(); return; }
                double htf = htfEma34[0];
                htfOk = (Close[0] > ema34[0]) ? Close[0] > htf : Close[0] < htf;
            }
            if (!htfOk) { ManageOpenTrades(); UpdatePanel(); return; }

            double bias = Close[0] - ema34[0];
            double biasSlope = (ema34[0] - ema34[5])/(5*atr14[0]);
            double slope = (ema14[0] - ema14[5])/(5*atr14[0]);
            double volZ = (volStd[0] > 1e-9) ? (volSeries[0]-volSMA[0])/volStd[0] : 0.0;
            double distEma = Math.Abs(Close[0] - ema34[0])/atr14[0];
            double body = Math.Abs(Close[0] - Open[0]);
            double candleRange = High[0] - Low[0];
            double context = 0.0;
            double oppWickRatio = 0.0;
            if (Math.Abs(candleRange) > 1e-9)
            {
                context = body / candleRange;
                if (bias >= 0)
                    oppWickRatio = (High[0] - Math.Max(Open[0], Close[0])) / candleRange;
                else
                    oppWickRatio = (Math.Min(Open[0], Close[0]) - Low[0]) / candleRange;
            }

            double scoreBiasLong = 0, scoreBiasShort = 0;
            double scoreSlopeLong = 0, scoreSlopeShort = 0;
            double scoreVol = 0, scoreVolShort = 0;
            double scoreDist = 0, scoreDistShort = 0;
            double scorePatternLong = 0, scorePatternShort = 0;

            if (Close[0] > ema34[0] && biasSlope > BiasSlopeMin)
                scoreBiasLong = 2*wBias;
            if (Close[0] < ema34[0] && biasSlope < -BiasSlopeMin)
                scoreBiasShort = 2*wBias;

            if (slope > SlopeMinEMANorm)
                scoreSlopeLong = 2*wSlope;
            if (slope < -SlopeMinEMANorm)
                scoreSlopeShort = 2*wSlope;

            if (volZ > VolSpikeZ)
            {
                scoreVol = 2*wVol;
                scoreVolShort = 2*wVol;
            }

            if (distEma >= EMADistMinATR && distEma <= EMADistMaxATR)
            {
                scoreDist = 2*wDist;
                scoreDistShort = 2*wDist;
            }

            if (context >= BodyContextRatio && oppWickRatio <= MaxOppWickRatio)
            {
                scorePatternLong = 2*wPattern;
            }
            if (context >= BodyContextRatio && oppWickRatio <= MaxOppWickRatio)
            {
                scorePatternShort = 2*wPattern;
            }

            double scoreLong = scoreBiasLong + scoreSlopeLong + scoreVol + scoreDist + scorePatternLong;
            double scoreShort = scoreBiasShort + scoreSlopeShort + scoreVol + scoreDist + scorePatternShort;

            if (scoreLong >= MinScoreToTrade && scoreLong >= scoreShort && bias > 0)
                ProcessSignal("LONG", scoreLong, scoreBiasLong, scoreSlopeLong, scoreVol, scoreDist, scorePatternLong);
            else if (scoreShort >= MinScoreToTrade && scoreShort > scoreLong && bias < 0)
                ProcessSignal("SHORT", scoreShort, scoreBiasShort, scoreSlopeShort, scoreVolShort, scoreDistShort, scorePatternShort);

            ManageOpenTrades();
            UpdatePanel();

            // Fallback: texto anclado por si no se pudiera renderizar el panel
            if (ShowStatsPanel && !string.IsNullOrEmpty(panelTextCached))
            {
                double y = Instrument.MasterInstrument.RoundToTickSize(MAX(High, 20)[0] + 10 * TickSize);
                Draw.Text(this, "AumV4Panel" + ProfileName, panelTextCached, 0, y, Brushes.White);
            }
        }

        private bool IsWithinTimeFilters()
        {
            DateTime t = Time[0];
            if (UseHourSideFilters)
            {
                if (Close[0] > ema34[0] && longHours.Count>0 && !longHours.Contains(t.Hour))
                    return false;
                if (Close[0] < ema34[0] && shortHours.Count>0 && !shortHours.Contains(t.Hour))
                    return false;
            }
            foreach (var w in blockWindows)
            {
                TimeSpan ts = t.TimeOfDay;
                if (ts >= w.Item1 && ts <= w.Item2)
                    return false;
            }
            return true;
        }

        private bool AtrRegimeOk() => atr14[0] >= ATR14vs100Min * atr100[0];

        private bool InConsolidation()
        {
            if (CurrentBar < ConsolidationBars + 1)
                return false;

            double hh = MAX(High, ConsolidationBars)[1];
            double ll = MIN(Low, ConsolidationBars)[1];
            double range = hh - ll;

            if (BarsPeriod.BarsPeriodType == BarsPeriodType.Renko || BarsPeriod.BarsPeriodType == BarsPeriodType.LineBreak)
            {
                double boxSize = BarsPeriod.Value * Instrument.MasterInstrument.TickSize;
                return range <= boxSize * ConsolidationRangeBoxes;
            }
            return range <= 0.25 * atr14[0];
        }

        private bool HasOpen(string side) => openTrades.Any(x => x.Active && x.Side == side);
        private bool HasOppositeOpen(string side) => openTrades.Any(x => x.Active && x.Side != side);

        private void ProcessSignal(string dir, double totalScore, double sBias, double sSlope, double sVol, double sDist, double sPattern)
        {
            if (CurrentBar - lastSignalBar < MinBarsBetweenSignals)
                return;
            if (CooldownMinutes > 0 && Time[0] - lastSignalTime < TimeSpan.FromMinutes(CooldownMinutes))
                return;
            if (!AllowOverlapSignals)
            {
                if (HasOppositeOpen(dir))
                    return;
                if (openTrades.Count >= MaxConcurrentSignals)
                    return;
            }

            lastSignalBar = CurrentBar;
            lastSignalTime = Time[0];

            pending.Add(new PendingSignal
            {
                SignalBar = CurrentBar,
                Side = dir,
                Score = totalScore,
                ScoreBias = sBias,
                ScoreSlope = sSlope,
                ScoreVol = sVol,
                ScoreDist = sDist,
                ScorePattern = sPattern,
                SignalTime = Time[0]
            });

            // === NUEVO: colorear solo la barra de la señal ===
            if (BarColoring == BarColoringMode.SignalsOnly)
            {
                var b = (dir == "LONG") ? Brushes.LimeGreen : Brushes.IndianRed;
                BarBrushes[0] = b;
                CandleOutlineBrushes[0] = b;
            }
            // === FIN NUEVO ===

            if (ShowDrawObjects && drawnSignals < MaxSignalsToDraw)
            {
                drawnSignals++;
                string tag = $"AumV4_{ProfileName}_{CurrentBar}";
                if (dir=="LONG")
                    NinjaTrader.NinjaScript.DrawingTools.Draw.ArrowUp(this, tag, false, 0, Low[0]-2*TickSize, ProfileColor);
                else
                    NinjaTrader.NinjaScript.DrawingTools.Draw.ArrowDown(this, tag, false, 0, High[0]+2*TickSize, ProfileColor);
                NinjaTrader.NinjaScript.DrawingTools.Draw.VerticalLine(this, tag+"_v", 0, ProfileColor);
            }
        }

        private void ManageOpenTrades()
        {
            for (int i=openTrades.Count-1;i>=0;i--)
            {
                Trade t = openTrades[i];
                if (!t.Active) { openTrades.RemoveAt(i); continue; }
                if (CurrentBar == t.EntryBar) { openTrades[i] = t; continue; }

                bool hitTp = false, hitSl = false;
                double high = High[0];
                double low = Low[0];
                if (t.Side=="LONG")
                {
                    hitTp = high >= t.TpPrice;
                    hitSl = low <= t.SlPrice;
                }
                else
                {
                    hitTp = low <= t.TpPrice;
                    hitSl = high >= t.SlPrice;
                }

                if (hitTp && hitSl)
                {
                    if (ConservativeTieBreak)
                    {
                        hitTp = false; hitSl = true;
                    }
                    else
                    {
                        double dTp = Math.Abs(t.TpPrice - t.EntryPrice);
                        double dSl = Math.Abs(t.EntryPrice - t.SlPrice);
                        if (dSl < dTp) { hitTp = false; hitSl = true; }
                        else { hitTp = true; hitSl = false; }
                    }
                }

                if (!t.BreakEvenDone && BreakEvenTicks > 0)
                {
                    double trigger = t.Side=="LONG" ? t.EntryPrice + TickSize*BETriggerTicks : t.EntryPrice - TickSize*BETriggerTicks;
                    if ((t.Side=="LONG" && high>=trigger) || (t.Side=="SHORT" && low<=trigger))
                    {
                        t.SlPrice = t.EntryPrice + (t.Side=="LONG" ? TickSize*BEOffset : -TickSize*BEOffset);
                        t.BreakEvenDone = true;
                    }
                }

                if (TrailATRMult > 0)
                {
                    double trail = atr14[0]*TrailATRMult;
                    if (t.Side=="LONG")
                        t.SlPrice = Math.Max(t.SlPrice, Close[0]-trail);
                    else
                        t.SlPrice = Math.Min(t.SlPrice, Close[0]+trail);
                }

                if (hitTp || hitSl)
                {
                    double exit = hitTp ? t.TpPrice : t.SlPrice;
                    double pnl = t.Side=="LONG" ? (exit - t.EntryPrice)/TickSize : (t.EntryPrice - exit)/TickSize;
                    pnlTicks += pnl;
                    trades++;
                    if (pnl>0) wins++; else losses++;
                    lastClosedSide = t.Side;
                    lastClosedScore = t.Score;
                    WriteCsv(t, pnl);
                    t.Active=false;
                    openTrades[i]=t;
                    openTrades.RemoveAt(i);
                    continue;
                }

                openTrades[i]=t;
            }
        }

        private void WriteCsv(Trade t, double pnlTicksTrade)
        {
            try
            {
                bool fileExists = File.Exists(csvPath);
                using (var sw = new StreamWriter(csvPath, true))
                {
                    if (!fileExists)
                        sw.WriteLine("Time,Instrument,Profile,Strictness,Entry,TP,SL,Result,DurationMin,Bars,Side,ScoreTotal,ScoreBias,ScoreSlope,ScoreVol,ScoreDist,ScorePattern");
                    string result = pnlTicksTrade>0?"TP":(pnlTicksTrade<0?"SL":"BE");
                    double dur = (Time[0]-t.EntryTime).TotalMinutes;
                    var ci = UseDecimalComma ? new CultureInfo("es-ES") : CultureInfo.InvariantCulture;
                    string ts = UseShortTime ? Time[0].ToString("HH:mm:ss") : Time[0].ToString("o");
                    sw.WriteLine(string.Format(ci,
                        "{0},{1},{2},{3},{4},{5},{6},{7},{8},{9},{10},{11},{12},{13},{14},{15},{16}",
                        ts, Instrument.FullName, ProfileName, Strictness, t.EntryPrice, t.TpPrice, t.SlPrice, result, dur,
                        CurrentBar - t.EntryBar, t.Side, t.Score, t.ScoreBias, t.ScoreSlope, t.ScoreVol, t.ScoreDist, t.ScorePattern));
                }
            }
            catch { }
        }

        private void UpdatePanel()
        {
            if (!ShowStatsPanel) { panelTextCached = string.Empty; return; }

            double wr = trades > 0 ? 100.0 * wins / Math.Max(1, trades) : 0.0;
            double rentab = (trades > 0 && SignalPoints > 0) ? 100.0 * pnlTicks / (SignalPoints * trades) : 0.0;

            string line1 = string.Format("{0} | Trades:{1} Wins:{2} Losses:{3} WR:{4:F1}% PnL:{5:F0} Rentab:{6:F1}% Open:{7}",
                ProfileName, trades, wins, losses, wr, pnlTicks, rentab, openTrades.Count);

            // === NUEVO (opcional): mostrar desde cuándo cuenta ===
            if (statsStart != Core.Globals.MinDate)
                line1 = string.Format("[desde {0:HH:mm}] ", statsStart) + line1;
            // === FIN NUEVO ===

            string line2 = string.Empty;
            if (!string.IsNullOrEmpty(lastClosedSide))
                line2 = string.Format("Last: {0} | Score={1:F1}", lastClosedSide, lastClosedScore);

            string line3 = string.Empty;
            if (quickScanDone)
            {
                double qswr = qsTrades > 0 ? 100.0 * qsWins / Math.Max(1, qsTrades) : 0.0;
                double qsr  = (qsTrades > 0 && SignalPoints > 0) ? 100.0 * qsPnlTicks / (SignalPoints * qsTrades) : 0.0;
                line3 = string.Format("QS: Trades:{0} WR:{1:F1}% PnL:{2:F0} Rentab:{3:F1}%", qsTrades, qswr, qsPnlTicks, qsr);
            }

            panelTextCached = string.IsNullOrEmpty(line2)
                ? (string.IsNullOrEmpty(line3) ? line1 : (line1 + "\n" + line3))
                : (string.IsNullOrEmpty(line3) ? (line1 + "\n" + line2) : (line1 + "\n" + line2 + "\n" + line3));
        }

        private void PerformQuickScan()
        {
            quickScanDone = true;
            int barsBack = Math.Min(QuickScanMaxBars>0?QuickScanMaxBars:Bars.Count, Bars.Count);

            if (Bars.Count < Math.Max(VolSpikeLookback, 20) + 10)
                return;

            DateTime start = Time[0].AddDays(-QuickScanDays);
            for (int idx = barsBack-1; idx>=0; idx--)
            {
                if (Time[idx] < start) break;
                if (idx + 5 >= barsBack || idx - 1 < 0 || idx + VolSpikeLookback >= barsBack) continue;

                double bias = Close[idx] - ema34[idx];
                double biasSlope = (ema34[idx] - ema34[idx+5])/(5*atr14[idx]);
                double slope = (ema14[idx] - ema14[idx+5])/(5*atr14[idx]);
                double volZ = (volStd[idx] > 1e-9) ? (volSeries[idx]-volSMA[idx])/volStd[idx] : 0.0;
                double distEma = Math.Abs(Close[idx]-ema34[idx])/atr14[idx];
                double body = Math.Abs(Close[idx]-Open[idx]);
                double candleRange = High[idx]-Low[idx];
                double context=0, oppWickLong=0, oppWickShort=0;
                if (Math.Abs(candleRange) > 1e-9)
                {
                    context = body/candleRange;
                    oppWickLong = (High[idx]-Math.Max(Open[idx], Close[idx]))/candleRange;
                    oppWickShort = (Math.Min(Open[idx], Close[idx])-Low[idx])/candleRange;
                }

                double scoreBiasLong = 0, scoreBiasShort = 0;
                double scoreSlopeLong = 0, scoreSlopeShort = 0;
                double scoreVol = 0;
                double scoreDist = 0;
                double scorePatternLong = 0, scorePatternShort = 0;

                if (Close[idx] > ema34[idx] && biasSlope > BiasSlopeMin) scoreBiasLong = 2*wBias;
                if (Close[idx] < ema34[idx] && biasSlope < -BiasSlopeMin) scoreBiasShort = 2*wBias;
                if (slope > SlopeMinEMANorm) scoreSlopeLong = 2*wSlope;
                if (slope < -SlopeMinEMANorm) scoreSlopeShort = 2*wSlope;
                if (volZ > VolSpikeZ) scoreVol = 2*wVol;
                if (distEma >= EMADistMinATR && distEma <= EMADistMaxATR) scoreDist = 2*wDist;
                if (context >= BodyContextRatio && oppWickLong <= MaxOppWickRatio) scorePatternLong = 2*wPattern;
                if (context >= BodyContextRatio && oppWickShort <= MaxOppWickRatio) scorePatternShort = 2*wPattern;

                double scoreLong = scoreBiasLong + scoreSlopeLong + scoreVol + scoreDist + scorePatternLong;
                double scoreShort = scoreBiasShort + scoreSlopeShort + scoreVol + scoreDist + scorePatternShort;

                if (scoreLong >= MinScoreToTrade && scoreLong >= scoreShort && bias > 0)
                    SimulateQuickScanTrade(idx, "LONG");
                else if (scoreShort >= MinScoreToTrade && scoreShort > scoreLong && bias < 0)
                    SimulateQuickScanTrade(idx, "SHORT");
            }
        }

        private void SimulateQuickScanTrade(int idx, string side)
        {
            double entry = Open[idx-1];
            double tp, sl;
            if (UseRR)
            {
                sl = side=="LONG" ? entry - TickSize*BaseTicks : entry + TickSize*BaseTicks;
                tp = side=="LONG" ? entry + TickSize*BaseTicks*R : entry - TickSize*BaseTicks*R;
            }
            else
            {
                tp = side=="LONG" ? entry + TickSize*SignalPoints : entry - TickSize*SignalPoints;
                sl = side=="LONG" ? entry - TickSize*SignalPoints : entry + TickSize*SignalPoints;
            }
            for (int k = idx-1; k >= 0; k--)
            {
                double high = High[k];
                double low = Low[k];
                bool hitTp = side=="LONG" ? high >= tp : low <= tp;
                bool hitSl = side=="LONG" ? low <= sl : high >= sl;
                if (hitTp && hitSl)
                {
                    if (ConservativeTieBreak)
                        hitTp = false;
                    else
                    {
                        double dTp = Math.Abs(tp - entry);
                        double dSl = Math.Abs(entry - sl);
                        if (dSl < dTp) hitTp = false; else hitSl = false;
                    }
                }
                if (hitTp || hitSl)
                {
                    qsTrades++;
                    double reward = Math.Abs(tp - entry)/TickSize;
                    if (hitTp) { qsWins++; qsPnlTicks += reward; }
                    else { qsPnlTicks -= reward; }
                    break;
                }
            }
        }

        // Panel fijo por OnRender (sin ChartControl.PanelBounds)
        protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
        {
            base.OnRender(chartControl, chartScale);
            if (!ShowStatsPanel || RenderTarget == null) return;
            if (string.IsNullOrWhiteSpace(panelTextCached)) return;

            // Usar siempre ChartPanel.W / ChartPanel.H; si no hay panel, salir.
            var panel = ChartPanel;
            if (panel == null) return;
            float panelW = (float)panel.W;
            float panelH = (float)panel.H;

            D2D.RenderTarget rt = RenderTarget;
            var dw = Core.Globals.DirectWriteFactory;

            using (var tf = new DW.TextFormat(dw, "Segoe UI", 12))
            using (var tl = new DW.TextLayout(dw, panelTextCached, tf, panelW, panelH))
            {
                float margin = Math.Max(0, PanelMargin);
                float tw = tl.Metrics.Width + 12f;
                float th = tl.Metrics.Height + 8f;

                float x, y;
                switch (PanelCorner)
                {
                    case PanelCornerKind.TopRight:
                        x = panelW - tw - margin; y = margin; break;
                    case PanelCornerKind.BottomLeft:
                        x = margin; y = panelH - th - margin; break;
                    case PanelCornerKind.BottomRight:
                        x = panelW - tw - margin; y = panelH - th - margin; break;
                    default: // TopLeft
                        x = margin; y = margin; break;
                }

                var wpf = (ProfileColor as SolidColorBrush)?.Color ?? Colors.DimGray;
                var bgc = new Color4(wpf.R / 255f, wpf.G / 255f, wpf.B / 255f, (float)Math.Min(1.0, Math.Max(0.0, PanelBgOpacity)));
                var fgc = new Color4(1f, 1f, 1f, 1f);

                using (var bg = new D2D.SolidColorBrush(rt, bgc))
                using (var fg = new D2D.SolidColorBrush(rt, fgc))
                {
                    var rect = new SharpDX.RectangleF(x, y, tw, th);
                    rt.FillRectangle(rect, bg);
                    rt.DrawTextLayout(new Vector2(x + 6f, y + 4f), tl, fg);
                }
            }
        }
    }
}


#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private AumentoV4_1[] cacheAumentoV4_1;
		public AumentoV4_1 AumentoV4_1(double strictness, bool overrideSlopeMinEMANorm, bool overrideVolSpikeZ, bool overrideMinScoreToTrade, bool overrideEMADistMinATR, bool overrideEMADistMaxATR, bool overrideATR14vs100Min, bool overrideConsolidationRangeBoxes, int biasEMA, double biasSlopeMin, double slopeMinEMANorm, int volSpikeLookback, double volSpikeZ, double eMADistMinATR, double eMADistMaxATR, double bodyContextRatio, double maxOppWickRatio, int minScoreToTrade, double wBias, double wSlope, double wVol, double wDist, double wPattern, bool useRR, int signalPoints, int baseTicks, double r, int breakEvenTicks, int bETriggerTicks, int bEOffset, double trailATRMult, bool conservativeTieBreak, bool allowOverlapSignals, int maxConcurrentSignals, int minBarsBetweenSignals, int cooldownBars, int cooldownMinutes, double targetSignalsPerHour, int minScoreFloor, int minScoreCeil, double volSpikeZFloor, double volSpikeZCeil, double aTR14vs100Min, int consolidationBars, int consolidationRangeBoxes, bool useHigherTF, int hTFMultiplier, bool useHourSideFilters, string longOnlyHoursCsv, string shortOnlyHoursCsv, string blockWindowsCsv, bool showStatsPanel, string profileName, bool showDrawObjects, int maxSignalsToDraw, bool runQuickScan, int quickScanDays, int quickScanMaxBars, bool useShortTime, bool useDecimalComma, PanelCornerKind panelCorner, int panelMargin, double panelBgOpacity, bool resetStatsAtSession, bool resetNow, BarColoringMode barColoring)
		{
			return AumentoV4_1(Input, strictness, overrideSlopeMinEMANorm, overrideVolSpikeZ, overrideMinScoreToTrade, overrideEMADistMinATR, overrideEMADistMaxATR, overrideATR14vs100Min, overrideConsolidationRangeBoxes, biasEMA, biasSlopeMin, slopeMinEMANorm, volSpikeLookback, volSpikeZ, eMADistMinATR, eMADistMaxATR, bodyContextRatio, maxOppWickRatio, minScoreToTrade, wBias, wSlope, wVol, wDist, wPattern, useRR, signalPoints, baseTicks, r, breakEvenTicks, bETriggerTicks, bEOffset, trailATRMult, conservativeTieBreak, allowOverlapSignals, maxConcurrentSignals, minBarsBetweenSignals, cooldownBars, cooldownMinutes, targetSignalsPerHour, minScoreFloor, minScoreCeil, volSpikeZFloor, volSpikeZCeil, aTR14vs100Min, consolidationBars, consolidationRangeBoxes, useHigherTF, hTFMultiplier, useHourSideFilters, longOnlyHoursCsv, shortOnlyHoursCsv, blockWindowsCsv, showStatsPanel, profileName, showDrawObjects, maxSignalsToDraw, runQuickScan, quickScanDays, quickScanMaxBars, useShortTime, useDecimalComma, panelCorner, panelMargin, panelBgOpacity, resetStatsAtSession, resetNow, barColoring);
		}

		public AumentoV4_1 AumentoV4_1(ISeries<double> input, double strictness, bool overrideSlopeMinEMANorm, bool overrideVolSpikeZ, bool overrideMinScoreToTrade, bool overrideEMADistMinATR, bool overrideEMADistMaxATR, bool overrideATR14vs100Min, bool overrideConsolidationRangeBoxes, int biasEMA, double biasSlopeMin, double slopeMinEMANorm, int volSpikeLookback, double volSpikeZ, double eMADistMinATR, double eMADistMaxATR, double bodyContextRatio, double maxOppWickRatio, int minScoreToTrade, double wBias, double wSlope, double wVol, double wDist, double wPattern, bool useRR, int signalPoints, int baseTicks, double r, int breakEvenTicks, int bETriggerTicks, int bEOffset, double trailATRMult, bool conservativeTieBreak, bool allowOverlapSignals, int maxConcurrentSignals, int minBarsBetweenSignals, int cooldownBars, int cooldownMinutes, double targetSignalsPerHour, int minScoreFloor, int minScoreCeil, double volSpikeZFloor, double volSpikeZCeil, double aTR14vs100Min, int consolidationBars, int consolidationRangeBoxes, bool useHigherTF, int hTFMultiplier, bool useHourSideFilters, string longOnlyHoursCsv, string shortOnlyHoursCsv, string blockWindowsCsv, bool showStatsPanel, string profileName, bool showDrawObjects, int maxSignalsToDraw, bool runQuickScan, int quickScanDays, int quickScanMaxBars, bool useShortTime, bool useDecimalComma, PanelCornerKind panelCorner, int panelMargin, double panelBgOpacity, bool resetStatsAtSession, bool resetNow, BarColoringMode barColoring)
		{
			if (cacheAumentoV4_1 != null)
				for (int idx = 0; idx < cacheAumentoV4_1.Length; idx++)
					if (cacheAumentoV4_1[idx] != null && cacheAumentoV4_1[idx].Strictness == strictness && cacheAumentoV4_1[idx].OverrideSlopeMinEMANorm == overrideSlopeMinEMANorm && cacheAumentoV4_1[idx].OverrideVolSpikeZ == overrideVolSpikeZ && cacheAumentoV4_1[idx].OverrideMinScoreToTrade == overrideMinScoreToTrade && cacheAumentoV4_1[idx].OverrideEMADistMinATR == overrideEMADistMinATR && cacheAumentoV4_1[idx].OverrideEMADistMaxATR == overrideEMADistMaxATR && cacheAumentoV4_1[idx].OverrideATR14vs100Min == overrideATR14vs100Min && cacheAumentoV4_1[idx].OverrideConsolidationRangeBoxes == overrideConsolidationRangeBoxes && cacheAumentoV4_1[idx].BiasEMA == biasEMA && cacheAumentoV4_1[idx].BiasSlopeMin == biasSlopeMin && cacheAumentoV4_1[idx].SlopeMinEMANorm == slopeMinEMANorm && cacheAumentoV4_1[idx].VolSpikeLookback == volSpikeLookback && cacheAumentoV4_1[idx].VolSpikeZ == volSpikeZ && cacheAumentoV4_1[idx].EMADistMinATR == eMADistMinATR && cacheAumentoV4_1[idx].EMADistMaxATR == eMADistMaxATR && cacheAumentoV4_1[idx].BodyContextRatio == bodyContextRatio && cacheAumentoV4_1[idx].MaxOppWickRatio == maxOppWickRatio && cacheAumentoV4_1[idx].MinScoreToTrade == minScoreToTrade && cacheAumentoV4_1[idx].wBias == wBias && cacheAumentoV4_1[idx].wSlope == wSlope && cacheAumentoV4_1[idx].wVol == wVol && cacheAumentoV4_1[idx].wDist == wDist && cacheAumentoV4_1[idx].wPattern == wPattern && cacheAumentoV4_1[idx].UseRR == useRR && cacheAumentoV4_1[idx].SignalPoints == signalPoints && cacheAumentoV4_1[idx].BaseTicks == baseTicks && cacheAumentoV4_1[idx].R == r && cacheAumentoV4_1[idx].BreakEvenTicks == breakEvenTicks && cacheAumentoV4_1[idx].BETriggerTicks == bETriggerTicks && cacheAumentoV4_1[idx].BEOffset == bEOffset && cacheAumentoV4_1[idx].TrailATRMult == trailATRMult && cacheAumentoV4_1[idx].ConservativeTieBreak == conservativeTieBreak && cacheAumentoV4_1[idx].AllowOverlapSignals == allowOverlapSignals && cacheAumentoV4_1[idx].MaxConcurrentSignals == maxConcurrentSignals && cacheAumentoV4_1[idx].MinBarsBetweenSignals == minBarsBetweenSignals && cacheAumentoV4_1[idx].CooldownBars == cooldownBars && cacheAumentoV4_1[idx].CooldownMinutes == cooldownMinutes && cacheAumentoV4_1[idx].TargetSignalsPerHour == targetSignalsPerHour && cacheAumentoV4_1[idx].MinScoreFloor == minScoreFloor && cacheAumentoV4_1[idx].MinScoreCeil == minScoreCeil && cacheAumentoV4_1[idx].VolSpikeZFloor == volSpikeZFloor && cacheAumentoV4_1[idx].VolSpikeZCeil == volSpikeZCeil && cacheAumentoV4_1[idx].ATR14vs100Min == aTR14vs100Min && cacheAumentoV4_1[idx].ConsolidationBars == consolidationBars && cacheAumentoV4_1[idx].ConsolidationRangeBoxes == consolidationRangeBoxes && cacheAumentoV4_1[idx].UseHigherTF == useHigherTF && cacheAumentoV4_1[idx].HTFMultiplier == hTFMultiplier && cacheAumentoV4_1[idx].UseHourSideFilters == useHourSideFilters && cacheAumentoV4_1[idx].LongOnlyHoursCsv == longOnlyHoursCsv && cacheAumentoV4_1[idx].ShortOnlyHoursCsv == shortOnlyHoursCsv && cacheAumentoV4_1[idx].BlockWindowsCsv == blockWindowsCsv && cacheAumentoV4_1[idx].ShowStatsPanel == showStatsPanel && cacheAumentoV4_1[idx].ProfileName == profileName && cacheAumentoV4_1[idx].ShowDrawObjects == showDrawObjects && cacheAumentoV4_1[idx].MaxSignalsToDraw == maxSignalsToDraw && cacheAumentoV4_1[idx].RunQuickScan == runQuickScan && cacheAumentoV4_1[idx].QuickScanDays == quickScanDays && cacheAumentoV4_1[idx].QuickScanMaxBars == quickScanMaxBars && cacheAumentoV4_1[idx].UseShortTime == useShortTime && cacheAumentoV4_1[idx].UseDecimalComma == useDecimalComma && cacheAumentoV4_1[idx].PanelCorner == panelCorner && cacheAumentoV4_1[idx].PanelMargin == panelMargin && cacheAumentoV4_1[idx].PanelBgOpacity == panelBgOpacity && cacheAumentoV4_1[idx].ResetStatsAtSession == resetStatsAtSession && cacheAumentoV4_1[idx].ResetNow == resetNow && cacheAumentoV4_1[idx].BarColoring == barColoring && cacheAumentoV4_1[idx].EqualsInput(input))
						return cacheAumentoV4_1[idx];
			return CacheIndicator<AumentoV4_1>(new AumentoV4_1(){ Strictness = strictness, OverrideSlopeMinEMANorm = overrideSlopeMinEMANorm, OverrideVolSpikeZ = overrideVolSpikeZ, OverrideMinScoreToTrade = overrideMinScoreToTrade, OverrideEMADistMinATR = overrideEMADistMinATR, OverrideEMADistMaxATR = overrideEMADistMaxATR, OverrideATR14vs100Min = overrideATR14vs100Min, OverrideConsolidationRangeBoxes = overrideConsolidationRangeBoxes, BiasEMA = biasEMA, BiasSlopeMin = biasSlopeMin, SlopeMinEMANorm = slopeMinEMANorm, VolSpikeLookback = volSpikeLookback, VolSpikeZ = volSpikeZ, EMADistMinATR = eMADistMinATR, EMADistMaxATR = eMADistMaxATR, BodyContextRatio = bodyContextRatio, MaxOppWickRatio = maxOppWickRatio, MinScoreToTrade = minScoreToTrade, wBias = wBias, wSlope = wSlope, wVol = wVol, wDist = wDist, wPattern = wPattern, UseRR = useRR, SignalPoints = signalPoints, BaseTicks = baseTicks, R = r, BreakEvenTicks = breakEvenTicks, BETriggerTicks = bETriggerTicks, BEOffset = bEOffset, TrailATRMult = trailATRMult, ConservativeTieBreak = conservativeTieBreak, AllowOverlapSignals = allowOverlapSignals, MaxConcurrentSignals = maxConcurrentSignals, MinBarsBetweenSignals = minBarsBetweenSignals, CooldownBars = cooldownBars, CooldownMinutes = cooldownMinutes, TargetSignalsPerHour = targetSignalsPerHour, MinScoreFloor = minScoreFloor, MinScoreCeil = minScoreCeil, VolSpikeZFloor = volSpikeZFloor, VolSpikeZCeil = volSpikeZCeil, ATR14vs100Min = aTR14vs100Min, ConsolidationBars = consolidationBars, ConsolidationRangeBoxes = consolidationRangeBoxes, UseHigherTF = useHigherTF, HTFMultiplier = hTFMultiplier, UseHourSideFilters = useHourSideFilters, LongOnlyHoursCsv = longOnlyHoursCsv, ShortOnlyHoursCsv = shortOnlyHoursCsv, BlockWindowsCsv = blockWindowsCsv, ShowStatsPanel = showStatsPanel, ProfileName = profileName, ShowDrawObjects = showDrawObjects, MaxSignalsToDraw = maxSignalsToDraw, RunQuickScan = runQuickScan, QuickScanDays = quickScanDays, QuickScanMaxBars = quickScanMaxBars, UseShortTime = useShortTime, UseDecimalComma = useDecimalComma, PanelCorner = panelCorner, PanelMargin = panelMargin, PanelBgOpacity = panelBgOpacity, ResetStatsAtSession = resetStatsAtSession, ResetNow = resetNow, BarColoring = barColoring }, input, ref cacheAumentoV4_1);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.AumentoV4_1 AumentoV4_1(double strictness, bool overrideSlopeMinEMANorm, bool overrideVolSpikeZ, bool overrideMinScoreToTrade, bool overrideEMADistMinATR, bool overrideEMADistMaxATR, bool overrideATR14vs100Min, bool overrideConsolidationRangeBoxes, int biasEMA, double biasSlopeMin, double slopeMinEMANorm, int volSpikeLookback, double volSpikeZ, double eMADistMinATR, double eMADistMaxATR, double bodyContextRatio, double maxOppWickRatio, int minScoreToTrade, double wBias, double wSlope, double wVol, double wDist, double wPattern, bool useRR, int signalPoints, int baseTicks, double r, int breakEvenTicks, int bETriggerTicks, int bEOffset, double trailATRMult, bool conservativeTieBreak, bool allowOverlapSignals, int maxConcurrentSignals, int minBarsBetweenSignals, int cooldownBars, int cooldownMinutes, double targetSignalsPerHour, int minScoreFloor, int minScoreCeil, double volSpikeZFloor, double volSpikeZCeil, double aTR14vs100Min, int consolidationBars, int consolidationRangeBoxes, bool useHigherTF, int hTFMultiplier, bool useHourSideFilters, string longOnlyHoursCsv, string shortOnlyHoursCsv, string blockWindowsCsv, bool showStatsPanel, string profileName, bool showDrawObjects, int maxSignalsToDraw, bool runQuickScan, int quickScanDays, int quickScanMaxBars, bool useShortTime, bool useDecimalComma, PanelCornerKind panelCorner, int panelMargin, double panelBgOpacity, bool resetStatsAtSession, bool resetNow, BarColoringMode barColoring)
		{
			return indicator.AumentoV4_1(Input, strictness, overrideSlopeMinEMANorm, overrideVolSpikeZ, overrideMinScoreToTrade, overrideEMADistMinATR, overrideEMADistMaxATR, overrideATR14vs100Min, overrideConsolidationRangeBoxes, biasEMA, biasSlopeMin, slopeMinEMANorm, volSpikeLookback, volSpikeZ, eMADistMinATR, eMADistMaxATR, bodyContextRatio, maxOppWickRatio, minScoreToTrade, wBias, wSlope, wVol, wDist, wPattern, useRR, signalPoints, baseTicks, r, breakEvenTicks, bETriggerTicks, bEOffset, trailATRMult, conservativeTieBreak, allowOverlapSignals, maxConcurrentSignals, minBarsBetweenSignals, cooldownBars, cooldownMinutes, targetSignalsPerHour, minScoreFloor, minScoreCeil, volSpikeZFloor, volSpikeZCeil, aTR14vs100Min, consolidationBars, consolidationRangeBoxes, useHigherTF, hTFMultiplier, useHourSideFilters, longOnlyHoursCsv, shortOnlyHoursCsv, blockWindowsCsv, showStatsPanel, profileName, showDrawObjects, maxSignalsToDraw, runQuickScan, quickScanDays, quickScanMaxBars, useShortTime, useDecimalComma, panelCorner, panelMargin, panelBgOpacity, resetStatsAtSession, resetNow, barColoring);
		}

		public Indicators.AumentoV4_1 AumentoV4_1(ISeries<double> input , double strictness, bool overrideSlopeMinEMANorm, bool overrideVolSpikeZ, bool overrideMinScoreToTrade, bool overrideEMADistMinATR, bool overrideEMADistMaxATR, bool overrideATR14vs100Min, bool overrideConsolidationRangeBoxes, int biasEMA, double biasSlopeMin, double slopeMinEMANorm, int volSpikeLookback, double volSpikeZ, double eMADistMinATR, double eMADistMaxATR, double bodyContextRatio, double maxOppWickRatio, int minScoreToTrade, double wBias, double wSlope, double wVol, double wDist, double wPattern, bool useRR, int signalPoints, int baseTicks, double r, int breakEvenTicks, int bETriggerTicks, int bEOffset, double trailATRMult, bool conservativeTieBreak, bool allowOverlapSignals, int maxConcurrentSignals, int minBarsBetweenSignals, int cooldownBars, int cooldownMinutes, double targetSignalsPerHour, int minScoreFloor, int minScoreCeil, double volSpikeZFloor, double volSpikeZCeil, double aTR14vs100Min, int consolidationBars, int consolidationRangeBoxes, bool useHigherTF, int hTFMultiplier, bool useHourSideFilters, string longOnlyHoursCsv, string shortOnlyHoursCsv, string blockWindowsCsv, bool showStatsPanel, string profileName, bool showDrawObjects, int maxSignalsToDraw, bool runQuickScan, int quickScanDays, int quickScanMaxBars, bool useShortTime, bool useDecimalComma, PanelCornerKind panelCorner, int panelMargin, double panelBgOpacity, bool resetStatsAtSession, bool resetNow, BarColoringMode barColoring)
		{
			return indicator.AumentoV4_1(input, strictness, overrideSlopeMinEMANorm, overrideVolSpikeZ, overrideMinScoreToTrade, overrideEMADistMinATR, overrideEMADistMaxATR, overrideATR14vs100Min, overrideConsolidationRangeBoxes, biasEMA, biasSlopeMin, slopeMinEMANorm, volSpikeLookback, volSpikeZ, eMADistMinATR, eMADistMaxATR, bodyContextRatio, maxOppWickRatio, minScoreToTrade, wBias, wSlope, wVol, wDist, wPattern, useRR, signalPoints, baseTicks, r, breakEvenTicks, bETriggerTicks, bEOffset, trailATRMult, conservativeTieBreak, allowOverlapSignals, maxConcurrentSignals, minBarsBetweenSignals, cooldownBars, cooldownMinutes, targetSignalsPerHour, minScoreFloor, minScoreCeil, volSpikeZFloor, volSpikeZCeil, aTR14vs100Min, consolidationBars, consolidationRangeBoxes, useHigherTF, hTFMultiplier, useHourSideFilters, longOnlyHoursCsv, shortOnlyHoursCsv, blockWindowsCsv, showStatsPanel, profileName, showDrawObjects, maxSignalsToDraw, runQuickScan, quickScanDays, quickScanMaxBars, useShortTime, useDecimalComma, panelCorner, panelMargin, panelBgOpacity, resetStatsAtSession, resetNow, barColoring);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.AumentoV4_1 AumentoV4_1(double strictness, bool overrideSlopeMinEMANorm, bool overrideVolSpikeZ, bool overrideMinScoreToTrade, bool overrideEMADistMinATR, bool overrideEMADistMaxATR, bool overrideATR14vs100Min, bool overrideConsolidationRangeBoxes, int biasEMA, double biasSlopeMin, double slopeMinEMANorm, int volSpikeLookback, double volSpikeZ, double eMADistMinATR, double eMADistMaxATR, double bodyContextRatio, double maxOppWickRatio, int minScoreToTrade, double wBias, double wSlope, double wVol, double wDist, double wPattern, bool useRR, int signalPoints, int baseTicks, double r, int breakEvenTicks, int bETriggerTicks, int bEOffset, double trailATRMult, bool conservativeTieBreak, bool allowOverlapSignals, int maxConcurrentSignals, int minBarsBetweenSignals, int cooldownBars, int cooldownMinutes, double targetSignalsPerHour, int minScoreFloor, int minScoreCeil, double volSpikeZFloor, double volSpikeZCeil, double aTR14vs100Min, int consolidationBars, int consolidationRangeBoxes, bool useHigherTF, int hTFMultiplier, bool useHourSideFilters, string longOnlyHoursCsv, string shortOnlyHoursCsv, string blockWindowsCsv, bool showStatsPanel, string profileName, bool showDrawObjects, int maxSignalsToDraw, bool runQuickScan, int quickScanDays, int quickScanMaxBars, bool useShortTime, bool useDecimalComma, PanelCornerKind panelCorner, int panelMargin, double panelBgOpacity, bool resetStatsAtSession, bool resetNow, BarColoringMode barColoring)
		{
			return indicator.AumentoV4_1(Input, strictness, overrideSlopeMinEMANorm, overrideVolSpikeZ, overrideMinScoreToTrade, overrideEMADistMinATR, overrideEMADistMaxATR, overrideATR14vs100Min, overrideConsolidationRangeBoxes, biasEMA, biasSlopeMin, slopeMinEMANorm, volSpikeLookback, volSpikeZ, eMADistMinATR, eMADistMaxATR, bodyContextRatio, maxOppWickRatio, minScoreToTrade, wBias, wSlope, wVol, wDist, wPattern, useRR, signalPoints, baseTicks, r, breakEvenTicks, bETriggerTicks, bEOffset, trailATRMult, conservativeTieBreak, allowOverlapSignals, maxConcurrentSignals, minBarsBetweenSignals, cooldownBars, cooldownMinutes, targetSignalsPerHour, minScoreFloor, minScoreCeil, volSpikeZFloor, volSpikeZCeil, aTR14vs100Min, consolidationBars, consolidationRangeBoxes, useHigherTF, hTFMultiplier, useHourSideFilters, longOnlyHoursCsv, shortOnlyHoursCsv, blockWindowsCsv, showStatsPanel, profileName, showDrawObjects, maxSignalsToDraw, runQuickScan, quickScanDays, quickScanMaxBars, useShortTime, useDecimalComma, panelCorner, panelMargin, panelBgOpacity, resetStatsAtSession, resetNow, barColoring);
		}

		public Indicators.AumentoV4_1 AumentoV4_1(ISeries<double> input , double strictness, bool overrideSlopeMinEMANorm, bool overrideVolSpikeZ, bool overrideMinScoreToTrade, bool overrideEMADistMinATR, bool overrideEMADistMaxATR, bool overrideATR14vs100Min, bool overrideConsolidationRangeBoxes, int biasEMA, double biasSlopeMin, double slopeMinEMANorm, int volSpikeLookback, double volSpikeZ, double eMADistMinATR, double eMADistMaxATR, double bodyContextRatio, double maxOppWickRatio, int minScoreToTrade, double wBias, double wSlope, double wVol, double wDist, double wPattern, bool useRR, int signalPoints, int baseTicks, double r, int breakEvenTicks, int bETriggerTicks, int bEOffset, double trailATRMult, bool conservativeTieBreak, bool allowOverlapSignals, int maxConcurrentSignals, int minBarsBetweenSignals, int cooldownBars, int cooldownMinutes, double targetSignalsPerHour, int minScoreFloor, int minScoreCeil, double volSpikeZFloor, double volSpikeZCeil, double aTR14vs100Min, int consolidationBars, int consolidationRangeBoxes, bool useHigherTF, int hTFMultiplier, bool useHourSideFilters, string longOnlyHoursCsv, string shortOnlyHoursCsv, string blockWindowsCsv, bool showStatsPanel, string profileName, bool showDrawObjects, int maxSignalsToDraw, bool runQuickScan, int quickScanDays, int quickScanMaxBars, bool useShortTime, bool useDecimalComma, PanelCornerKind panelCorner, int panelMargin, double panelBgOpacity, bool resetStatsAtSession, bool resetNow, BarColoringMode barColoring)
		{
			return indicator.AumentoV4_1(input, strictness, overrideSlopeMinEMANorm, overrideVolSpikeZ, overrideMinScoreToTrade, overrideEMADistMinATR, overrideEMADistMaxATR, overrideATR14vs100Min, overrideConsolidationRangeBoxes, biasEMA, biasSlopeMin, slopeMinEMANorm, volSpikeLookback, volSpikeZ, eMADistMinATR, eMADistMaxATR, bodyContextRatio, maxOppWickRatio, minScoreToTrade, wBias, wSlope, wVol, wDist, wPattern, useRR, signalPoints, baseTicks, r, breakEvenTicks, bETriggerTicks, bEOffset, trailATRMult, conservativeTieBreak, allowOverlapSignals, maxConcurrentSignals, minBarsBetweenSignals, cooldownBars, cooldownMinutes, targetSignalsPerHour, minScoreFloor, minScoreCeil, volSpikeZFloor, volSpikeZCeil, aTR14vs100Min, consolidationBars, consolidationRangeBoxes, useHigherTF, hTFMultiplier, useHourSideFilters, longOnlyHoursCsv, shortOnlyHoursCsv, blockWindowsCsv, showStatsPanel, profileName, showDrawObjects, maxSignalsToDraw, runQuickScan, quickScanDays, quickScanMaxBars, useShortTime, useDecimalComma, panelCorner, panelMargin, panelBgOpacity, resetStatsAtSession, resetNow, barColoring);
		}
	}
}

#endregion
