using System;
using System.Windows.Media;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.Data;

namespace NinjaTrader.NinjaScript.Indicators
{
    public class MagnoFluxScalperIndicator : Indicator
    {
        // === Configuración de filtros ===
        [NinjaScriptProperty] public int CooldownBars       { get; set; } = 1;
        [NinjaScriptProperty] public int MinConditions      { get; set; } = 2;
        [NinjaScriptProperty] public double VolumeThreshold { get; set; } = 1.3;
        [NinjaScriptProperty] public int SpeedTicks         { get; set; } = 18;
        [NinjaScriptProperty] public double BodyContextRatio { get; set; } = 0.3;
        [NinjaScriptProperty] public double SlopeMin         { get; set; } = 0.03;
        [NinjaScriptProperty] public string SessionStart     { get; set; } = "10:30";
        [NinjaScriptProperty] public string SessionEnd       { get; set; } = "13:00";

        // === Configuración de SL y TP ===
        [NinjaScriptProperty] public int StopLossTicks      { get; set; } = 40; // Cambia aquí el SL en ticks
        [NinjaScriptProperty] public int ProfitTargetTicks  { get; set; } = 28; // Cambia aquí el TP en ticks

        private int lastSignalBar = -1000;
        private TimeSpan sessionStart;
        private TimeSpan sessionEnd;

        private int seqCount = 1;

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name             = "MagnoFluxScalperIndicator";
                Calculate        = Calculate.OnBarClose;
                IsOverlay        = true;
                DisplayInDataBox = false;
            }
            else if (State == State.Configure)
            {
                sessionStart = TimeSpan.Parse(SessionStart);
                sessionEnd   = TimeSpan.Parse(SessionEnd);
            }
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < 60 || CurrentBar <= lastSignalBar + CooldownBars)
                return;

            var now = Time[0].TimeOfDay;
            if (now < sessionStart || now > sessionEnd)
                return;

            bool isBull  = Close[0] >= Open[0];
            bool prevBull = Close[1] >= Open[1];
            if (isBull == prevBull)
                seqCount++;
            else
                seqCount = 1;

            // 1) filtros: volumen, rapidez, cuerpo
            double avgVol    = SMA(Volume, 10)[0];
            bool volSpike    = Volume[0] > avgVol * VolumeThreshold;
            double fastMove  = Math.Abs(Close[0] - Close[2]) / TickSize;
            bool speedOk     = fastMove >= SpeedTicks;
            double bodySize  = Math.Abs(Close[0] - Open[0]);
            bool contextOk   = bodySize > (High[0] - Low[0]) * BodyContextRatio;

            int passCount = 0;
            if (volSpike)  passCount++;
            if (speedOk)   passCount++;
            if (contextOk) passCount++;

            // 2) pendiente EMA(14)
            double slope    = (EMA(14)[0] - EMA(14)[3]) / (3 * TickSize);
            bool upTrend    = slope > SlopeMin;
            bool downTrend  = slope < -SlopeMin;

            int[] shortPeriods = {3,5,8,10,12,15};
            int[] longPeriods  = {30,35,40,45,50,60};

            bool aboveShort = true;
            foreach (int p in shortPeriods)
            {
                if (Close[0] <= EMA(p)[0])
                {
                    aboveShort = false;
                    break;
                }
            }

            bool lowsAboveLong = true;
            for (int i = 1; i <= 3 && lowsAboveLong; i++)
            {
                foreach (int p in longPeriods)
                {
                    if (Low[i] <= EMA(p)[i])
                    {
                        lowsAboveLong = false;
                        break;
                    }
                }
            }

            bool guppyLong = aboveShort && lowsAboveLong;

            bool belowShort = true;
            foreach (int p in shortPeriods)
            {
                if (Close[0] >= EMA(p)[0])
                {
                    belowShort = false;
                    break;
                }
            }

            bool highsBelowLong = true;
            for (int i = 1; i <= 3 && highsBelowLong; i++)
            {
                foreach (int p in longPeriods)
                {
                    if (High[i] >= EMA(p)[i])
                    {
                        highsBelowLong = false;
                        break;
                    }
                }
            }

            bool guppyShort = belowShort && highsBelowLong;

            // 3) señal LONG
            if (upTrend && passCount >= MinConditions && seqCount >= 3 && guppyLong && Close[0] > Open[0])
            {
                Print($"{Time[0]:HH:mm:ss} - Signal LONG | TP: {ProfitTargetTicks} ticks | SL: {StopLossTicks} ticks");
                Draw.ArrowUp(this, "mfscalp_" + CurrentBar, true, 0, Low[0] - TickSize, Brushes.Lime);
                lastSignalBar = CurrentBar;
            }
            // 4) señal SHORT (opcional)
            else if (downTrend && passCount >= MinConditions && seqCount >= 3 && guppyShort && Close[0] < Open[0])
            {
                Print($"{Time[0]:HH:mm:ss} - Signal SHORT | TP: {ProfitTargetTicks} ticks | SL: {StopLossTicks} ticks");
                Draw.ArrowDown(this, "mfscalp_" + CurrentBar, true, 0, High[0] + TickSize, Brushes.Red);
                lastSignalBar = CurrentBar;
            }
        }
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MagnoFluxScalperIndicator[] cacheMagnoFluxScalperIndicator;
		public MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}

		public MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input, int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			if (cacheMagnoFluxScalperIndicator != null)
				for (int idx = 0; idx < cacheMagnoFluxScalperIndicator.Length; idx++)
					if (cacheMagnoFluxScalperIndicator[idx] != null && cacheMagnoFluxScalperIndicator[idx].CooldownBars == cooldownBars && cacheMagnoFluxScalperIndicator[idx].MinConditions == minConditions && cacheMagnoFluxScalperIndicator[idx].VolumeThreshold == volumeThreshold && cacheMagnoFluxScalperIndicator[idx].SpeedTicks == speedTicks && cacheMagnoFluxScalperIndicator[idx].BodyContextRatio == bodyContextRatio && cacheMagnoFluxScalperIndicator[idx].SlopeMin == slopeMin && cacheMagnoFluxScalperIndicator[idx].SessionStart == sessionStart && cacheMagnoFluxScalperIndicator[idx].SessionEnd == sessionEnd && cacheMagnoFluxScalperIndicator[idx].StopLossTicks == stopLossTicks && cacheMagnoFluxScalperIndicator[idx].ProfitTargetTicks == profitTargetTicks && cacheMagnoFluxScalperIndicator[idx].EqualsInput(input))
						return cacheMagnoFluxScalperIndicator[idx];
			return CacheIndicator<MagnoFluxScalperIndicator>(new MagnoFluxScalperIndicator(){ CooldownBars = cooldownBars, MinConditions = minConditions, VolumeThreshold = volumeThreshold, SpeedTicks = speedTicks, BodyContextRatio = bodyContextRatio, SlopeMin = slopeMin, SessionStart = sessionStart, SessionEnd = sessionEnd, StopLossTicks = stopLossTicks, ProfitTargetTicks = profitTargetTicks }, input, ref cacheMagnoFluxScalperIndicator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}

		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input , int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}

		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input , int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}
	}
}

#endregion
