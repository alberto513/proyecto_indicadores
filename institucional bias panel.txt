using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Linq;
using System.Windows.Media;
using System.Xml.Serialization;
using SharpDX;
using NinjaTrader.Cbi;
using NinjaTrader.Data;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.Tools;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.DrawingTools;

namespace NinjaTrader.NinjaScript.Indicators
{
    // Enum que representa el sesgo de cada condición y el general
    public enum BiasColor { Bull, Bear, Neutral }

    // Estructura para contener el estado actual de las tres condiciones
    public struct BiasState
    {
        public BiasColor VwapBias;
        public BiasColor DeltaBias;
        public BiasColor ImbalanceBias;
        public BiasColor OverallBias;

        public BiasState(BiasColor vwapBias, BiasColor deltaBias, BiasColor imbalanceBias, BiasColor overallBias)
        {
            VwapBias = vwapBias;
            DeltaBias = deltaBias;
            ImbalanceBias = imbalanceBias;
            OverallBias = overallBias;
        }
    }

    /// <summary>
    /// Panel gráfico que muestra un semáforo grande indicando el sesgo institucional
    /// basado en VWAP, delta acumulado e imbalance del libro de órdenes.
    /// Compatible con cualquier tipo de gráfico (incluye Wicked Renko).
    /// </summary>
    public class InstitutionalBiasPanel : Indicator
    {
        #region Campos privados
        // Variables para VWAP manual de sesión
        private double sumPV;
        private double sumV;
        private double manualVwap;

        // Delta acumulado manual
        private Series<double> manualCumDeltaSeries;
        private double manualCumDelta;

        // Estructuras para imbalance Level II
        private readonly object bookLock = new object();
        private readonly SortedDictionary<int, double> bidSizes = new SortedDictionary<int, double>();
        private readonly SortedDictionary<int, double> askSizes = new SortedDictionary<int, double>();
        private double totalBidSize;
        private double totalAskSize;

        // Fallback sin Level II
        private double aggressiveBuyVolume;
        private double aggressiveSellVolume;

        // Recursos gráficos
        private SharpDX.Direct2D1.Brush bullBrush;
        private SharpDX.Direct2D1.Brush bearBrush;
        private SharpDX.Direct2D1.Brush neutralBrush;
        private SharpDX.Direct2D1.Brush textBrush;
        private SharpDX.Direct2D1.Brush panelBgBrush;
        private SharpDX.Direct2D1.Brush panelBorderBrush;

        private SharpDX.DirectWrite.Factory dwFactory;
        private SharpDX.DirectWrite.TextFormat textFormat;
        #endregion

        #region Propiedades configurables
        [NinjaScriptProperty]
        [Display(Name = "PanelWidth", Order = 1, GroupName = "Visual", Description = "Ancho del panel.")]
        public int PanelWidth { get; set; } = 180;

        [NinjaScriptProperty]
        [Display(Name = "PanelHeight", Order = 2, GroupName = "Visual", Description = "Alto del panel.")]
        public int PanelHeight { get; set; } = 140;

        [NinjaScriptProperty]
        [Display(Name = "PanelX", Order = 3, GroupName = "Visual", Description = "Posición X del panel.")]
        public int PanelX { get; set; } = 20;

        [NinjaScriptProperty]
        [Display(Name = "PanelY", Order = 4, GroupName = "Visual", Description = "Posición Y del panel.")]
        public int PanelY { get; set; } = 20;

        [NinjaScriptProperty]
        [XmlIgnore]
        [Display(Name = "ColorBull", Order = 5, GroupName = "Visual", Description = "Color para condición alcista.")]
        public Brush ColorBull { get; set; } = Brushes.LimeGreen;

        [Browsable(false)]
        public string ColorBullSerializable
        {
            get { return Serialize.BrushToString(ColorBull); }
            set { ColorBull = Serialize.StringToBrush(value); }
        }

        [NinjaScriptProperty]
        [XmlIgnore]
        [Display(Name = "ColorBear", Order = 6, GroupName = "Visual", Description = "Color para condición bajista.")]
        public Brush ColorBear { get; set; } = Brushes.Red;

        [Browsable(false)]
        public string ColorBearSerializable
        {
            get { return Serialize.BrushToString(ColorBear); }
            set { ColorBear = Serialize.StringToBrush(value); }
        }

        [NinjaScriptProperty]
        [XmlIgnore]
        [Display(Name = "ColorNeutral", Order = 7, GroupName = "Visual", Description = "Color para condición neutral.")]
        public Brush ColorNeutral { get; set; } = Brushes.Gold;

        [Browsable(false)]
        public string ColorNeutralSerializable
        {
            get { return Serialize.BrushToString(ColorNeutral); }
            set { ColorNeutral = Serialize.StringToBrush(value); }
        }

        [NinjaScriptProperty]
        [XmlIgnore]
        [Display(Name = "TextColor", Order = 8, GroupName = "Visual", Description = "Color del texto.")]
        public Brush TextColor { get; set; } = Brushes.White;

        [Browsable(false)]
        public string TextColorSerializable
        {
            get { return Serialize.BrushToString(TextColor); }
            set { TextColor = Serialize.StringToBrush(value); }
        }

        [NinjaScriptProperty]
        [XmlIgnore]
        [Display(Name = "PanelBgColor", Order = 9, GroupName = "Visual", Description = "Color de fondo del panel.")]
        public Brush PanelBgColor { get; set; } = Brushes.DimGray;

        [Browsable(false)]
        public string PanelBgColorSerializable
        {
            get { return Serialize.BrushToString(PanelBgColor); }
            set { PanelBgColor = Serialize.StringToBrush(value); }
        }

        [NinjaScriptProperty]
        [XmlIgnore]
        [Display(Name = "PanelBorderColor", Order = 10, GroupName = "Visual", Description = "Color del borde del panel.")]
        public Brush PanelBorderColor { get; set; } = Brushes.Black;

        [Browsable(false)]
        public string PanelBorderColorSerializable
        {
            get { return Serialize.BrushToString(PanelBorderColor); }
            set { PanelBorderColor = Serialize.StringToBrush(value); }
        }

        [NinjaScriptProperty]
        [Display(Name = "VwapNearPct", Order = 11, GroupName = "Parametros", Description = "Porcentaje de cercanía al VWAP para estado neutral.")]
        public double VwapNearPct { get; set; } = 0.0005;

        [NinjaScriptProperty]
        [Display(Name = "DeltaLookbackBars", Order = 12, GroupName = "Parametros", Description = "Número de barras para la pendiente del delta acumulado.")]
        public int DeltaLookbackBars { get; set; } = 5;

        [NinjaScriptProperty]
        [Display(Name = "ImbalancePct", Order = 13, GroupName = "Parametros", Description = "Umbral de porcentaje de imbalance (p.ej. 0.60 = 60 %).")]
        public double ImbalancePct { get; set; } = 0.60;

        [NinjaScriptProperty]
        [Display(Name = "UseOrderFlowPlus", Order = 14, GroupName = "Parametros", Description = "Bandera para Order Flow+ (no usado).")]
        public bool UseOrderFlowPlus { get; set; } = true;

        [NinjaScriptProperty]
        [Display(Name = "UseLevel2Book", Order = 15, GroupName = "Parametros", Description = "Usar información de libro de órdenes Level II.")]
        public bool UseLevel2Book { get; set; } = true;

        [NinjaScriptProperty]
        [Display(Name = "FontFamily", Order = 16, GroupName = "Visual", Description = "Nombre de la fuente para el texto.")]
        public string FontFamily { get; set; } = "Arial";

        [NinjaScriptProperty]
        [Display(Name = "FontSize", Order = 17, GroupName = "Visual", Description = "Tamaño de la fuente.")]
        public int FontSize { get; set; } = 14;
        #endregion

        #region Métodos NinjaScript
        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name = "InstitutionalBiasPanel";
                Calculate = Calculate.OnEachTick;
                IsOverlay = true;
                BarsRequiredToPlot = 20;
            }
            else if (State == State.Configure)
            {
                manualCumDeltaSeries = new Series<double>(this);
            }
        }

        protected override void OnBarUpdate()
        {
            if (CurrentBar < BarsRequiredToPlot)
                return;

            bool firstBar = Bars.IsFirstBarOfSession;
            if (firstBar)
            {
                sumPV = sumV = 0;
                manualCumDelta = 0;
                aggressiveBuyVolume = aggressiveSellVolume = 0;
                lock (bookLock)
                {
                    bidSizes.Clear();
                    askSizes.Clear();
                    totalBidSize = totalAskSize = 0;
                }
            }

            // VWAP manual
            sumPV += Close[0] * Volume[0];
            sumV += Volume[0];
            manualVwap = sumV > 0 ? sumPV / sumV : Close[0];

            // Delta acumulado manual (regla de tick)
            double deltaBar = 0;
            if (CurrentBar > 0)
            {
                if (Close[0] > Close[1])
                    deltaBar = Volume[0];
                else if (Close[0] < Close[1])
                    deltaBar = -Volume[0];
            }
            manualCumDelta += deltaBar;
            manualCumDeltaSeries[0] = manualCumDelta;

            // Fallback imbalance sin Level II
            if (!UseLevel2Book)
            {
                if (Close[0] > Open[0])
                    aggressiveBuyVolume += Volume[0];
                else if (Close[0] < Open[0])
                    aggressiveSellVolume += Volume[0];
            }
        }

        protected override void OnMarketDepth(MarketDepthEventArgs e)
        {
            if (!UseLevel2Book)
                return;

            lock (bookLock)
            {
                SortedDictionary<int, double> book = e.MarketDataType == MarketDataType.Ask ? askSizes : bidSizes;

                // --- reemplazo robusto sin MarketDepthOperation ---
                string op = e.Operation != null ? e.Operation.ToString() : string.Empty; // "Add", "Update", "Remove", "Reset"

                if (op == "Reset")
                {
                    book.Clear();
                }
                else if (op == "Add" || op == "Update")
                {
                    book[e.Position] = e.Volume;
                }
                else if (op == "Remove")
                {
                    if (book.ContainsKey(e.Position))
                        book.Remove(e.Position);
                }

                totalBidSize = bidSizes.Values.Sum();
                totalAskSize = askSizes.Values.Sum();
            }
        }

        public override void OnRenderTargetChanged()
        {
            base.OnRenderTargetChanged();

            DisposeBrush(ref bullBrush);
            DisposeBrush(ref bearBrush);
            DisposeBrush(ref neutralBrush);
            DisposeBrush(ref textBrush);
            DisposeBrush(ref panelBgBrush);
            DisposeBrush(ref panelBorderBrush);

            textFormat?.Dispose();
            dwFactory?.Dispose();
            textFormat = null;
            dwFactory = null;

            if (RenderTarget != null)
            {
                bullBrush        = CreateDxBrush(ColorBull);
                bearBrush        = CreateDxBrush(ColorBear);
                neutralBrush     = CreateDxBrush(ColorNeutral);
                textBrush        = CreateDxBrush(TextColor);
                panelBgBrush     = CreateDxBrush(PanelBgColor);
                panelBorderBrush = CreateDxBrush(PanelBorderColor);

                dwFactory = new SharpDX.DirectWrite.Factory();
                textFormat = new SharpDX.DirectWrite.TextFormat(dwFactory, FontFamily, FontSize);
            }
        }

        private SharpDX.Direct2D1.SolidColorBrush CreateDxBrush(Brush wpf)
        {
            SolidColorBrush scb = wpf as SolidColorBrush ?? Brushes.White;
            System.Windows.Media.Color c = scb.Color;
            var col = new Color4(c.R / 255f, c.G / 255f, c.B / 255f, c.A / 255f);
            return new SharpDX.Direct2D1.SolidColorBrush(RenderTarget, col);
        }

        private void DisposeBrush(ref SharpDX.Direct2D1.Brush brush)
        {
            if (brush != null)
            {
                brush.Dispose();
                brush = null;
            }
        }

        protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
        {
            base.OnRender(chartControl, chartScale);
            if (RenderTarget == null)
                return;

            BiasColor vwapBias = EvaluateVWAP();
            BiasColor deltaBias = EvaluateDelta();
            BiasColor imbalanceBias = EvaluateImbalance();
            BiasColor overallBias = EvaluateOverall(vwapBias, deltaBias, imbalanceBias);

            BiasState state = new BiasState(vwapBias, deltaBias, imbalanceBias, overallBias);

            float x = PanelX;
            float y = PanelY;
            float w = PanelWidth;
            float h = PanelHeight;

            var rect = new SharpDX.RectangleF(x, y, w, h);
            var rounded = new SharpDX.Direct2D1.RoundedRectangle { Rect = rect, RadiusX = 5f, RadiusY = 5f };
            RenderTarget.FillRoundedRectangle(rounded, panelBgBrush);
            RenderTarget.DrawRoundedRectangle(rounded, panelBorderBrush, 1f);

            float ledSize = 20f;
            float padding = 10f;
            float lineHeight = 25f;

            DrawIndicatorState("VWAP", vwapBias, x + padding, y + padding, ledSize, lineHeight);
            DrawIndicatorState("Delta", deltaBias, x + padding, y + padding + lineHeight, ledSize, lineHeight);
            DrawIndicatorState("Imb", imbalanceBias, x + padding, y + padding + 2 * lineHeight, ledSize, lineHeight);

            float circleRadius = Math.Min(w, h) / 4f;
            float cx = x + w / 2f;
            float cy = y + (h + lineHeight) / 2f;
            var ellipse = new SharpDX.Direct2D1.Ellipse(new SharpDX.Vector2(cx, cy), circleRadius, circleRadius);
            var brush = GetBrushForBias(overallBias);
            RenderTarget.FillEllipse(ellipse, brush);

            string biasText = overallBias == BiasColor.Bull ? "Bias alcista" : overallBias == BiasColor.Bear ? "Bias bajista" : "Bias neutro";
            var layout = new SharpDX.DirectWrite.TextLayout(dwFactory, biasText, textFormat, 500, 50);
            var textPos = new SharpDX.Vector2(cx - layout.Metrics.Width / 2f, cy + circleRadius + 5f);
            RenderTarget.DrawTextLayout(textPos, layout, textBrush);
            layout.Dispose();
        }

        private void DrawIndicatorState(string label, BiasColor bias, float x, float y, float ledSize, float lineHeight)
        {
            var brush = GetBrushForBias(bias);
            var rect = new SharpDX.RectangleF(x, y, ledSize, ledSize);
            RenderTarget.FillRectangle(rect, brush);
            RenderTarget.DrawRectangle(rect, panelBorderBrush);

            var layout = new SharpDX.DirectWrite.TextLayout(dwFactory, label, textFormat, 200, lineHeight);
            var textPos = new SharpDX.Vector2(x + ledSize + 5f, y + (ledSize - layout.Metrics.Height) / 2f);
            RenderTarget.DrawTextLayout(textPos, layout, textBrush);
            layout.Dispose();
        }

        private SharpDX.Direct2D1.Brush GetBrushForBias(BiasColor bias)
        {
            switch (bias)
            {
                case BiasColor.Bull:
                    return bullBrush;
                case BiasColor.Bear:
                    return bearBrush;
                default:
                    return neutralBrush;
            }
        }
        #endregion

        #region Evaluadores
        private BiasColor EvaluateVWAP()
        {
            double c = Close[0];
            double v = manualVwap;
            double diffPct = Math.Abs(c - v) / Math.Max(Math.Abs(v), 1);
            if (diffPct <= VwapNearPct)
                return BiasColor.Neutral;
            return c > v ? BiasColor.Bull : BiasColor.Bear;
        }

        private BiasColor EvaluateDelta()
        {
            if (CurrentBar <= DeltaLookbackBars)
                return BiasColor.Neutral;

            double cum = manualCumDelta;
            double past = manualCumDeltaSeries[DeltaLookbackBars];
            double slope = cum - past;

            if (cum > 0 && slope > 0)
                return BiasColor.Bull;
            if (cum < 0 && slope < 0)
                return BiasColor.Bear;
            return BiasColor.Neutral;
        }

        private BiasColor EvaluateImbalance()
        {
            if (UseLevel2Book)
            {
                double buys;
                double sells;
                lock (bookLock)
                {
                    buys = totalAskSize;
                    sells = totalBidSize;
                }

                if (buys == 0 && sells == 0)
                    return BiasColor.Neutral;

                double ratio = buys / Math.Max(sells, 1);
                if (ratio >= 1 + ImbalancePct)
                    return BiasColor.Bull;
                if (ratio <= 1 / (1 + ImbalancePct))
                    return BiasColor.Bear;
                return BiasColor.Neutral;
            }
            else
            {
                double buys = aggressiveBuyVolume;
                double sells = aggressiveSellVolume;
                if (buys == 0 && sells == 0)
                    return BiasColor.Neutral;

                double ratio = buys / Math.Max(sells, 1);
                if (ratio >= 1 + ImbalancePct)
                    return BiasColor.Bull;
                if (ratio <= 1 / (1 + ImbalancePct))
                    return BiasColor.Bear;
                return BiasColor.Neutral;
            }
        }

        private BiasColor EvaluateOverall(BiasColor vwapBias, BiasColor deltaBias, BiasColor imbalanceBias)
        {
            if (vwapBias == BiasColor.Bull && deltaBias == BiasColor.Bull && imbalanceBias == BiasColor.Bull)
                return BiasColor.Bull;
            if (vwapBias == BiasColor.Bear && deltaBias == BiasColor.Bear && imbalanceBias == BiasColor.Bear)
                return BiasColor.Bear;
            return BiasColor.Neutral;
        }
        #endregion
    }

    /// <summary>
    /// Métodos de extensión para comparaciones de dobles
    /// </summary>
    public static class DoubleExtensions
    {
        public static int ApproxCompare(this double value, double other, double epsilon = 1e-8)
        {
            double diff = value - other;
            if (Math.Abs(diff) <= epsilon)
                return 0;
            return diff > 0 ? 1 : -1;
        }
    }
}



#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private InstitutionalBiasPanel[] cacheInstitutionalBiasPanel;
		public InstitutionalBiasPanel InstitutionalBiasPanel(int panelWidth, int panelHeight, int panelX, int panelY, Brush colorBull, Brush colorBear, Brush colorNeutral, Brush textColor, Brush panelBgColor, Brush panelBorderColor, double vwapNearPct, int deltaLookbackBars, double imbalancePct, bool useOrderFlowPlus, bool useLevel2Book, string fontFamily, int fontSize)
		{
			return InstitutionalBiasPanel(Input, panelWidth, panelHeight, panelX, panelY, colorBull, colorBear, colorNeutral, textColor, panelBgColor, panelBorderColor, vwapNearPct, deltaLookbackBars, imbalancePct, useOrderFlowPlus, useLevel2Book, fontFamily, fontSize);
		}

		public InstitutionalBiasPanel InstitutionalBiasPanel(ISeries<double> input, int panelWidth, int panelHeight, int panelX, int panelY, Brush colorBull, Brush colorBear, Brush colorNeutral, Brush textColor, Brush panelBgColor, Brush panelBorderColor, double vwapNearPct, int deltaLookbackBars, double imbalancePct, bool useOrderFlowPlus, bool useLevel2Book, string fontFamily, int fontSize)
		{
			if (cacheInstitutionalBiasPanel != null)
				for (int idx = 0; idx < cacheInstitutionalBiasPanel.Length; idx++)
					if (cacheInstitutionalBiasPanel[idx] != null && cacheInstitutionalBiasPanel[idx].PanelWidth == panelWidth && cacheInstitutionalBiasPanel[idx].PanelHeight == panelHeight && cacheInstitutionalBiasPanel[idx].PanelX == panelX && cacheInstitutionalBiasPanel[idx].PanelY == panelY && cacheInstitutionalBiasPanel[idx].ColorBull == colorBull && cacheInstitutionalBiasPanel[idx].ColorBear == colorBear && cacheInstitutionalBiasPanel[idx].ColorNeutral == colorNeutral && cacheInstitutionalBiasPanel[idx].TextColor == textColor && cacheInstitutionalBiasPanel[idx].PanelBgColor == panelBgColor && cacheInstitutionalBiasPanel[idx].PanelBorderColor == panelBorderColor && cacheInstitutionalBiasPanel[idx].VwapNearPct == vwapNearPct && cacheInstitutionalBiasPanel[idx].DeltaLookbackBars == deltaLookbackBars && cacheInstitutionalBiasPanel[idx].ImbalancePct == imbalancePct && cacheInstitutionalBiasPanel[idx].UseOrderFlowPlus == useOrderFlowPlus && cacheInstitutionalBiasPanel[idx].UseLevel2Book == useLevel2Book && cacheInstitutionalBiasPanel[idx].FontFamily == fontFamily && cacheInstitutionalBiasPanel[idx].FontSize == fontSize && cacheInstitutionalBiasPanel[idx].EqualsInput(input))
						return cacheInstitutionalBiasPanel[idx];
			return CacheIndicator<InstitutionalBiasPanel>(new InstitutionalBiasPanel(){ PanelWidth = panelWidth, PanelHeight = panelHeight, PanelX = panelX, PanelY = panelY, ColorBull = colorBull, ColorBear = colorBear, ColorNeutral = colorNeutral, TextColor = textColor, PanelBgColor = panelBgColor, PanelBorderColor = panelBorderColor, VwapNearPct = vwapNearPct, DeltaLookbackBars = deltaLookbackBars, ImbalancePct = imbalancePct, UseOrderFlowPlus = useOrderFlowPlus, UseLevel2Book = useLevel2Book, FontFamily = fontFamily, FontSize = fontSize }, input, ref cacheInstitutionalBiasPanel);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.InstitutionalBiasPanel InstitutionalBiasPanel(int panelWidth, int panelHeight, int panelX, int panelY, Brush colorBull, Brush colorBear, Brush colorNeutral, Brush textColor, Brush panelBgColor, Brush panelBorderColor, double vwapNearPct, int deltaLookbackBars, double imbalancePct, bool useOrderFlowPlus, bool useLevel2Book, string fontFamily, int fontSize)
		{
			return indicator.InstitutionalBiasPanel(Input, panelWidth, panelHeight, panelX, panelY, colorBull, colorBear, colorNeutral, textColor, panelBgColor, panelBorderColor, vwapNearPct, deltaLookbackBars, imbalancePct, useOrderFlowPlus, useLevel2Book, fontFamily, fontSize);
		}

		public Indicators.InstitutionalBiasPanel InstitutionalBiasPanel(ISeries<double> input , int panelWidth, int panelHeight, int panelX, int panelY, Brush colorBull, Brush colorBear, Brush colorNeutral, Brush textColor, Brush panelBgColor, Brush panelBorderColor, double vwapNearPct, int deltaLookbackBars, double imbalancePct, bool useOrderFlowPlus, bool useLevel2Book, string fontFamily, int fontSize)
		{
			return indicator.InstitutionalBiasPanel(input, panelWidth, panelHeight, panelX, panelY, colorBull, colorBear, colorNeutral, textColor, panelBgColor, panelBorderColor, vwapNearPct, deltaLookbackBars, imbalancePct, useOrderFlowPlus, useLevel2Book, fontFamily, fontSize);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.InstitutionalBiasPanel InstitutionalBiasPanel(int panelWidth, int panelHeight, int panelX, int panelY, Brush colorBull, Brush colorBear, Brush colorNeutral, Brush textColor, Brush panelBgColor, Brush panelBorderColor, double vwapNearPct, int deltaLookbackBars, double imbalancePct, bool useOrderFlowPlus, bool useLevel2Book, string fontFamily, int fontSize)
		{
			return indicator.InstitutionalBiasPanel(Input, panelWidth, panelHeight, panelX, panelY, colorBull, colorBear, colorNeutral, textColor, panelBgColor, panelBorderColor, vwapNearPct, deltaLookbackBars, imbalancePct, useOrderFlowPlus, useLevel2Book, fontFamily, fontSize);
		}

		public Indicators.InstitutionalBiasPanel InstitutionalBiasPanel(ISeries<double> input , int panelWidth, int panelHeight, int panelX, int panelY, Brush colorBull, Brush colorBear, Brush colorNeutral, Brush textColor, Brush panelBgColor, Brush panelBorderColor, double vwapNearPct, int deltaLookbackBars, double imbalancePct, bool useOrderFlowPlus, bool useLevel2Book, string fontFamily, int fontSize)
		{
			return indicator.InstitutionalBiasPanel(input, panelWidth, panelHeight, panelX, panelY, colorBull, colorBear, colorNeutral, textColor, panelBgColor, panelBorderColor, vwapNearPct, deltaLookbackBars, imbalancePct, useOrderFlowPlus, useLevel2Book, fontFamily, fontSize);
		}
	}
}

#endregion
