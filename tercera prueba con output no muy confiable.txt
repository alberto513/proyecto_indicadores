#region Using declarations
using System;
using System.Collections.Generic;
using System.Windows.Media;
using NinjaTrader.NinjaScript;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.Data;
#endregion

namespace NinjaTrader.NinjaScript.Indicators
{
    public class MagnoFluxScalperIndicator : Indicator
    {
        // === Configuración de filtros ===
        [NinjaScriptProperty] public int CooldownBars       { get; set; } = 1;
        [NinjaScriptProperty] public int MinConditions      { get; set; } = 2;
        [NinjaScriptProperty] public double VolumeThreshold { get; set; } = 1.3;
        [NinjaScriptProperty] public int SpeedTicks         { get; set; } = 18;
        [NinjaScriptProperty] public double BodyContextRatio { get; set; } = 0.3;
        [NinjaScriptProperty] public double SlopeMin         { get; set; } = 0.03;
        [NinjaScriptProperty] public string SessionStart     { get; set; } = "10:30";
        [NinjaScriptProperty] public string SessionEnd       { get; set; } = "13:00";

        // === Configuración de SL y TP ===
        [NinjaScriptProperty] public int StopLossTicks      { get; set; } = 40; // Cambia aquí el SL en ticks
        [NinjaScriptProperty] public int ProfitTargetTicks  { get; set; } = 28; // Cambia aquí el TP en ticks

        private int lastSignalBar = -1000;
        private TimeSpan sessionStart;
        private TimeSpan sessionEnd;
        private int seqCount = 1;

        private class SignalData
        {
            public int SignalBar;
            public int EntryBar;
            public DateTime Time;
            public bool IsLong;
            public double EntryPrice;
            public double TP;
            public double SL;
            public bool Done = false;
            public int BarsHeld;
            public double DurationSeconds;
            public double TradeEfficiency;
        }

        private List<SignalData> signals = new List<SignalData>();

        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                Name             = "MagnoFluxScalperIndicator";
                Calculate        = Calculate.OnBarClose;
                IsOverlay        = true;
                DisplayInDataBox = false;

                AddPlot(Brushes.Transparent, "SignalDir");
            }
            else if (State == State.Configure)
            {
                sessionStart = TimeSpan.Parse(SessionStart);
                sessionEnd   = TimeSpan.Parse(SessionEnd);
            }
        }

        protected override void OnBarUpdate()
        {
            Values[0][0] = 0;

            foreach (var sig in signals)
            {
                if (sig.Done || CurrentBar <= sig.EntryBar)
                    continue;

                bool tpHit = sig.IsLong ? High[0] >= sig.TP : Low[0] <= sig.TP;
                bool slHit = sig.IsLong ? Low[0] <= sig.SL : High[0] >= sig.SL;

                if (tpHit || slHit)
                {
                    sig.BarsHeld = CurrentBar - sig.EntryBar;
                    sig.DurationSeconds = (Time[0] - sig.Time).TotalSeconds;
                    sig.TradeEfficiency = tpHit ? 100.0 : 0.0;
                    sig.Done = true;

                    string result = tpHit ? "TP" : "SL";
                    Print($"{(sig.IsLong ? "LONG" : "SHORT")}={sig.Time:HH:mm:ss} - Señal={sig.EntryPrice:F2} - Entrada={sig.EntryPrice:F2} - TP={sig.TP:F2} - SL={sig.SL:F2} - Resultado={result} - Bars={sig.BarsHeld} - Duration={sig.DurationSeconds:F0}s - Efficiency={sig.TradeEfficiency}%");
                }
            }

            if (CurrentBar < 60 || CurrentBar <= lastSignalBar + CooldownBars)
                return;

            var now = Time[0].TimeOfDay;
            if (now < sessionStart || now > sessionEnd)
                return;

            bool isBull  = Close[0] >= Open[0];
            bool prevBull = Close[1] >= Open[1];
            if (isBull == prevBull)
                seqCount++;
            else
                seqCount = 1;

            double avgVol    = SMA(Volume, 10)[0];
            bool volSpike    = Volume[0] > avgVol * VolumeThreshold;
            double fastMove  = Math.Abs(Close[0] - Close[2]) / TickSize;
            bool speedOk     = fastMove >= SpeedTicks;
            double bodySize  = Math.Abs(Close[0] - Open[0]);
            bool contextOk   = bodySize > (High[0] - Low[0]) * BodyContextRatio;

            int passCount = 0;
            if (volSpike)  passCount++;
            if (speedOk)   passCount++;
            if (contextOk) passCount++;

            double slope    = (EMA(14)[0] - EMA(14)[3]) / (3 * TickSize);
            bool upTrend    = slope > SlopeMin;
            bool downTrend  = slope < -SlopeMin;

            int[] shortPeriods = {3,5,8,10,12,15};
            int[] longPeriods  = {30,35,40,45,50,60};

            bool aboveShort = true;
            foreach (int p in shortPeriods)
            {
                if (Close[0] <= EMA(p)[0])
                {
                    aboveShort = false;
                    break;
                }
            }

            bool lowsAboveLong = true;
            for (int i = 1; i <= 3 && lowsAboveLong; i++)
            {
                foreach (int p in longPeriods)
                {
                    if (Low[i] <= EMA(p)[i])
                    {
                        lowsAboveLong = false;
                        break;
                    }
                }
            }

            bool guppyLong = aboveShort && lowsAboveLong;

            bool belowShort = true;
            foreach (int p in shortPeriods)
            {
                if (Close[0] >= EMA(p)[0])
                {
                    belowShort = false;
                    break;
                }
            }

            bool highsBelowLong = true;
            for (int i = 1; i <= 3 && highsBelowLong; i++)
            {
                foreach (int p in longPeriods)
                {
                    if (High[i] >= EMA(p)[i])
                    {
                        highsBelowLong = false;
                        break;
                    }
                }
            }

            bool guppyShort = belowShort && highsBelowLong;

            if (upTrend && passCount >= MinConditions && seqCount >= 3 && guppyLong && Close[0] > Open[0])
            {
                Print($"{Time[0]:HH:mm:ss} - Signal LONG | TP: {ProfitTargetTicks} ticks | SL: {StopLossTicks} ticks");
                Draw.ArrowUp(this, "mfscalp_" + CurrentBar, true, 0, Low[0] - TickSize, Brushes.Lime);
                Values[0][0] = 1;
                lastSignalBar = CurrentBar;
                signals.Add(new SignalData {
                    SignalBar = CurrentBar,
                    EntryBar  = CurrentBar + 1,
                    Time      = Time[0],
                    IsLong    = true,
                    EntryPrice = Open[1],
                    TP = Open[1] + ProfitTargetTicks * TickSize,
                    SL = Open[1] - StopLossTicks * TickSize
                });
            }
            else if (downTrend && passCount >= MinConditions && seqCount >= 3 && guppyShort && Close[0] < Open[0])
            {
                Print($"{Time[0]:HH:mm:ss} - Signal SHORT | TP: {ProfitTargetTicks} ticks | SL: {StopLossTicks} ticks");
                Draw.ArrowDown(this, "mfscalp_" + CurrentBar, true, 0, High[0] + TickSize, Brushes.Red);
                Values[0][0] = -1;
                lastSignalBar = CurrentBar;
                signals.Add(new SignalData {
                    SignalBar = CurrentBar,
                    EntryBar  = CurrentBar + 1,
                    Time      = Time[0],
                    IsLong    = false,
                    EntryPrice = Open[1],
                    TP = Open[1] - ProfitTargetTicks * TickSize,
                    SL = Open[1] + StopLossTicks * TickSize
                });
            }
        }
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private MagnoFluxScalperIndicator[] cacheMagnoFluxScalperIndicator;
		public MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}

		public MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input, int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			if (cacheMagnoFluxScalperIndicator != null)
				for (int idx = 0; idx < cacheMagnoFluxScalperIndicator.Length; idx++)
					if (cacheMagnoFluxScalperIndicator[idx] != null && cacheMagnoFluxScalperIndicator[idx].CooldownBars == cooldownBars && cacheMagnoFluxScalperIndicator[idx].MinConditions == minConditions && cacheMagnoFluxScalperIndicator[idx].VolumeThreshold == volumeThreshold && cacheMagnoFluxScalperIndicator[idx].SpeedTicks == speedTicks && cacheMagnoFluxScalperIndicator[idx].BodyContextRatio == bodyContextRatio && cacheMagnoFluxScalperIndicator[idx].SlopeMin == slopeMin && cacheMagnoFluxScalperIndicator[idx].SessionStart == sessionStart && cacheMagnoFluxScalperIndicator[idx].SessionEnd == sessionEnd && cacheMagnoFluxScalperIndicator[idx].StopLossTicks == stopLossTicks && cacheMagnoFluxScalperIndicator[idx].ProfitTargetTicks == profitTargetTicks && cacheMagnoFluxScalperIndicator[idx].EqualsInput(input))
						return cacheMagnoFluxScalperIndicator[idx];
			return CacheIndicator<MagnoFluxScalperIndicator>(new MagnoFluxScalperIndicator(){ CooldownBars = cooldownBars, MinConditions = minConditions, VolumeThreshold = volumeThreshold, SpeedTicks = speedTicks, BodyContextRatio = bodyContextRatio, SlopeMin = slopeMin, SessionStart = sessionStart, SessionEnd = sessionEnd, StopLossTicks = stopLossTicks, ProfitTargetTicks = profitTargetTicks }, input, ref cacheMagnoFluxScalperIndicator);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}

		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input , int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(Input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}

		public Indicators.MagnoFluxScalperIndicator MagnoFluxScalperIndicator(ISeries<double> input , int cooldownBars, int minConditions, double volumeThreshold, int speedTicks, double bodyContextRatio, double slopeMin, string sessionStart, string sessionEnd, int stopLossTicks, int profitTargetTicks)
		{
			return indicator.MagnoFluxScalperIndicator(input, cooldownBars, minConditions, volumeThreshold, speedTicks, bodyContextRatio, slopeMin, sessionStart, sessionEnd, stopLossTicks, profitTargetTicks);
		}
	}
}

#endregion
